<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>操作系统・简述</title>
    <url>/2021/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="并发、共享、虚拟、异步"><a href="#并发、共享、虚拟、异步" class="headerlink" title="并发、共享、虚拟、异步"></a>并发、共享、虚拟、异步</h2><p>没有并发和共享，就没有虚拟和异步</p>
<p>并发和共享互为存在条件</p>
<p>只有系统有并发性，才能导致异步性</p>
<h2 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h2><p>联机：交互式</p>
<p>脱机：批处理</p>
<h2 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h2><p>系统调用（广义指令）</p>
<h2 id="操作系统用作扩充机器"><a href="#操作系统用作扩充机器" class="headerlink" title="操作系统用作扩充机器"></a>操作系统用作扩充机器</h2><p>没有任何软件支持的计算机称为裸机</p>
<p>覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></p>
<h2 id="操作系统发展"><a href="#操作系统发展" class="headerlink" title="操作系统发展"></a>操作系统发展</h2><p>手工操作系统：独占全机、CPU 等待手工操作</p>
<p>单道批处理操作系统：解决人机矛盾、CPU 和 I/O 设备速率不匹配、每次主机内存仅存放一道作业</p>
<p>多道批处理操作系统：资源利用率高、用户响应时间长、不提供人机交互</p>
<p>分时操作系统：同时、交互、独立、及时</p>
<p>实时操作系统：及时、可靠</p>
<p>网络操作系统</p>
<p>分布式计算机系统</p>
<p>个人操作系统</p>
<h2 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h2><p>CPU 的状态划分为用户态、核心态</p>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断（外中断）：CPU 执行指令意外的事件【设备发出的 I/O 结束中断】</p>
<p>异常（内中断、陷入）：CPU 执行指令内部的事件【非法操作码、地址越界、算术溢出、虚拟存储系统的缺页、陷入指令】</p>
<h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">关中断1--保存断点</span><br><span class="line">保存断点--中断服务程序寻址</span><br><span class="line">中断服务程序寻址--保存现场和屏蔽字</span><br><span class="line">保存现场和屏蔽字--开中断1</span><br><span class="line">开中断1--执行中断服务程序</span><br><span class="line">执行中断服务程序--关中断2</span><br><span class="line">关中断2--恢复现场和屏蔽字</span><br><span class="line">恢复现场和屏蔽字--开中断2</span><br><span class="line">开中断2--中断返回</span><br></pre></td></tr></tbody></table></figure>
<p><img src="../imgs/OS/os_1.png" alt="os_1"></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>用户程序中调用操作系统提供的子功能</p>
<p>程序员可以使用高级语言，估计又要可以调用库函数，有的库函数封装了系统调用</p>
<p>用户进程执行 调用系统调用 <strong>进入核心态</strong> 执行系统调用 <strong>退出核心态</strong> 从系统调用返回</p>
<h2 id="大内核-微内核"><a href="#大内核-微内核" class="headerlink" title="大内核 微内核"></a>大内核 微内核</h2><p>大内核：内核代码庞大、结构混乱、难以维护、提供高性能系统服务</p>
<p>微内核：分离内核与服务、频繁切换用户核心态、操作系统执行开销大、内核内容少、方便维护</p>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p>进程：程序段、数据段、PCB 进程控制块</p>
<p>进程映像是静态的，进程是动态的</p>
<p>动态、并发、独立、异步、结构</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>运行、就绪、阻塞、创建、结束</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>共享存储（需要同步互斥工具 PV 操作、低级：基于共享数据结构、高级：基于存储区）</p>
<p>消息传递（进程间数据交换以格式化消息为单位、直接 / 间接）</p>
<p>管道通信（pipe 文件用于连接一个读进程和写进程通信、半双工、全双工需要两条管道）</p>
<h2 id="线程-多线程"><a href="#线程-多线程" class="headerlink" title="线程 多线程"></a>线程 多线程</h2><p>引入进程目的：更好的使多道程序<strong>并发</strong>执行</p>
<p>引入线程目的：减小程序在并发执行付出的时空开销，提高并发性能</p>
<p>线程：线程 ID、程序计数器、寄存器结合、堆栈组合、三态【就绪、阻塞、运行】</p>
<p>轻量实体，无系统资源，唯一 ID 和线程控制块</p>
<p>用户级线程 ULT：操作系统意识不到 ULT 的存在，有关线程管理由应用程序完成</p>
<p>内核级线程 KLT：有关线程管理由内核完成</p>
<p>多线程模型：多对一、一对一、多对多（m&lt;=n）</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>调度层次：作业调度（高）、内存调度（中）、进程调度（低）</p>
<p>不能进行进程调度与切换：处理中断、进程处于内核态、其他需要完全屏蔽中断的原子操作</p>
<p>调度方式：非剥夺调度（非抢占方式、适用于大多批处理系统、不能用于分时系统和大多数的实时系统）、剥夺调度（抢占方式、有优先权、短进程优先、时间片原则）</p>
<p>调度基本原则：CPU 利用率、系统吞吐量、周转时间、等待时间、响应时间</p>
<p>系统吞吐量：单位时间内 CPU 完成作业的数量</p>
<p>周转时间：从作业提交到作业完成所用时间</p>
<script type="math/tex; mode=display">
T=t_{等待}+t_{就绪队列排队}+t_{上处理机运行及输入输出}\\
t_{周转时间}=t_{作业完成时间}-t_{作业提交时间}\\
t_{平均周转时间}=\frac{\sum_i^n{t_i}}{n}(作业i的周转时间：t_i)\\
t_{带权周转时间}=\frac{t_{作业周转时间}}{t_{作业实际运转}}\geq{1}\\
t_{带权平均周转时间}=\frac{\sum_i^n{t_i}}{n}(作业i的带权周转时间：t_i)\\</script><p>等待时间：进程处于等处理机状态的时间和</p>
<p>响应时间：从用户提交请求到系统首次产生响应所用时间</p>
<p><strong>调度算法</strong>：先来先服务（FCFS、非抢占）、短作业优先（SJF、SPF）、抢占式短作业优先（SRTN）、优先级调度、高响应比优先（HRRN）、时间片轮转调度（RR）、多级反馈队列调度</p>
<p>1. 先来先服务（FCFS）：简单，效率低；对长作业有利，对短作业不利；有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业；不会导致饥饿；多用于早期批处理系统</p>
<p>2. 短作业优先（SJF、SPF）：当前已到达的最短作业先上处理机；有优先权、短进程优先、时间片原则；适用于实时 / 分时操作系统；调度机制导致长作业长时间不被调度（饥饿）；多用于早期批处理系统</p>
<p>3. 抢占式短作业优先（SRTN）：最短剩余时间算法</p>
<p>4. 优先级调度：适用于实时操作系统；剥夺、非剥夺、静态优先级、动态优先级；系统进程用户进程 交互型进程非交互型进程 I/O 型进程计算型进程；不导致饥饿</p>
<p>5. 高响应比优先（HRRN）：多用于早期批处理系统</p>
<script type="math/tex; mode=display">
响应比R_p=\frac{t_{等待时间}+t_{要求服务时间}}{t_{要求服务时间}}\geq{1}\\</script><p>6. 时间片轮转调度（RR）：时间片大小设置对系统性能影响很大，时间片足够大，以至于所有进程都能在一个时间片完成，退化为先来先服务算法；时间片太小，处理机频繁在进程间切换，增加处理机开销；时间片长短由系统的响应时间、就绪队列的进程数目、系统处理能力决定；不会导致饥饿</p>
<p>7. 多级反馈队列调度：设置多个就绪队列，各个队列赋予不同优先级，赋予各个队列中进程执行时间片的大小各个不同，一个进程进入内存后挂在一级队列队尾，时间片内未完成进入第二级队列队尾，第一级队列为空下一级运行；课本认为是抢占式算法；</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>临界资源：进入区、临界区、退出区、剩余区</p>
<p>同步：完成某种任务而建立的两个或多个进程，需要协调制约关系</p>
<p>互斥：一个进程使用临界资源另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程允许访问临界资源</p>
<p>为禁止两个进程进入同一个临界区，指定准则：</p>
<p>（1）空闲让进</p>
<p>（2）忙则等待</p>
<p>（3）有限等待</p>
<p>（4）让权等待</p>
<p>实现互斥基本方法：</p>
<p>（1）软件：单标志法（违背空闲让进）、双标志法先检查（违法忙则等待）、双标志法后检查（导致饥饿、违背空闲让进、有限等待）、皮特森算法 Peterson’s Algorithm（违法让权等待）</p>
<p>（2）硬件：中断屏蔽方法（禁止一切中断发生、优：简单高效 / 缺：不适用多处理机、用户进程，只适用于系统内核进程）、硬件指令方法 TS/TSL（优：适用于任意数目的进程，无论是单处理机还是多处理机，简单容易验证其正确性 / 缺：不能实现让权等待，从等待中随机选择一个进临界区，可能导致饥饿）</p>
<p><strong>信号量</strong></p>
<p>整型信号量：用于表示资源数目的整型量 S，只要信号量 S&lt;=0，就会不断测试，违背让权等待</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S){</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)</span><br><span class="line">        S = S - <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">signal</span>(S){</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>记录型信号量：一个用于记录资源数目的整型量 value，一个进程链表 L，链接等待资源的进程，S.L 解决了让权等待的问题</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;</span><br><span class="line">}semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>{</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>){</span><br><span class="line">        add <span class="keyword">this</span> process P to S.L;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">block</span>(S.L);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>{</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>){</span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        <span class="built_in">wakeup</span>(P);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>利用信号量实现同步：前 V 后 P，必须保证一前一后，实现同步关系</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">P1</span>(){</span><br><span class="line">    x;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="built_in">P2</span>(){</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    y;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>利用信号量实现互斥：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">seamphore S = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">P1</span>(){</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    进程P1的临界区;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="built_in">P2</span>(){</span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">P</span>(S);</span><br><span class="line">   进程P2的临界区</span><br><span class="line">   <span class="built_in">V</span>(S);</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>利用信号量实现前驱关系：</p>
<p>对不同的临界资源设置不同的互斥信号量，PV 必须成对出现</p>
<p><img src="../imgs/OS/OS_mutex.png" alt="OS_mutex"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">semaphore a1 = a2 = b1 = b2 = c = d = e = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S1</span>(){</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(a1);</span><br><span class="line">    <span class="built_in">V</span>(a2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">S2</span>(){</span><br><span class="line">    <span class="built_in">P</span>(a1);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(b1);</span><br><span class="line">    <span class="built_in">V</span>(b2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">S3</span>(){</span><br><span class="line">    <span class="built_in">P</span>(a2);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">S4</span>(){</span><br><span class="line">    <span class="built_in">P</span>(b1);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(d);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">S5</span>(){</span><br><span class="line">    <span class="built_in">P</span>(b2);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">S6</span>(){</span><br><span class="line">    <span class="built_in">P</span>(c);</span><br><span class="line">    <span class="built_in">P</span>(d);</span><br><span class="line">    <span class="built_in">P</span>(e);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>另一角度：图论出度（P）入度（V）</p>
<p><strong>管程</strong></p>
<p>名称、共享结构数据、一组过程（函数）、设置共享结构数据初值</p>
<p>互斥特性由编译器负责实现</p>
<p>各外部进程 / 线程，只能从管程提供的特定入口才能访问共享数据</p>
<p>每次只允许一个进程在管程内执行某个内部过程</p>
<p><strong>经典同步问题</strong></p>
<p><em>1. 生产者消费者问题</em></p>
<ul>
<li><p>一组生产者进程 (Producer)</p>
</li>
<li><p>一组消费者进程 (Consumer)</p>
</li>
<li><p>共享初始为空 大小为 n 的缓冲区 (Buffer)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">semaphore mutex = 1;  //mutex</span><br><span class="line">semaphore empty = n;  //buffer</span><br><span class="line">semaphore full = 0;   //full</span><br><span class="line"></span><br><span class="line">Producer(){</span><br><span class="line">	while(1){</span><br><span class="line">		Produce();</span><br><span class="line">		P(mutex);</span><br><span class="line">		add2Buffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Consumer(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(full);</span><br><span class="line">		P(mutex);</span><br><span class="line">		getFromBuffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		Consume();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>2. 读者写者问题</em></p>
<ul>
<li>读者进程 (Reader)</li>
<li> 写者进程 (Writer)</li>
<li> 共享一个文档 (Document)</li>
<li> 多进程读，不可多进程写</li>
<li>写进程写，不可读</li>
<li>写进程检查是否有读进程读</li>
</ul>
<p><strong>读进程优先</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">Reader(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Writer(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(rw);</span><br><span class="line">		write();</span><br><span class="line">		v(rw);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>写进程优先</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">semaphore w = 1;</span><br><span class="line">Writer(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(w);</span><br><span class="line">		P(rw);</span><br><span class="line">		Write();</span><br><span class="line">		V(rw);</span><br><span class="line">		V(w);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Reader(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(w);</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(w);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>3. 哲学家进餐问题</em></p>
<ul>
<li>5 名哲学家 (Philosopher)</li>
<li> 每两名之间有一根筷子 (Chopstick)</li>
<li> 每名有一碗饭</li>
<li>吃完饭思考 </li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">semaphore Chopsticks[5] = {1, 1, 1, 1, 1};</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">Philosopher(){</span><br><span class="line">	do{</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(Chopsticks[i]);</span><br><span class="line">		P(Chopsticks[(i+1)%5]);</span><br><span class="line">		V(mutex);</span><br><span class="line">		eat();</span><br><span class="line">		V(Chopsticks[i]);</span><br><span class="line">		V(Chopsticks[(i+1)%5]);</span><br><span class="line">		think();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4. 吸烟者问题</strong></p>
<ul>
<li>3 个吸烟者进程 (Smoker)</li>
<li>1 个提供者进程 (Offer)</li>
<li>Smoker1(paper, glue)</li>
<li>Smoker2(tobacco, glue)</li>
<li>Smoker3(paper, tobacco)</li>
<li>Offer(offer1) return paper, glue</li>
<li>Offer(offer2) return tobacco, glue</li>
<li>Offer(offer3) return paper, tobacco</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int num = 0;	//store random num</span><br><span class="line">semaphore offer1 = 0;</span><br><span class="line">semaphore offer2 = 0;</span><br><span class="line">semaphore offer3 = 0;</span><br><span class="line">semaphore end = 0;</span><br><span class="line">Offer(){</span><br><span class="line">	whlie(1){</span><br><span class="line">		num++;</span><br><span class="line">		num = num % 3;</span><br><span class="line">		if(num == 0)</span><br><span class="line">			V(offer1);</span><br><span class="line">		else if(num == 1)</span><br><span class="line">			V(offer2);</span><br><span class="line">		else</span><br><span class="line">			V(offer3);</span><br><span class="line">		P(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Smoker1(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(offer3);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Smoker2(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(offer2);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Smoker3(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(offer1);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>eg1</em></p>
<ul>
<li>3 个进程 P1 P2 P3</li>
<li> 互斥使用 N 个单元的缓冲区 (Buffer)</li>
<li>P1 produce() return (int num) put() @Buffer</li>
<li>P2 </li>
</ul>
<p><strong>死锁</strong></p>
<p>多个进程因竞争资源造成的一种互相等待，若无外力作用，这些进程都将无法向前推进</p>
<p>死锁产生的原因：（1）系统资源的竞争（2）进程推进顺序非法（3）死锁产生的必要条件：互斥条件、不剥夺条件（已经至少保持了一个资源）、请求并保持条件、循环等待条件</p>
<p><strong>发生死锁一定有循环等待，但发生循环等待未必死锁</strong></p>
<p><strong>死锁的处理策略</strong></p>
<p><strong>死锁预防</strong>：破坏四个必要条件之一即可</p>
<ul>
<li><p>破坏互斥条件</p>
</li>
<li><p>破坏不剥夺条件</p>
</li>
<li><p>破坏请求并保持条件</p>
</li>
<li><p>破坏循环等待条件</p>
</li>
</ul>
<p>死锁避免：在资源分配过程，防止进入不安全状态</p>
<ul>
<li>银行家算法 </li>
</ul>
<script type="math/tex; mode=display">Need = Max -Allocation</script><p>死锁检测和解除：系统分配进程时不做措施，应该提供死锁检测和解除的手段</p>
<ul>
<li>资源分配图</li>
</ul>
<p><img src="../imgs/OS/source_allocation.png" alt="source_allocation"></p>
<p>请求边：从进程到资源<br>分配边：从资源到进程</p>
<ul>
<li>死锁定理：依次消除与不阻塞进程相连接的边，直到无边可消除</li>
<li>死锁解除：资源剥夺法、撤销进程法、进程回退法</li>
</ul>
<h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><p><strong>程序装入和链接</strong></p>
<ul>
<li>编译：编译程序将源代码编译成若干目标模块</li>
<li>链接：链接程序将编译后形成一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块</li>
<li>装入：装入程序装入模块装入内存运行</li>
</ul>
<p>链接方式</p>
<ul>
<li>静态：程序运行前，链接为一个完整可执行的程序</li>
<li>装入时动态：装入过程中，边装入边链接</li>
<li>运行时动态：程序执行过程需要该模块才进行</li>
</ul>
<p>装入方式：</p>
<ul>
<li>绝对装入：仅适用于单道程序，装入程序按照装入模块中的地址，将程序数据装入内存，逻辑地址与物理地址完全相同</li>
<li>可重定位装入（静态重定位）：一个作业装入内存，<strong>必须给它分配要求的全部内存空间</strong>，若没有足够的内存，则无法装入。一旦运行，作业进入内存，整个运行期间不能在内存中移动，也不能再申请内存空间</li>
<li>动态运行时装入（动态重定位）：程序在内存中发生移动，则需要采用动态的装入方式。装入程序把装入内存后，并不立即将装入模块中的相对地址转换为绝对地址，而是将<strong>地址转换推迟到程序真正要执行时才进行</strong>，需要重定位寄存器的支持</li>
</ul>
<p>逻辑地址和物理地址</p>
<ul>
<li>地址重定位：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成为物理地址</li>
</ul>
<p>内存保护</p>
<ul>
<li>在 CPU 中设置一堆上、下限寄存器，CPU 要访问一个地址，分别和两个寄存器值相比，判断有无越界</li>
<li>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）来实现这种保护</li>
</ul>
<p><strong>连续分配管理方式</strong></p>
<p>单一连续分配</p>
<p>内存分为系统区、用户区，无需进行内存保护，内存中只允许有有一道程序</p>
<ul>
<li>优 简单无外部碎片</li>
<li>缺 只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低</li>
</ul>
<p><strong>固定分区分配</strong></p>
<p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，可从外存的后备作业队列中选择适当大小的作业装入</p>
<ul>
<li>划分分区方式：分区大小相等、分区大小不等</li>
</ul>
<p>问题</p>
<ul>
<li>程序可能太大放不进任何一块分区，用户不得不使用覆盖技术使用内存空间</li>
<li>主存利用率低，程序小也要占用一个分区，现象称为<strong>内部碎片</strong></li>
</ul>
<p><strong>动态分区分配</strong></p>
<p>又称可变分区分配，不预先划分内存，在进程装入内存时，根据进程大小动态地建立分区，并使分区的大小正好适合进程的需要</p>
<p>问题：所有分区外的存储空间会产生越来越多的碎片，克服外部碎片可以通过紧凑技术来解决</p>
<p>动态分区策略</p>
<ul>
<li><p>首次适应 Fiist Fit：空闲分区以地址递增的次序链接，找到大小能满足要求的第一个空间。会使得内存的低地址部分出现很多小的空闲分区，每次分配查找时，都要经过这些分区，增加了查找的开销</p>
</li>
<li><p>最佳适应 Best Fit：空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空间。性能通常很差，因为每次最佳的分配会留下很小难以利用的内存块，会产生最多的外部碎片。</p>
</li>
<li><p>最坏适应 Worst Fit（最大适应 Lasgest Fit）: 以容量递减的次序链接，找到第一个能满足要求的空闲分区。选择最大的块，但却把最大的连续内存的划分开，会很快导致没有可用的大内存块，导致性能很差</p>
</li>
<li><p>邻近适用 Next Fit（循环首次适应算法）：分配内存时从上次查询结束的位置开始继续查找。在一次扫描中，内存前面部分使用后再释放时，不会参与分配，导致在内存的末尾分配空间分裂为小碎片。</p>
</li>
</ul>
<p><strong><em>非连续分配</em></strong> </p>
<p><strong>基本分页存储管理方式</strong>：主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程以块为单位进行划分，进程在执行时，以块为单位逐个申请贮存中的空间</p>
<p>分页管理不会产生外部碎片，块的大小相对分区要小，进程按块划分，进程运行时按块申请主存可用空间并执行，进程只会在最后一个不完整的块，不产生主存碎片，，每个进程平均只产生半个块大小的内部碎片</p>
<ul>
<li><p>页面和页面大小：进程中的块称为页（page），内存中的块称为页框（page frame、或页帧）。外存也以同样的单位进行划分，称为块（block）。进程在执行时需要申请主存空间，要为每个页面分配主存中的可用页框，页和页框一一对应</p>
</li>
<li><p>地址结构</p>
</li>
</ul>
<p><img src="../imgs/OS/single_page.png" alt="single_page"></p>
<ul>
<li>页表：通过查找页表即可找到相应的物理块</li>
</ul>
<p>基本地址变换：</p>
<p>将逻辑地址变换为内存中的物理地址，在系统中设置页表寄存器（PTR）存放内存起始地址 F 和页表长度 M。</p>
<p><img src="../imgs/OS/page_allocation_transform.png" alt="page_allocation_transform"></p>
<script type="math/tex; mode=display">
\begin{aligned}
&（1）页号P=\frac{A}{L}\\
&（2）页内偏移量W=A\%L\\
&（3）比较页号P和页表长度M，P\geq M产生越界中断\\
&（4）页表中页号P对应的页表项地址A=F+P*M\\
&（5）物理地址E=b*L+W\\
\end{aligned}</script><p><em>页式管理中空间地址是一维的</em></p>
<p>问题</p>
<ul>
<li>每次访存均需地址变换，地址变换必须足够快，否则访存速度会降低</li>
<li>每个进程引入页表，用于存储映射机制，页表不能过大</li>
</ul>
<p>引入快表机制：在地址变换过程中加入具有并行查找能力的高速缓冲存储器 —— <strong>快表</strong>（相联存储器 TLB，主存中的页表为<strong>慢表</strong>）</p>
<p><img src="../imgs/OS/add_TLB_page_allocation_transform.png" alt="add_TLB_page_allocation_transform"></p>
<p>一次地址变换流程</p>
<p>（1）CPU 给出逻辑地址，将页号送入高速缓冲寄存器，查询此页号是否存在于快表内</p>
<p>（2）若匹配到，直接取出对应页的页框号，与页内偏移拼接为物理地址，访存</p>
<p>（3）若未匹配到，访问慢表查询，读取页表项后复制到快表中，进行地址变换后访存</p>
<p><em>值得注意的是，题中是否说明快表初始为空以及快表慢表的查询机制，是否同时查询！</em></p>
<p>两级页表</p>
<ul>
<li>引入页表，执行时不需要调入所有内存页框，为了压缩页表，采取多级映射</li>
</ul>
<p><img src="../imgs/OS/2_dim_page.png" alt="2_dim_page"></p>
<ul>
<li>多级页表大小不能超过一个页面</li>
</ul>
<p><img src="../imgs/OS/2_dim_page_arch.png" alt="2_dim_page_arch"></p>
<script type="math/tex; mode=display">
\begin{aligned}
&逻辑地址：32bit\\
&以字节编址\\
&页表项：4B\\
&页面大小：4KB=2^{12}B （页内偏移量）\\
&页号：32-12=20\\
&全映射需要2^{20}个页表项\\
&共需4B*2^{20}=4MB大小空间存储页表\\
&\\
&以40MB进程为例\\
&页表项：\frac{40MB}{4B*4KB}=40KB\\
&需要\frac{40KB}{4KB}=10页面\\
&整个进程需要\frac{40MB}{4KB}=10*2^{10}个页面\\
&\\
&为了压缩页表，采取二级页表机制\\
&页表10页进行映射只需要10个页表项\\
&上一级页表只需要1页就已经足够2^{10}=1024个页表项\\
&进程执行时，仅需将这一页的上级页表调入即可\\
&页面大小：4KB=2^{12}B （页内偏移量）\\
&页号：32-12=20\\
&顶级（一级）页表为1个页面\\
&一级页表项\frac{4KB}{4B}=1K\\
&一级页表占用log_2{1K}=10位\\
&二级页表占用20-10=10位\\
&二级页表大小2^{10}*4B=4KB\leq页面大小4KB\\
\end{aligned}</script><p><strong>基本分段存储管理方式</strong></p>
<p>分页管理是从计算机角度考虑设计，提高内存利用率，分页通过硬件机制实现</p>
<p>分段管理是从用户和程序员出发，方便编程、信息保护和共享、动态增长以及动态链接等方面的需要</p>
<p><img src="../imgs/OS/single_seg.png" alt="single_seg"></p>
<p>段号决定每个进程最多可以分几个段，段内地址决定每个段内的最大长度</p>
<p>段表：每个进程都有一张逻辑空间与内存空间映射的段表</p>
<p><img src="../imgs/OS/seg.png" alt="seg"></p>
<p>地址变换机构</p>
<p><img src="../imgs/OS/segment_address_translation_mechanism.png" alt="分段地址变换机构"></p>
<script type="math/tex; mode=display">
从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W\\
比较段号S和段表长度M，S\geq M,产生越界中断，否则继续执行\\
段表中段号S对应段表项地址=段表始址F+段号S*段表项长度\\
段内偏移量\geq C，产生越界中断，否则继续执行\\
取出段表项中该段的起始地址b，E=b+W，得到物理地址E去访问内存\\</script><p>段的共享与保护：分段系统，通过两个作业的段表中相应表项指向被共享的段同一个物理副本，当地一个作业从共享段读取数据，必须防止另一个修改数据，不能修改的的代码称为<strong>纯代码、可重入代码</strong></p>
<p>段号和段内偏移需要显示给出，地址空间为二维</p>
<p><strong>段页式管理方式</strong></p>
<p>作业的地址空间被分为若干逻辑段，每段都有自己的段号，将每段分为若干大小的固定的页，内存空间分为若干和页面大小相同的存储块，对内存的分配以块为单位。</p>
<ul>
<li><p>段号位数决定每个进程最多可以分几个段</p>
</li>
<li><p>页号位数决定最多有几个页</p>
</li>
<li><p>页内偏移量决定页面大小、内存块的大小</p>
</li>
</ul>
<p>段页式系统的逻辑地址结构：</p>
<p><img src="../imgs/OS/OS_page_seg_add.png" alt="OS_page_seg_add"></p>
<p>地址变换</p>
<p>需要三次访存，可以使用快表机制</p>
<p><img src="../imgs/OS/segment_page_address_translation_mechanism.png" alt="segment_page_address_translation_mechanism"></p>
<p><strong>虚拟内存管理</strong></p>
<p>传统存储管理方式</p>
<ul>
<li>一次性：一次全部装入，才能开始</li>
<li>驻留性：装入后，常驻内存，任何部分都不会被换出，直至结束</li>
</ul>
<p>局部性原理</p>
<p>一个程序，一段时间内，只有一部分会被访问</p>
<ul>
<li>空间</li>
<li>时间</li>
</ul>
<p>虚拟存储器</p>
<p>将程序的一部分装入内存，其余部分留在外存，当所访问的部分不在内存，操作系统将需要的部分调入内存，将暂时不需要的内容换到外存</p>
<ul>
<li>多次性：无需一次全部装入，允许分为多次调入</li>
<li>对换性：无需常驻内存</li>
<li>虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于内存容量</li>
</ul>
<p>本质：用时间换空间</p>
<p>实现：请求分页、请求分段、请求段页式</p>
<p>支持：内存、外存、页表机制、段表机制、中断机构、地址变换机构</p>
<p><strong>请求分页管理方式</strong></p>
<p>访问不存在内存中的页面，通过调页将其调入，通过置换算法将暂时不需要的页面调到外存上</p>
<p>页表机制</p>
<p><img src="../imgs/OS/Request_paging_page_table_mechanism.png" alt="Request_paging_page_table_mechanism"></p>
<script type="math/tex; mode=display">
状态位P：指示是否调入内存\\
访问字段A：记录一段时间内被访问的次数\\
修改位M：标识页面调入内存后是否被修改过\\
外存地址：指出该页在外存上的地址，通常是物理块号\\</script><p>缺页中断机制</p>
<p>访问页面不在内存中时，产生一个缺页中断，请求操作系统将缺页调入内存，将缺页的进程阻塞，若内存有闲置的空闲块，则分配一个块，将页面装入，并修改页表相应的页表项，若内存中无空闲块，则淘汰某页，淘汰页若在内存中修改过需要同步，写回外存</p>
<p>地址变换机构</p>
<p><img src="../imgs/OS/request_paging_address_translation_mechanism.png" alt="request_paging_address_translation_mechanism"></p>
<p>页面置换算法</p>
<ul>
<li>最佳置换算法 OPT</li>
</ul>
<p>选择的被淘汰页是以后永不使用的页面，或是最长时间内不再被访问的页面</p>
<ul>
<li>先进先出算法 FIFO</li>
</ul>
<p>优先淘汰最早进入内存的页面，即内存中驻留时间最久的页面</p>
<p>会产生所分配的物理块增大页故障数不减反增的异常现象，<strong>Belady 异常</strong></p>
<ul>
<li>最近最久未使用算法 LRU</li>
</ul>
<p>选择最近最长时间未访问过的页面予以淘汰，为每个页面设置一个访问字段记录上次被访问所经历的时间</p>
<p>性能较好，需要寄存器和栈的硬件支持</p>
<ul>
<li>时钟置换算法 CLOCK</li>
</ul>
<p>简单的 CLOCK 算法：每帧关联一个附加位，使用位 <strong>u</strong>，连成一个循环队列。某页装入时，使用位置为 1；被访问时，使用位置为 1；置换时，操作系统扫描缓冲区，每当遇到一个使用位为 1 的帧，置为 0；最后停留在第一个使用位为 0 的帧</p>
<p>CLOCK 算法性能比较接近 LRU 算法</p>
<p>改进的 CLOCK 算法：再增加一个修改位 <strong>m</strong>，<strong>P(u,m)</strong></p>
<p>第一轮扫描，指针扫描过的页面使用位 <strong>u</strong> 置为 0</p>
<p>第一轮扫描中，未找到使用位 <strong>u</strong> 为 0 的页面进行第二轮扫描</p>
<p>第二轮扫描，第一个页面置换出，换入页面 <strong>m</strong> 修改位置为 1，并将指针后移</p>
<p><strong>页面分配策略</strong></p>
<p>一个进程分配的物理页框的集合，分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而提高处理机的效率；一个进程页数过少，基于局部性原理，页错误率会相对较高；页数过多，基于局部性原理，给特定的进程分配更多主存空间对该进程的错误率没有明显改善。</p>
<p>策略：固定分配局部置换、可变分配全局置换、可变分配局部置换（没有固定分配全局分配）</p>
<p>调入时机：预调页策略、请求调页策略</p>
<p>从何处调页：系统拥有足够的对换区间、系统缺少足够的对换区间、UNIX 方式</p>
<p><strong>抖动</strong></p>
<p>某进程频繁访问的页面数目高于可用的物理页帧数目</p>
<p><strong>工作集</strong></p>
<p>在某段时间间隔内，进程要访问的页面集合</p>
<p>一般，分配给进程的物理块数（驻留集大小）要大于工作集大小</p>
<h1 id="第四章-文件系统"><a href="#第四章-文件系统" class="headerlink" title="第四章 文件系统"></a>第四章 文件系统</h1><p><strong>文件</strong></p>
<p>文件结构：数据项、记录、文件</p>
<p>属性：名称、标识符、类型、位置、大小、保护、时间</p>
<p>所有文件的信息都保存在目录结构中，而目录结构保存在外存上，文件信息在需要时调入内存。</p>
<p>基本操作：创建、写、读、重定位、删除、截断</p>
<p>文件逻辑结构</p>
<ul>
<li>无结构文件（流式文件）</li>
</ul>
<p>二进制式字符流组成</p>
<ul>
<li>有结构文件（记录式文件）</li>
</ul>
<p>顺序文件</p>
<p>索引文件</p>
<p>索引顺序文件</p>
<p>直接文件或散列文件</p>
<p><strong>目录结构</strong></p>
]]></content>
  </entry>
  <entry>
    <title>操作系统・同步问题</title>
    <url>/2021/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>经典同步问题</strong></p>
<p><em>1. 生产者消费者问题</em></p>
<ul>
<li><p>一组生产者进程 (Producer)</p>
</li>
<li><p>一组消费者进程 (Consumer)</p>
</li>
<li><p>共享初始为空 大小为 n 的缓冲区 (Buffer)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">semaphore mutex = 1;  //mutex</span><br><span class="line">semaphore empty = n;  //buffer</span><br><span class="line">semaphore full = 0;   //full</span><br><span class="line"></span><br><span class="line">Producer(){</span><br><span class="line">	while(1){</span><br><span class="line">		Produce();</span><br><span class="line">		P(mutex);</span><br><span class="line">		add2Buffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Consumer(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(full);</span><br><span class="line">		P(mutex);</span><br><span class="line">		getFromBuffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		Consume();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>2. 读者写者问题</em></p>
<ul>
<li>读者进程 (Reader)</li>
<li> 写者进程 (Writer)</li>
<li> 共享一个文档 (Document)</li>
<li> 多进程读，不可多进程写</li>
<li>写进程写，不可读</li>
<li>写进程检查是否有读进程读</li>
</ul>
<p><strong>读进程优先</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">Reader(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Writer(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(rw);</span><br><span class="line">		write();</span><br><span class="line">		v(rw);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>写进程优先</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">semaphore w = 1;</span><br><span class="line">Writer(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(w);</span><br><span class="line">		P(rw);</span><br><span class="line">		Write();</span><br><span class="line">		V(rw);</span><br><span class="line">		V(w);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Reader(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(w);</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(w);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>3. 哲学家进餐问题</em></p>
<ul>
<li>5 名哲学家 (Philosopher)</li>
<li> 每两名之间有一根筷子 (Chopstick)</li>
<li> 每名有一碗饭</li>
<li>吃完饭思考 </li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">semaphore Chopsticks[5] = {1, 1, 1, 1, 1};</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">Philosopher(){</span><br><span class="line">	do{</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(Chopsticks[i]);</span><br><span class="line">		P(Chopsticks[(i+1)%5]);</span><br><span class="line">		V(mutex);</span><br><span class="line">		eat();</span><br><span class="line">		V(Chopsticks[i]);</span><br><span class="line">		V(Chopsticks[(i+1)%5]);</span><br><span class="line">		think();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4. 吸烟者问题</strong></p>
<ul>
<li>3 个吸烟者进程 (Smoker)</li>
<li>1 个提供者进程 (Offer)</li>
<li>Smoker1(paper, glue)</li>
<li>Smoker2(tobacco, glue)</li>
<li>Smoker3(paper, tobacco)</li>
<li>Offer(offer1) return paper, glue</li>
<li>Offer(offer2) return tobacco, glue</li>
<li>Offer(offer3) return paper, tobacco</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int num = 0;	//store random num</span><br><span class="line">semaphore offer1 = 0;</span><br><span class="line">semaphore offer2 = 0;</span><br><span class="line">semaphore offer3 = 0;</span><br><span class="line">semaphore end = 0;</span><br><span class="line">Offer(){</span><br><span class="line">	whlie(1){</span><br><span class="line">		num++;</span><br><span class="line">		num = num % 3;</span><br><span class="line">		if(num == 0)</span><br><span class="line">			V(offer1);</span><br><span class="line">		else if(num == 1)</span><br><span class="line">			V(offer2);</span><br><span class="line">		else</span><br><span class="line">			V(offer3);</span><br><span class="line">		P(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Smoker1(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(offer3);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Smoker2(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(offer2);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">Smoker3(){</span><br><span class="line">	while(1){</span><br><span class="line">		P(offer1);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>eg1</em></p>
<ul>
<li>3 个进程 P1 P2 P3</li>
<li> 互斥使用 N 个单元的缓冲区 (Buffer)</li>
<li>P1 produce() return (int num) put() @Buffer</li>
<li>P2 </li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据库・简述</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%C2%B7%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="数据库DB"><a href="#数据库DB" class="headerlink" title="数据库DB"></a>数据库 DB</h1><h2 id="一、数据库系统概论"><a href="#一、数据库系统概论" class="headerlink" title="一、数据库系统概论"></a>一、数据库系统概论</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>数据库的四个基本概念：数据、数据库、数据库管理系统、数据库系统  </p>
<ul>
<li>数据 DATA：描述事物的符号记录，数据的含义称为数据的语义，数据与其语义不可分  </li>
<li>数据库 DB：长期存储在计算机内、有组织的、可共享的大量数据的集合，数据库中的数据按一定数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性、易扩展性 </li>
<li>数据库管理系统 DBMS：位于操作系统和用户之间的一层数据管理软件，包括：数据定义、组织、存储、管理、操纵；数据库的事务管理、运行管理、建立、维护；其他；</li>
<li>数据库系统 DBS：由数据库、数据库管理系统、应用程序、数据库管理员 DBA 组成的存储、管理、处理和维护的系统<br>&lt;!—more—<h4 id="数据库技术发展"><a href="#数据库技术发展" class="headerlink" title="数据库技术发展"></a>数据库技术发展</h4>人工管理阶段、文件系统阶段、数据库系统阶段</li>
</ul>
<h4 id="数据库系统特点"><a href="#数据库系统特点" class="headerlink" title="数据库系统特点"></a>数据库系统特点</h4><ul>
<li>数据结构化：是与文件系统的本质区别</li>
<li>数据的共享性高、冗余度低且易扩充</li>
<li>数据独立性高</li>
<li>数据由数据库管理系统统一管理和控制：安全性保护、完整性保护、并发控制、数据库恢复</li>
</ul>
<h3 id="数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础"><a href="#数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础" class="headerlink" title="数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础"></a>数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础</h3><h4 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h4><ul>
<li>第一类概念模型（信息模型）：按用户的观点对数据和信息建模，主要用于数据库设计 —— <em>面向用户</em></li>
<li>第二类逻辑模型：包括层次模型、网状模型、关系模型、面向对象模型、对象关系模型、半结构化模型；是按计算机系统的观点对数据建模 —— <em>面向设计人员</em></li>
<li>第二类物理模型：是对数据最底层的抽象，面向计算机系统</li>
</ul>
<h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li>实体：客观存在并且可相互区别的事物</li>
<li>属性：实体具有的某一特性  </li>
<li>码：唯一标识实体的属性集  </li>
<li>实体型：用实体名及属性名集合来抽象和刻画同类实体  </li>
<li>实体集：同一类型实体的集合  </li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系，一对一、一对多、多对多等类型  <h5 id="一种表示方法：实体-联系方法"><a href="#一种表示方法：实体-联系方法" class="headerlink" title="一种表示方法：实体-联系方法"></a>一种表示方法：实体 - 联系方法</h5></li>
<li> E-R 模型</li>
</ul>
<h4 id="组成要素：数据模型通常由数据结构、数据操作、数据的完整性约束条件组成"><a href="#组成要素：数据模型通常由数据结构、数据操作、数据的完整性约束条件组成" class="headerlink" title="组成要素：数据模型通常由数据结构、数据操作、数据的完整性约束条件组成"></a>组成要素：数据模型通常由<strong>数据结构</strong>、<strong>数据操作</strong>、<strong>数据的完整性约束条件</strong>组成</h4><ul>
<li>数据结构：描述数据库的组成对象以及对象之间的关系 </li>
<li>数据操作：对数据库中的各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则（SQL）</li>
<li>数据的完整性约束条件：是一组完整性规则，保证数据的正确、有效和相容，任何关系需满足实体完整性和参照完整性（DBMS 自动完成，之外的由设计人员完成，用户自己的完整性也需设计人员完成）；在某个表中某一个属性不能重复且不能为空</li>
</ul>
<h4 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h4><ul>
<li>层次模型（非关系模型）</li>
<li>网状模型（非关系模型）</li>
<li>关系模型（表）</li>
<li>面向对象模型（对象）</li>
<li>对象关系模型</li>
<li>半结构化模型</li>
</ul>
<h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>早期的数据组织方式，IBM 的 IMS，在数据库中定义满足  </p>
<ul>
<li>有且只有一个结点没有双亲结点，这个结点叫根结点</li>
<li>根以外的其他结点有且只有一个双亲结点  </li>
</ul>
<p>层次模型更像是一颗倒立的树</p>
<h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><ul>
<li>允许一个以上的结点无双亲  </li>
<li>一个结点可以有多于一个的双亲  </li>
</ul>
<p>层次模型中子女结点与双亲结点的联系是唯一的，网状模型不唯一</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>IBM E.F.Codd</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>关系：一个关系对应一个表</li>
<li>元组：表中的一行</li>
<li>属性：表中的一列</li>
<li>码：表中某个属性组，可以唯一确定一个元组</li>
<li>域：一组有相同数据类型的集合</li>
<li>分量：元组的一个属性值</li>
<li>关系模式：关系的描述（关系名（属性 1，属性 2，…，属性 n））  </li>
</ul>
<p>要求关系必须规范化，每一个分量必须是一个不可分的数据项</p>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户 - 浏览器结构</li>
<li>浏览器 - 应用服务器、数据库服务器多层结构</li>
</ul>
<h4 id="系统模式的概念"><a href="#系统模式的概念" class="headerlink" title="系统模式的概念"></a>系统模式的概念</h4><p>在数据模型中有 “型” 和 “值” 的概念，型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值<br>模式是数据库中全体数据的逻辑结构和特征的描述，涉及型的描述，不涉及具体的值<br>模式是相对稳定的，而实例是相对变动的</p>
<h4 id="数据库系统的三级模式：外模式、模式、内模式"><a href="#数据库系统的三级模式：外模式、模式、内模式" class="headerlink" title="数据库系统的三级模式：外模式、模式、内模式"></a>数据库系统的三级模式：外模式、模式、内模式</h4><ul>
<li>模式：又称逻辑模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据试图，是与某一用户有关的数据的逻辑表示</li>
<li>外模式：通常是模式的子集，一个数据库可以有多个外模式，如果不同的用户在应用需求、看待的数据方式、对数据保密的要求等方面存在差异，则其外模式描述是不同的；同一模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式</li>
<li>内模式：又称存储模式或物理模式，一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</li>
</ul>
<h4 id="数据库二级映像功能与数据独立性"><a href="#数据库二级映像功能与数据独立性" class="headerlink" title="数据库二级映像功能与数据独立性"></a>数据库二级映像功能与数据独立性</h4><ul>
<li>外模式 / 模式映像：模式描述的是数据全局逻辑结构，外模式描述的是数据的局部逻辑结构，对于每一个外模式，数据库系统都有一个外模式 / 模式映像，定义了外模式与模式之间的对应关系，通常包含在各自的外模式描述中；当模式改变时，有数据库管理员对各个外模式 / 模式的映像做相应改变，可使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li>
<li>模式 / 内模式映像：数据库只有一个模式，也只有一个内模式，模式 / 内模式是唯一的，定义了数据全局逻辑结构与存储结构之间的对应关系；当数据库的存储结构发生改变，由数据库管理员对模式 / 内模式映像作相应改变，可使模式保持不变，从而应用程序不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性  </li>
</ul>
<h4 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h4><ul>
<li>硬件平台 &amp; 数据库</li>
<li>软件</li>
<li>人员</li>
</ul>
<h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><p>《Communications of the ACM》E.F.Codd</p>
<h3 id="关系数据结构及形式化定义-单一的数据结构，在用户看来逻辑结构是一张二维表"><a href="#关系数据结构及形式化定义-单一的数据结构，在用户看来逻辑结构是一张二维表" class="headerlink" title="关系数据结构及形式化定义:单一的数据结构，在用户看来逻辑结构是一张二维表"></a>关系数据结构及形式化定义：单一的数据结构，在用户看来逻辑结构是一张二维表</h3><ul>
<li><p>域：一组具有相同数据结构的值的集合  </p>
<script type="math/tex; mode=display">
\begin{aligned}
&D_1, D_2, \dots, D_n\\
\end{aligned}</script></li>
<li><p>笛卡尔积：域上的一种集合运算  </p>
<script type="math/tex; mode=display">
\begin{aligned}
&D_1 * D_2 * \dots * D_n = \{(d_1, d_2, \dots, d_n)|d_i\in D_i, i = 1, 2, \dots, n\}\\
&每一个元素(d_1, d_2, \dots, d_n)叫做一个n元组\\
&元组每一个值d_i叫做一个分量\\
&基数：一个域允许的不同取值个数M=\prod_{i=1}^{n}{m_i}
\end{aligned}</script></li>
<li><p>关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&D_1 * D_2 * \dots * D_n的子集叫做在域D_1, D_2, \dots\\
&D_n上的关系，表示为R(D_1, D_2, \dots, D_n)\\
&R表示为关系的名字，n是关系的目或度\\
&n=1，单元关系\\
&n=2，二元关系\\
&某一个属性组的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码\\
&若一个关系有多个候选码，则选定一个为主码\\
&候选码的诸属性成为主属性，不包含在任何候选码中的属性成为非主属性或非码属性\\
&在最简单情况下，候选码只包含一个属性；在最极端情况下，关系模式的所有属性是这个关系模式的候选码，称为全码\\
&关系有三种类型：\\
&基本关系（基本表或基表）：实际存在的表，实际存储数据的逻辑表示；\\
&查询表：查询结果对应的表；\\
&视图表：基本表或其他视图表导出的表，虚表，不对应实际存储的数据\\
&关系是一个无限的集合，由于笛卡尔积的域不满足交换律\\
&(d_1, d_2, \dots, d_n) \neq (d_2, d_1, \dots, d_n)(i, j =1, 2, \dots, n)\\
&对关系数据模型的限定和扩充：\\
&(1)无限关系在数据库系统中是无意义的，限定关系数据模型中的关系必须是有限集合\\
&(2)通过关系的每个列附加一个属性名的方法取消属性的有序性\\
&基本关系的性质：\\
&(1)列是同质的\\
&(2)不同列可出自同一个域\\
&(3)列顺序可无序\\
&(4)任意两个元组的候选码不能取同值\\
&(5)行的顺序可无序\\
&(6)分量必须取原子值\\
&这些规范中最基本的是每一个分量必须是一个不可分的数据项\\
\end{aligned}</script><h3 id="关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系"><a href="#关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系" class="headerlink" title="关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系"></a>关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系</h3><script type="math/tex; mode=display">
\begin{aligned}
&关系模式：R(U, D, DOM, F)\\
&R：关系名\\
&D：U中属性所来自的域\\
&DOM：属性向域的映射集合\\
&F：属性间数据的依赖关系\\
\end{aligned}</script><p>关系模式是静态的、稳定的，而关系是的动态的、随时间变化的；</p>
</li>
</ul>
<h3 id="关系数据库-有型和值的区分"><a href="#关系数据库-有型和值的区分" class="headerlink" title="关系数据库:有型和值的区分"></a>关系数据库：有型和值的区分</h3><ul>
<li>型：关系数据库模式，是对关系数据库的描述</li>
<li>值：关系模式在某一时刻对应的关系的集合</li>
</ul>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><h4 id="基本操作：查询、插入、删除、修改"><a href="#基本操作：查询、插入、删除、修改" class="headerlink" title="基本操作：查询、插入、删除、修改"></a>基本操作：查询、插入、删除、修改</h4><p>查询：选择、投影、连接、除、并、差、笛卡尔积；{选择、投影、并、差、笛卡尔积} 是 5 种基本操作<br>关系操作的特点：集合操作方式，一次一集合操作；非关系模型的数据操作为一次一记录方式</p>
<h3 id="关系数据语言：关系代数、关系演算"><a href="#关系数据语言：关系代数、关系演算" class="headerlink" title="关系数据语言：关系代数、关系演算"></a>关系数据语言：关系代数、关系演算</h3><ul>
<li>关系代数：用对关系的运算来表达查询要求</li>
<li>关系演算：用谓词来表达查询要求，按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算  </li>
</ul>
<p>SQL (Structured Query Language) 是集查询、数据定义语言、数据操纵语言和数据控制语言 DCL (Data Control Language) 于一体的关系数据语言</p>
<ul>
<li>关系代数语言：ISBL</li>
<li> 关系演算语言：元组关系演算语言：ALPHA、QUEL；域关系演算语言：QBE</li>
<li> 关系代数 &amp; 关系演算 - 语言:<strong>SQL</strong></li>
</ul>
<h2 id="关系的完整性：是对关系的某种约束条件，有三类约束："><a href="#关系的完整性：是对关系的某种约束条件，有三类约束：" class="headerlink" title="关系的完整性：是对关系的某种约束条件，有三类约束："></a>关系的完整性：是对关系的某种约束条件，有三类约束：</h2><h3 id="实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证"><a href="#实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证" class="headerlink" title="实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证"></a>实体完整性：若属性 A 是基本关系 R 的主属性，则 A 不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证</h3><p>实体完整性规则说明：<br>（1）实体完整性是针对基本关系而言，一个基本表对应现实世界的一个实体集<br>（2）现实世界中的实体是可区分的，即它们具有某种唯一标识<br>（3）关系模型中以主码作为唯一性标识<br>（4）主码中的属性即主属性不能取空值</p>
<h3 id="参照完整性：定义外码与主码之间的引用规则"><a href="#参照完整性：定义外码与主码之间的引用规则" class="headerlink" title="参照完整性：定义外码与主码之间的引用规则"></a>参照完整性：定义外码与主码之间的引用规则</h3><script type="math/tex; mode=display">
\begin{aligned}
&设F是基本关系R的一个或一组属性，但不是关系R的码，K_s是基本关系S的主码\\
&如果F与K_s相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系\\
&关系R和S不一定是不同的关系\\
&目标关系S的主码与K_s和参照关系R的外码F必须定义在同一个（同一组）\\
\end{aligned}</script><p>参照完整性规则</p>
<script type="math/tex; mode=display">
\begin{aligned}
&若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码K_s相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须\\
&取空值 \space 等于S中某个元组的主码值  \space空值  \space非空值\\
\end{aligned}</script><h3 id="用户定义的完整：与现实语义相结合"><a href="#用户定义的完整：与现实语义相结合" class="headerlink" title="用户定义的完整：与现实语义相结合"></a>用户定义的完整：与现实语义相结合</h3><h3 id="关系代数：抽象的查询语言，使用对关系的运算来表达查询-运算对象、运算符、运算结果-；按运算符分为传统的集合运算和专门的关系运算"><a href="#关系代数：抽象的查询语言，使用对关系的运算来表达查询-运算对象、运算符、运算结果-；按运算符分为传统的集合运算和专门的关系运算" class="headerlink" title="关系代数：抽象的查询语言，使用对关系的运算来表达查询[运算对象、运算符、运算结果]；按运算符分为传统的集合运算和专门的关系运算"></a>关系代数：抽象的查询语言，使用对关系的运算来表达查询 [运算对象、运算符、运算结果]；按运算符分为传统的集合运算和专门的关系运算</h3><h4 id="传统的集合运算（二目运算）：并、差、交、笛卡尔积"><a href="#传统的集合运算（二目运算）：并、差、交、笛卡尔积" class="headerlink" title="传统的集合运算（二目运算）：并、差、交、笛卡尔积"></a>传统的集合运算（二目运算）：并、差、交、笛卡尔积</h4><script type="math/tex; mode=display">
\begin{aligned}
&设关系R和S具有相同的目n（即两个关系都有的n个属性）\\
&具有相应的属性取自同一个域，t是元组变量，t\in R表示t是R的一个元组\\
&（1）并\\
&R \cup S = \{ t | t\in R \vee t\in S\}\\
&（2）差\\
&R - S = \{ t | t\in R \wedge t\notin S\}\\
&（3）交\\
&R \cap S = \{ t | t\in R \wedge t\in S\}\\
&（4）广义笛卡尔积\\
&R \times S = \{ \widehat{t_r t_s}  | t_r\in R \wedge t_S\in S\}\\
\end{aligned}</script><p>$\large{R}$:<br>|A|B|C|<br>|—|—|—|<br>|$a_1$|$b_1$|$c_1$|<br>|$a_1$|$b_2$|$c_2$|<br>|$a_2$|$b_2$|$c_1$|<br>$\large{S}$:<br>|A|B|C|<br>|—|—|—|<br>|$a_1$|$b_2$|$c_2$|<br>|$a_1$|$b_3$|$c_2$|<br>|$a_2$|$b_2$|$c_1$|<br>$\large{R\cup S}$:<br>|A|B|C|<br>|—|—|—|<br>|$a_1$|$b_1$|$c_1$|<br>|$a_1$|$b_2$|$c_2$|<br>|$a_2$|$b_2$|$c_1$|<br>|$a_1$|$b_3$|$c_2$|<br>$\large{R\cap S}$:<br>|A|B|C|<br>|—|—|—|<br>|$a_1$|$b_2$|$c_2$|<br>|$a_2$|$b_2$|$c_1$|<br>$\large{R\times S}$:<br>|R.A|R.B|R.C|S.A|S.B|S.C|<br>|—|—|—|—|—|—|<br>|$a_1$|$b_1$|$c_1$|$a_1$|$b_2$|$c_2$|<br>|$a_1$|$b_1$|$c_1$|$a_1$|$b_3$|$c_2$|<br>|$a_1$|$b_1$|$c_1$|$a_2$|$b_2$|$c_1$|<br>|$a_1$|$b_2$|$c_2$|$a_1$|$b_2$|$c_2$|<br>|$a_1$|$b_2$|$c_2$|$a_1$|$b_3$|$c_2$|<br>|$a_1$|$b_2$|$c_2$|$a_2$|$b_2$|$c_1$|<br>|$a_2$|$b_2$|$c_1$|$a_1$|$b_2$|$c_2$|<br>|$a_2$|$b_2$|$c_1$|$a_1$|$b_3$|$c_2$|<br>|$a_2$|$b_2$|$c_1$|$a_2$|$b_2$|$c_1$|</p>
<h4 id="专门的关系运算：选择、投影、连接、除运算"><a href="#专门的关系运算：选择、投影、连接、除运算" class="headerlink" title="专门的关系运算：选择、投影、连接、除运算"></a>专门的关系运算：选择、投影、连接、除运算</h4><p>（1）设关系模式为 R ($A<em>1$,$A_2$,$\dots$,$A_n$)，它的一个关系为 R<br>    $t\in R$ 表示 t 是 R 的一个元组<br>    t$[A_i]$ 表示元组中相应的属性 $A_i$ 的一个分量<br>（2）若 $A={A</em> {i1}, A<em>{i2}, \dots, A</em>{ik}}$ ，其中 $A<em>{i1}, A</em>{i2}, \dots, A<em>{ik}$ 是 $A_1, A_2, \dots, A_n$ 中的一部分，则 $A$ 称为属性列或属性组<br>    $t[A]=(t[A</em> {i1}], t[A<em>{i2}], \dots, t[A</em>{ik}])$ 表示元组 $t$ 在属性列 $A$ 上诸多分量的集合<br>    $\overline {A}$ 则表示 $A={A<em>{1}, A</em>{2}, \dots, A<em>{n}}$ 中去掉 $A={A</em>{i1}, A<em>{i2}, \dots, A</em>{ik}}$ 后剩余的属性组<br>（3）$R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系，$t_r\in R, t_s \in S$，$\widehat {t_r t_s}$ 为元组的连接（串接）<br>    是一个 $n+m$ 的元组<br>（4）给定一个关系 $R (X,Z)$，$X$ 和 $Z$ 为属性组<br>    $t [X]=x$，$x$ 在 $R$ 中的象集：$Z_x={t [Z]|t\in R, t [X]=x}$<br>    表示 R 中属性组 X 上的值为 x 的诸多元组在 Z 上的分量集合<br>$\large{R}$<br>|$x$|$Z$|<br>|—|—|<br>|$x_1$|$Z_1$|<br>|$x_1$|$Z_2$|<br>|$x_1$|$Z_3$|<br>|$x_2$|$Z_2$|<br>|$x_2$|$Z_3$|<br>|$x_3$|$Z_1$|<br>|$x_3$|$Z_3$|</p>
<p>$x<em>1$ 在 $R$ 中的象集 $Z</em>{x<em>1}={Z_1, Z_2, Z_3}$<br>$x_2$ 在 $R$ 中的象集 $Z</em>{x<em>2}={Z_2, Z_3}$<br>$x_3$ 在 $R$ 中的象集 $Z</em>{x_3}={Z_1, Z_3}$</p>
<p>（1）选择（限制）：在关系 $R$ 中选择满足条件的诸多元组<br>$\sigma_{F}(R)={t|t\in R \cap F (t)=’True’}$  $F (t)=X_1 \theta Y_1$  $\theta$: 比较远算符<br>（2）投影：关系 $R$ 选择出若干属性列组成新的关系<br>$\prod_A (R)={t [A|t \in R}$  $A$ 是 $R$ 的属性列<br>投影之后不仅取消原关系中的某些列，而且还可能取消某些组</p>
<p>查询关系 Student 在所在属性上的投影 $\large {\prod_{Sdept}(Stud)}$</p>
<p>$\LARGE{b = \prod_{Sdept}(a)}$</p>
<p>$\LARGE{a}$<br>|Sname|Sdept|<br>|—|—|<br>|Nick|CS|<br>|Cay|CS|<br>|John|MA|<br>|West|IS|</p>
<p>$\LARGE{b}$<br>|Sdept|—|<br>|—|—|<br>|CS|—|<br>|MA|—|<br>|IS|—|</p>
<p>（3）连接（$\theta$ 连接）：从两个关系的笛卡尔积中选取属性间满足一定条件的元组<br>$R\mathop{\bowtie}\limits_{A \theta B} S ={\widehat{t_r t_s}|t_r \in R \cap t_s \in S \cap t_r[A] \theta t_s[B]}$</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构・基本概念</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p> Data Structure Notes</p>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Author : <span class="string">"ebxeax"</span></span><br><span class="line">Version : <span class="number">1.0</span></span><br><span class="line">Refresh Date <span class="number">2020.11</span><span class="number">.26</span></span><br><span class="line">Description : </span><br><span class="line">Just record <span class="keyword">and</span> review some points about Data Structure.</span><br><span class="line">Have mistakes that please correct it yourself.</span><br></pre></td></tr></tbody></table></figure>
<p> 数据结构的基本概念</p>
<p>  1. 数据</p>
<p>  2. 数据元素：</p>
<p>   数据的基本单位，一个数据元素可有若干个数据项构成，数据项是不可分割的最小单位</p>
<p>  3. 数据类型</p>
<p>  4. 抽象数据类型 (ADT [Abstract Data Type]):</p>
<p>  数学模型在计算机的一种实现，包括数据对象、数据关系、基本操作，如建立一个有限状态机模型</p>
<p>  5. 数据结构：数据元素之间的关系称之为结构，数据结构包括三方面：逻辑结构、存储结构、数据运算 (程序 = 算法 + 数据结构)</p>
<p>  6. 逻辑结构：数据间的逻辑关系，与数据存储独立，分为线性结构和非线性结构</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">逻辑结构--线性结构</span><br><span class="line">逻辑结构--非线性结构</span><br><span class="line">线性结构--一般线性表</span><br><span class="line">线性结构--受限线性表</span><br><span class="line">线性结构--线性表推广</span><br><span class="line">受限线性表--栈和队列</span><br><span class="line">受限线性表--串</span><br><span class="line">线性表推广--数组</span><br><span class="line">线性表推广--广义表</span><br><span class="line">非线性结构--非线性表</span><br><span class="line">非线性表--集合</span><br><span class="line">非线性表--树形结构</span><br><span class="line">非线性表--图形结构</span><br><span class="line">树形结构--一般树</span><br><span class="line">树形结构--二叉树</span><br><span class="line">图形结构--有向图</span><br><span class="line">图形结构--无向图</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>  7. 物理结构：数据元素的表示以及关系的表示，主要有：顺序存储、链式存储、索引存储、散列存储</p>
<p>  8. 算法评估</p>
<p>  （1）特性：有穷、确定、可行、输入、输出</p>
<p>  （2）时间复杂度：衡量算法随问题规模的增大，算法执行的时间增长的快慢</p>
<p>   T (n)=O (f (n))，f (n) 为算法运算频度，一般采用最坏情况下的时间复杂度</p>
<p>   计算方法：取算法时间增长最快的函数项，忽略其系数</p>
<p>   a 加法规则：</p>
<pre><code>$$
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
$$

多项式相加，只保留最高阶的项，且系数变为1
</code></pre><p>   b 乘法规则：</p>
<pre><code>$$
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
$$

多项式相乘，都保留
</code></pre><p>   从左到右性能依次降低：</p>
<pre><code>$$
O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)
$$
</code></pre><p>   单循环体型：</p>
<pre><code>例题1：计算下列程序的时间复杂度

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i,sum	<span class="comment">//执行1次</span></span><br><span class="line">sum=<span class="number">0</span>	<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//int i=0执行1次，i&lt;=n执行n+2次，i++执行n+1次</span></span><br><span class="line">	sum+=i;	<span class="comment">//执行n+1次</span></span><br></pre></td></tr></tbody></table></figure>

时间分析： 该算法执行了3n+6个语句。 假设每个语句执行时间一致，均为常数t。则总时间 
$$
T=(3n+6)*t
$$
随着问题规模n的增大，总时间的增长率与n的增长率一致，所以复杂度为
$$
O(n)
$$


结论： 

 复杂度是关于增长率的，所以可以直接忽视常数项

  一般可以直接关注循环段基本操作语句

  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">sum+=i;</span><br></pre></td></tr></tbody></table></figure>



 的执行次数
</code></pre><p>   例题 2：</p>
   <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum,i;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= n;i=<span class="number">2</span>*i){</span><br><span class="line">	sum=sum+i;</span><br></pre></td></tr></tbody></table></figure>
<p>   时间分析：</p>
<p>   i 取值：1,2,4,8…<br>   满足条件：2^𝑘 ≤ n<br>   K𝑙𝑜𝑔_2𝑛时， 跳出循环<br>   所以循环体执行次数：⌈𝑙𝑜𝑔_2𝑛⌉ 故时间复杂度为 O (logn).i 取值：1,2,4,8</p>
<p>  多循环体型</p>
<p>  两个运算法则：乘法规则（嵌套循环）、加法规则（若干循环）</p>
<p>  例题 3：</p>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x,y,i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	x++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		y++;</span><br></pre></td></tr></tbody></table></figure>
<p>  两个循环体是独立的，采用加法规则： </p>
<script type="math/tex; mode=display">
  T(n)=T_1(n)+T_2(n)</script><script type="math/tex; mode=display">
  =max(T_1(n),T_2(n)) =O(n^2)</script><p>  例题 4：</p>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i,j,sum;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j=<span class="number">2</span>*j)</span><br><span class="line">		sum=sum+j;</span><br></pre></td></tr></tbody></table></figure>
<p>  两个循环体是嵌套的，采用乘法规则：</p>
<script type="math/tex; mode=display">
  T(n)=T_1(n)*T_2(n)</script><script type="math/tex; mode=display">
  =O(nlogn)</script><p>  （3）空间复杂度：衡量算法随问题规模的增大，算法所需空间的快慢</p>
<p>   S (n)=O (g (n))，算法所需空间的增长率和 g (n) 的增长率相同</p>
<p>   空间复杂度 S (n) 指算法运行过程中所使用的辅助空间的大小</p>
<p>线性表</p>
<p> 1. 定义：线性表是具有相同数据类型的 n 个数据类型的有限序列，n 为表长</p>
<p> 线性表中第一个元素称为表头元素，最后一个元素称为表位元素</p>
<p> 除第一个元素外，每个元素仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继</p>
<p>顺序存储</p>
<p>线性表的顺序存储又称顺序表</p>
<p>使用一组地址连续的存储单元 (数组等) 依次存储线性表的数据元素，从而使得逻辑相邻的两个元素在物理位置上也相邻</p>
<p>三个属性：</p>
<p> 1. 存储空间的起始位置</p>
<p> 2. 顺序表最大存储容量</p>
<p> 3. 顺序表当前的长度</p>
<p>宏定义</p>
<p>静态分配大小</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</span><br><span class="line">Elemtype elem[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">}SqList;</span><br></pre></td></tr></tbody></table></figure>
<p>动态分配大小 (这里动态指空间大小运行时决定，但分配大小后，空间大小被固定)</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</span><br><span class="line">Elemtype *elem;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">}SqList;</span><br></pre></td></tr></tbody></table></figure>
<p>优点：访问效率高、存储密度高</p>
<p>缺点：插入删除操作复杂</p>
<p>顺序存储线性表操作</p>
<p>1. 初始化顺序存储线性表</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initLinklist</span><span class="params">(SqList &amp;L)</span></span>{</span><br><span class="line">	L.elem=<span class="keyword">new</span> Elemtype[MaxSize];</span><br><span class="line"><span class="keyword">if</span>(!L.elem)</span><br><span class="line">   <span class="built_in">exit</span>(OVERFLOWS);</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>（1）创建一个顺序存储表后，需要初始化，首先根据数组大小通过 new 在堆空间开辟一段连续的空间赋值于先前创建的顺序存储表的 elem 空间</p>
<p>（2）检查 elem 是否存在，不存在溢出退出程序</p>
<p>（3）将 length 元素赋值为 0，即设置顺序存储线性表长度为 0</p>
<p>2. 销毁顺序存储线性表</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyList</span><span class="params">(SqList &amp;L)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(L.elem)</span><br><span class="line">   <span class="built_in">delete</span>(L.elem);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果线性表存在，删除线性表 elem 开辟的空间</p>
<p>3. 清空顺序存储线性表</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearList</span><span class="params">(SqList &amp;L)</span></span>{</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将线性表的长度置为 0</p>
<p>4. 判断顺序存储线性表是否为空</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqList &amp;L)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>判断线性表长度是否为 0，并返回相应 bool 值</p>
<p>5. 引用类型按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i,type&amp;e)</span></span>{</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> e=L.elem[i<span class="number">-1</span>];</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）通过访问 elem 内数据存入引用类型变量内</p>
<p>6. 按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> <span class="keyword">return</span> L.elem[i<span class="number">-1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）通过访问 elem 内数据并返回</p>
<p>7. 引用类型按值查询顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e,<span class="type">int</span> &amp;i)</span></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 按照 elem 开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量赋值于引用类型下标变量</p>
<p>8. 按值获取顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e)</span></span>{</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 按照 elem 开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量返回</p>
<p>9. 按下标插入元素</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listInsert</span><span class="params">(SqList &amp;L,type e,<span class="type">int</span> i)</span></span>{</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> ++L.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j=i<span class="number">-1</span>;j--)</span><br><span class="line">     L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line"> L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）增加线性表长度</p>
<p> （3）按照目标元素位置，将其尾部元素后移 1 偏移量</p>
<p> （4）将目标元素存入下标位置</p>
<p> <strong>时间复杂度分析:</strong></p>
<p>  （1）</p>
<script type="math/tex; mode=display">
  最好情况：在表尾插入(即i=n+1)</script><script type="math/tex; mode=display">
  元素后移语句执行的时间复杂度为O(1)</script><p>  （2）</p>
<script type="math/tex; mode=display">
  最坏情况：在表头插入(即i=1)</script><script type="math/tex; mode=display">
  元素后移语句执行n次，时间复杂度为O(n)</script><p>  （3）</p>
<script type="math/tex; mode=display">
  平均情况：假设p_i(p_i=1/(n+1))</script><script type="math/tex; mode=display">
  是第i个位置上插入一个结点的概率</script><script type="math/tex; mode=display">
  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为</script><script type="math/tex; mode=display">
  \begin{equation*}

  f = \sum_{i=1}^{n+1}p_i(n-i-1)

  \end{equation*}</script><script type="math/tex; mode=display">
  \begin{equation*}

  =\sum_{i=1}^{n+1}{\frac{n+1}{n-i+1}}

  \end{equation*}</script><script type="math/tex; mode=display">
  \begin{equation*}

  =\frac{1}{n+1} \sum_{i=1}^{n+1}(n-i-1)

  \end{equation*}</script><script type="math/tex; mode=display">
  =\frac{1}{n+1}\frac{n(n+2)}{2}=\frac{n}{2}</script><script type="math/tex; mode=display">
  因此顺序存储线性表的插入算法平均时间复杂度为O(n)</script><p>10. 按下标删除元素</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i  L.length))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; i &lt;= L.length - <span class="number">1</span>; j++) {</span><br><span class="line">		L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">		--L.length;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）按照目标元素位置，将其头部元素前移 1 偏移量</p>
<p> （3）减少线性表长度</p>
<p> <strong>时间复杂度分析:</strong></p>
<p>  （1）</p>
<script type="math/tex; mode=display">
  最好情况：在表尾插入(即i=n)</script><script type="math/tex; mode=display">
  无需移动元素，时间复杂度为O(1)</script><p>  （2）</p>
<script type="math/tex; mode=display">
  最坏情况：在表头插入(即i=1)</script><script type="math/tex; mode=display">
  需移动除第一个元素外的所有元素，时间复杂度为O(n)</script><p>  （3）</p>
<script type="math/tex; mode=display">
  平均情况：假设p_i(p_i=1/(n+1))</script><script type="math/tex; mode=display">
  是第i个位置上插入一个结点的概率</script><script type="math/tex; mode=display">
  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为</script><script type="math/tex; mode=display">
  \begin{equation*}

  f = \sum_{i=1}^{n}p_i(n-i)

  \end{equation*}</script><script type="math/tex; mode=display">
  \begin{equation*}

  =\sum_{i=1}^{n}{\frac{n}{n-i}}

  \end{equation*}</script><script type="math/tex; mode=display">
  \begin{equation*}

  =\frac{1}{n} \sum_{i=1}^{n}(n-i)

  \end{equation*}</script><script type="math/tex; mode=display">
  =\frac{1}{n}\frac{n(n-1)}{2}=\frac{n-1}{2}</script><script type="math/tex; mode=display">
  因此顺序存储线性表的插入算法平均时间复杂度为O(n)</script><p>11. 创建顺序存储线性表</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">	type e;</span><br><span class="line">	L.length = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Please in put an element:"</span>;</span><br><span class="line">		cin  e;</span><br><span class="line">		L.elem[i] = e;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>11. 打印顺序存储线性表内元素</p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList L)</span> </span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nList's element：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"elem["</span> &lt;&lt; i &lt;&lt; <span class="string">"] ="</span> &lt;&lt; L.elem[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
  </entry>
  <entry>
    <title>数据结构・查找算法</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1. 顺序查找</h2><h3 id="一般表"><a href="#一般表" class="headerlink" title="一般表"></a>一般表</h3><p>（1）代码<br></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> tableLen;</span><br><span class="line">}SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchSeq</span><span class="params">(SSTable ST, ElemType key)</span></span>{</span><br><span class="line">    ST.elem[e] = key;   <span class="comment">//设置哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;ST.tableLen; i++)</span><br><span class="line">        <span class="keyword">return</span> i;   <span class="comment">//存在返回, 不存在返回1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>（2）设置哨兵：可以不必判断是否越界，注意数据下表从1开始<br>（3）ASL<p></p>
<script type="math/tex; mode=display">
如果不能知道查找概率，可先对记录的查找概率进行排序，是表中的记录按查找概率从小到大\\
ASL_{success} = \sum_{i=1}^{n} P_i(n-i+1) = \frac{n+1}{2}\\
ASL_{unsuccess} = n+1\\</script><p>（4）优缺点<br>优点：对数据的存储无要求，顺序存储或者链式存储皆可<br>缺点：当 n 较大，平均查找长度较大，效率低</p>
<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1((10))--id2((20))</span><br><span class="line">id1((10)).--infinity,10</span><br><span class="line">id2((20))--id3((30))</span><br><span class="line">id2((20)).--infinity,20</span><br><span class="line">id3((30))--id4((40))</span><br><span class="line">id3((30)).--infinity,30</span><br><span class="line">id4((40))--id5((50))</span><br><span class="line">id4((40)).--infinity,40</span><br><span class="line">id5((50))--id6((60))</span><br><span class="line">id5((50)).--infinity,50</span><br><span class="line">id6((60))--60,=</span><br><span class="line">id6((60)).--infinity,60</span><br></pre></td></tr></tbody></table></figure>
<p>（1）一旦查到某个元素大于该元素便停止查找<br>（2）方框是虚构的节点，查找长度 = 方框上的圆环<br>（3)ASL</p>
<script type="math/tex; mode=display">
ASL_{success} = \sum_{i=1}^{n} P_i(n-i+1) = \frac{n+1}{2}\\
ASL_{unsuccess} = \sum_{j=1}^{n} Q_j(l_j-1) =  \frac{1+2+...+n+n}{n+1} = \frac{n}{2} +  \frac{n}{n+1}\\</script><h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id29((29))--id37((37))--id41((41))--id43((43))</span><br><span class="line">id43((43))--43,+infinity</span><br><span class="line">id43((43))--37,43</span><br><span class="line">id37((37))--id32((32))--id33((33))</span><br><span class="line">id32((32))--29,32</span><br><span class="line">id33((33))--33,37</span><br><span class="line">id33((33))--32,33</span><br><span class="line">id13((13))--id16((16))--id19((19))--19,29</span><br><span class="line">id19((19))--16,19</span><br><span class="line">id29((29))--id13((13))--id7((7))--id10((10))--10,13</span><br><span class="line">id10((10))--7,10</span><br><span class="line">id7((7))---infinity,7</span><br></pre></td></tr></tbody></table></figure>
<p>（1）仅适用于顺序表<br>（2）代码<br></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(SeqList L, ElemType key)</span></span>{</span><br><span class="line">    <span class="type">int</span> low, high, mid = <span class="number">0</span>, L.tableLen, <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high){</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]  key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>（3）ASL<p></p>
<script type="math/tex; mode=display">
ASL = \frac{1}{n}\sum_{i=1}^{n} l_i = \frac{1}{n}(1*1+2*2+...+h*2^{h-1}) = \frac{n+1}{n} log_2(n+1)-1 = log_2(n+1)-1\\
h=[log_2(n+1)]（向上取整）</script><h4 id="查找11"><a href="#查找11" class="headerlink" title="查找11"></a>查找 11</h4><h5 id="low-7-high-43-mid-29"><a href="#low-7-high-43-mid-29" class="headerlink" title="low=7, high=43, mid=29"></a>low=7, high=43, mid=29</h5><h5 id="11-lt-29"><a href="#11-lt-29" class="headerlink" title="11<29"></a>11&lt;29</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29--mid</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43--high</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h5 id="low-7-high-mid-1-19-mid-13"><a href="#low-7-high-mid-1-19-mid-13" class="headerlink" title="low=7, high=mid-1=19, mid=13"></a>low=7, high=mid-1=19, mid=13</h5><h5 id="11-lt-13"><a href="#11-lt-13" class="headerlink" title="11<13"></a>11&lt;13</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13--mid</span><br><span class="line">16</span><br><span class="line">19--high</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h5 id="low-7-high-mid-1-7-mid-10"><a href="#low-7-high-mid-1-7-mid-10" class="headerlink" title="low=7, high=mid-1=7, mid=10"></a>low=7, high=mid-1=7, mid=10</h5><h5 id="117"><a href="#117" class="headerlink" title="117"></a>117</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low--mid</span><br><span class="line">10--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h5 id="low-mid-1-10-high-10-mid-10"><a href="#low-mid-1-10-high-10-mid-10" class="headerlink" title="low=mid+1=10, high=10, mid=10"></a>low=mid+1=10, high=10, mid=10</h5><h5 id="1010-×"><a href="#1010-×" class="headerlink" title="1010 ×"></a>1010 ×</h5><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph </span><br><span class="line">7</span><br><span class="line">10--low--mid--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h5 id="没找到，停在low"><a href="#没找到，停在low" class="headerlink" title="没找到，停在low"></a>没找到，停在 low</h5><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>（1）将查找表分为若干子块，块内可以无序，但块之间有序的</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph </span><br><span class="line">id24((24))--id((索引块24,54,78,88))</span><br><span class="line">id21((21))</span><br><span class="line">id6((6))</span><br><span class="line">id11((11))</span><br><span class="line">id8((8))</span><br><span class="line">id22((22))</span><br><span class="line">id32((32))--id((索引块24,54,78,88))</span><br><span class="line">id31((31))</span><br><span class="line">id54((54))</span><br><span class="line">id72((72))--id((索引块24,54,78,88))</span><br><span class="line">id61((61))</span><br><span class="line">id78((78))</span><br><span class="line">id88((88))--id((索引块24,54,78,88))</span><br><span class="line">id83((83))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>（2）ASL</p>
<script type="math/tex; mode=display">
n:长度\\
b:分块个数\\
s:每块s个记录\\
P:等概率\\
ASL = L_I+L_S = \frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}\\
s=\sqrt{n},ASL=\sqrt{n}+1\\
采用折半查找：ASL=L_I+L_S=[log_2(b+1)]+\frac{s+1}{2}（向上取整）</script><h3 id="B树（多路平衡查找树）"><a href="#B树（多路平衡查找树）" class="headerlink" title="B树（多路平衡查找树）"></a>B 树（多路平衡查找树）</h3><script type="math/tex; mode=display">
m阶B树或空树\\
每棵子树至多m棵子树，最多包含m-1个关键字\\
若根节点不是终端节点，至少两棵子树\\
除根结点外所有非叶节点至少[\frac{m}{2}]（向上取整）棵子树（关键字）\\</script><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph </span><br><span class="line">id[22]--id0[5,11]</span><br><span class="line">id[22]--id1[36,45]</span><br><span class="line">id0[5,11]--id00[1,3]</span><br><span class="line">id0[5,11]--id01[6,8,9]</span><br><span class="line">id0[5,11]--id02[13,15]</span><br><span class="line">id1[36,45]--id10[30,35]</span><br><span class="line">id1[36,45]--id11[40,42]</span><br><span class="line">id1[36,45]--id12[47,48,50,56]</span><br></pre></td></tr></tbody></table></figure>]]></content>
  </entry>
  <entry>
    <title>数据结构・栈和队列</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li>栈 (Stack)：只允许在一端插入或删除的线性表</li>
<li>栈顶：线性表允许进行插入或删除的那一端</li>
<li>栈底：固定的，不允许进行插入和删除的另一端</li>
<li>特点：是受限的线性表，拥有线性关系；后进先出 <strong>LIFO</strong></li>
</ul>
<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><ul>
<li>使用顺序存储，自底向上存储数据元素，指针指向栈顶元素的位置</li>
<li>操作 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">s.top = <span class="number">-1</span>;             <span class="comment">//判空</span></span><br><span class="line">s.data[++s.top] = x;    <span class="comment">//进栈</span></span><br><span class="line">x = s.data[s.top--];    <span class="comment">//出栈</span></span><br><span class="line">x = s.data[s.top];      <span class="comment">//读取栈顶元素</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><ul>
<li>两个栈共享一个一维数组空间</li>
<li>两个栈分别设置在共享空间两端</li>
<li>栈顶指向中间延伸位置</li>
<li>有利于空间使用</li>
</ul>
<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><ul>
<li>采用链式存储</li>
<li>便于多个栈共享存储空间</li>
<li>效率高</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li>允许在一端插入，另一端删除的线性表</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>先进先出 <strong>FIFO</strong></li>
</ul>
<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><ul>
<li>连续的存储单元</li>
<li>头指针指向队头元素</li>
<li>尾指针指向队尾元素</li>
</ul>
<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><ul>
<li>首尾相连的顺序存储的队列</li>
<li>操作 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Q.rear = Q.front = <span class="number">0</span>;                           <span class="comment">// 初始化</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % MaxSize;                    <span class="comment">// 入队</span></span><br><span class="line">front = (front + <span class="number">1</span>) % MaxSize;                  <span class="comment">// 出队</span></span><br><span class="line">queueLen = (rear + MaxSize - front) % MaxSize;  <span class="comment">// 队列长度</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>判断空队列或满队列 </li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个单元区分队空或队满</span></span><br><span class="line">(Q.rear + <span class="number">1</span>) % MaxSize = Q.front;   <span class="comment">//</span></span><br><span class="line">Q.front = Q.rear;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 类型中增加表示个数的数据成员</span></span><br><span class="line">Q.size = <span class="number">0</span>;                         <span class="comment">//</span></span><br><span class="line">Q.size = MaxSize;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 增加tag成员</span></span><br><span class="line">tag = <span class="number">0</span>;                            <span class="comment">//</span></span><br><span class="line">tag = <span class="number">1</span>;                            <span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><ul>
<li>允许两端可以入队和出队</li>
<li>输出受限的双端队列：允许一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="栈在括号匹配的应用"><a href="#栈在括号匹配的应用" class="headerlink" title="栈在括号匹配的应用"></a>栈在括号匹配的应用</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>空栈，一次读入一个符号</li>
<li>右括号：使栈顶元素消解，或不合法（序列不匹配，退出程序）</li>
<li>左括号：放入栈顶，作为更高优先级的一个元素，栈为空，否则括号序列不匹配</li>
</ul>
<h3 id="栈在表达式中的应用"><a href="#栈在表达式中的应用" class="headerlink" title="栈在表达式中的应用"></a>栈在表达式中的应用</h3><ul>
<li>中缀表达式转换后缀表达式</li>
</ul>
<h3 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h3><ul>
<li>原理：将原始问题转换为相同属性的小规模问题</li>
<li>求出递归表达式</li>
<li>边界条件（递归出口）</li>
</ul>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><h3 id="队列在层次遍历的应用"><a href="#队列在层次遍历的应用" class="headerlink" title="队列在层次遍历的应用"></a>队列在层次遍历的应用</h3><h3 id="队列在计算机系统中的应用"><a href="#队列在计算机系统中的应用" class="headerlink" title="队列在计算机系统中的应用"></a>队列在计算机系统中的应用</h3><ul>
<li>解决主机与外设之间速度不匹配的问题</li>
<li>解决多用户引起的资源竞争问题</li>
</ul>
<h1 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h1><h2 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h2><ul>
<li>行优先：先存储行号较小的元素，行号相等先存储列号小的元素</li>
<li>列优先：先存储列好较小的元素，列号相等先存储行号小的元素</li>
</ul>
<h2 id="n阶对称矩阵"><a href="#n阶对称矩阵" class="headerlink" title="n阶对称矩阵"></a>n 阶对称矩阵</h2><ul>
<li>上三角、主对角线、下三角，其中上下三角元素相同</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素 $a_{ij}$ 在数组中下标为 $k$</li>
<li> 元素下标之间的对于关系<br>$i \ge j , k = \frac{i<em>(i-1)}{2+j}-1 (下三角区和主对角线元素)$<br>$i &lt; j , k = \frac{j</em>(j-1)}{2+i}-1 (上三角区元素)$</li>
</ul>
<h2 id="n阶三角矩阵"><a href="#n阶三角矩阵" class="headerlink" title="n阶三角矩阵"></a>n 阶三角矩阵</h2><ul>
<li>下三角矩阵（上三角区元素为常量）和上三角矩阵（下三角矩阵元素为常量）</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素 $a_{ij}$ 在数组中下标为 $k</li>
<li> 下三角矩阵的的元素下表之间的对应关系<br>-</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据结构・简述</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="一、数据结构：相互存在一种或多种特定关系的集合"><a href="#一、数据结构：相互存在一种或多种特定关系的集合" class="headerlink" title="一、数据结构：相互存在一种或多种特定关系的集合"></a>一、数据结构：相互存在一种或多种特定关系的集合</h2><ul>
<li>结构：任何问题，数据元素不孤立存在，之间存在关系  </li>
<li>逻辑结构</li>
<li>存储结构（物理结构）</li>
<li>数据的运算</li>
<li>逻辑结构和存储结构密不可分</li>
<li>算法设计取决于逻辑结构，实现依赖存储结构<h2 id="二、逻辑结构：数据元素之间的逻辑关系"><a href="#二、逻辑结构：数据元素之间的逻辑关系" class="headerlink" title="二、逻辑结构：数据元素之间的逻辑关系"></a>二、逻辑结构：数据元素之间的逻辑关系</h2></li>
<li>与存储无关，独立于计算机</li>
<li>分为线性结构和非线性结构<br>线性结构：线性表、栈、队列、串、数组、广义表<br>非线性结构：树、二叉树、有向图、无向图<h2 id="三、存储结构（物理结构）：数据结构在计算机中的映像"><a href="#三、存储结构（物理结构）：数据结构在计算机中的映像" class="headerlink" title="三、存储结构（物理结构）：数据结构在计算机中的映像"></a>三、存储结构（物理结构）：数据结构在计算机中的映像</h2></li>
<li>数据结构的表示</li>
<li>关系的表示</li>
<li>依赖于计算机语言</li>
<li>分为顺序存储、链式存储、索引存储、散列存储<h3 id="1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻"><a href="#1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻" class="headerlink" title="1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻"></a>1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻</h3></li>
<li>优：实现随机存取、每个元素占用的内存少</li>
<li>缺：只能使用相邻的一块存储单元，产生较多的外部碎片<h3 id="2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素"><a href="#2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素" class="headerlink" title="2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素"></a>2. 链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素</h3></li>
<li>优：无碎片产生、充分利用存储单元</li>
<li>缺：只能顺序存储<h3 id="3-索引存储：类似目录"><a href="#3-索引存储：类似目录" class="headerlink" title="3. 索引存储：类似目录"></a>3. 索引存储：类似目录</h3><h3 id="4-散列存储：通过关键字直接计算出元素的物理地址"><a href="#4-散列存储：通过关键字直接计算出元素的物理地址" class="headerlink" title="4. 散列存储：通过关键字直接计算出元素的物理地址"></a>4. 散列存储：通过关键字直接计算出元素的物理地址</h3><h2 id="四、数据运算"><a href="#四、数据运算" class="headerlink" title="四、数据运算"></a>四、数据运算</h2><h2 id="五、算法的五个特征"><a href="#五、算法的五个特征" class="headerlink" title="五、算法的五个特征"></a>五、算法的五个特征</h2></li>
<li>有穷性：执行有限步后结束</li>
<li>确定性：每条指令都有确定的含义，相同输入得到相同的输出</li>
<li>可行性：通过实现的基本运算执行有限次得到确定的结果</li>
<li>输入：有零或多个输入</li>
<li>输出：一个或多个程序输出结果<h2 id="六、算法的复杂度"><a href="#六、算法的复杂度" class="headerlink" title="六、算法的复杂度"></a>六、算法的复杂度</h2><h3 id="1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢"><a href="#1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢" class="headerlink" title="1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢"></a>1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢</h3><h3 id="2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢"><a href="#2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢" class="headerlink" title="2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢"></a>2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢</h3></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据结构・线性表</title>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、逻辑结构和基本操作"><a href="#一、逻辑结构和基本操作" class="headerlink" title="一、逻辑结构和基本操作"></a>一、逻辑结构和基本操作</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1. 逻辑结构"></a>1. 逻辑结构</h3><ul>
<li>具有相同数据类型的 n 个数据元素的有限序列，表长 n，n=0 为空表</li>
<li>表头：第一个元素</li>
<li>表尾：最后一个元素</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>
<li>除最后一个元素外，每个元素有且仅有一个直接后继<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">initList</span>(&amp;L);</span><br><span class="line"><span class="built_in">len</span>(L);</span><br><span class="line"><span class="built_in">locateElem</span>(L, i);</span><br><span class="line"><span class="built_in">getElem</span>(L, i);</span><br><span class="line"><span class="built_in">listInsert</span>(&amp;L, i, e);</span><br><span class="line"><span class="built_in">listDelete</span>(&amp;L, i, &amp;e);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"><span class="built_in">isEmptyList</span>(L);</span><br><span class="line"><span class="built_in">destroyList</span>(&amp;L);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="二、顺序存储结构"><a href="#二、顺序存储结构" class="headerlink" title="二、顺序存储结构"></a>二、顺序存储结构</h2><h3 id="1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻"><a href="#1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻" class="headerlink" title="1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻"></a>1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻</h3><ul>
<li>存储空间的起始位置 data [ ]</li>
<li> 顺序表最大存储容量 MaxSize</li>
<li> 顺序表当前最大长度 len<br>特点</li>
<li>随机访存，O (1) 时间复杂度访问</li>
<li>存储密度高，每个结点只存储数据元素</li>
<li>无需花费空间建立数据之间的逻辑关系，由物理位置相邻特性决定</li>
<li>逻辑上物理上均相邻，插入删除操作需要移动大量元素<h3 id="2-基本操作-1"><a href="#2-基本操作-1" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3>（1）插入元素 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.len = MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = L.len; j  i; j--)</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">	L.len++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
分析</li>
<li>最好情况：在表尾插入 <strong>(i=n+1)</strong>，不需要移动元素，时间复杂度为 O (1)  </li>
<li>最坏情况：在表头插入 <strong>(i=1)</strong>，元素后移 n 次，时间复杂度 O (n)  </li>
<li>平均情况：假设 $P_i$ <strong>($P_i = \frac{1}{n+1}$)</strong>，是在第 i 个位置上插入一个结点的概率，则在长度为 n 的线性表中插入一个结点所需移动的平均次数为 $\frac {n}{2}$，其时间复杂度为 O (n)<br>（2）删除元素 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	e = L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.len; j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">	L.len--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
分析</li>
<li>最好情况：在表尾插入 <strong>(i=n)</strong>，不需要移动元素，时间复杂度为 O (1)  </li>
<li>最坏情况：在表头插入 <strong>(i=1)</strong>，元素后移 n 次，时间复杂度 O (n)  </li>
<li>平均情况：假设 $P_i$ <strong>($P_i = \frac{1}{n+1}$)</strong>，是在第 i 个位置上插入一个结点的概率，则在长度为 n 的线性表中插入一个结点所需移动的平均次数为 $\frac {n-1}{2}$，其时间复杂度为 O (n)<br>（3）查找元素 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList &amp;L, Elemtype e)</span></span>{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.len; i++)</span><br><span class="line">		<span class="keyword">if</span>(e == L.data[i])</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
分析</li>
<li>最好情况：查找的元素在表头，仅需比较 1 次，时间复杂度 O (1)</li>
<li> 最坏情况：查找的元素在表尾或不存在，需要比较 n 次，时间复杂度 O (n)  </li>
<li>平均情况：假设 $P_i$ <strong>($P_i = \frac{1}{n}$)</strong> 是在第 i 个位置上结点的概率，则在长度为 n 的线性表中插入一个结点所需移动的平均次数为 $\frac {n+1}{2}$，其时间复杂度为 O (n)  <h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><h2 id="1-创建单链表"><a href="#1-创建单链表" class="headerlink" title="1.创建单链表"></a>1. 创建单链表</h2><h3 id="（1）头插法"><a href="#（1）头插法" class="headerlink" title="（1）头插法"></a>（1）头插法</h3></li>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表头 (头结点位置)</li>
<li> 链表结点的次序与输入的顺序相反<h3 id="（2）尾插法"><a href="#（2）尾插法" class="headerlink" title="（2）尾插法"></a>（2）尾插法</h3></li>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表尾 (尾结点位置)</li>
<li> 链表中的结点顺序与输入顺序一致<h2 id="2-按值查找结点"><a href="#2-按值查找结点" class="headerlink" title="2.按值查找结点"></a>2. 按值查找结点</h2></li>
<li>在链表中从第一个结点出发，顺指针 next 逐个向下搜索，直到找到第 i 个结点，否则返回最后一个结点的指针域 NULL<h2 id="3-按序号查找结点"><a href="#3-按序号查找结点" class="headerlink" title="3.按序号查找结点"></a>3. 按序号查找结点</h2></li>
<li>从链表第一个结点开始，由前往后按照序号递增定位到相应结点的位置，返回该值，需检查序号是否越界<h2 id="4-插入"><a href="#4-插入" class="headerlink" title="4.插入"></a>4. 插入</h2></li>
<li>插入操作是将值为 x 的新结点插入到单链表的第 i 个位置</li>
<li>先检查插入位置是否合法</li>
<li>找到待插入位置的前驱结点</li>
<li>在其后将结点插入 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">s-next = p-next;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5. 删除</h2></li>
<li>将单链表的第 i 个结点删除</li>
<li>先检查插入位置是否合法</li>
<li>找到待删除位置的前驱结点</li>
<li>删除其后结点 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">q = p-next;</span><br><span class="line">q-next = p-next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></tbody></table></figure>
<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1></li>
<li>双链表有两个指针 prior 和 next，分别指向前驱和后继结点</li>
<li>插入操作 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">s-next = p-next;</span><br><span class="line">p-next-prior = s;</span><br><span class="line">s-prior = p;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></tbody></table></figure></li>
<li>删除操作 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">p-next = q-next;</span><br><span class="line">q-next-prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></tbody></table></figure>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1></li>
<li>循环双链表和循环单链表</li>
<li>静态链表使用数组来描述线性表的链式存储结构</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>环境配置・Ubuntu1804 安装 CUDA 和 Pytorch</title>
    <url>/2021/04/06/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%C2%B7Ubuntu1804%E5%AE%89%E8%A3%85CUDA%E5%92%8CPytorch/</url>
    <content><![CDATA[<h2 id="Init-Ubuntu-and-change-deb-amp-pip-source"><a href="#Init-Ubuntu-and-change-deb-amp-pip-source" class="headerlink" title="Init Ubuntu and change deb&amp;pip source"></a>Init Ubuntu and change deb&amp;pip source</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">wget https://github.com/ebxeax/ebxeax.github.io/blob/main/toolbox/initUbuntu/initUbuntu.sh</span><br><span class="line">bash ./initUbuntu.sh</span><br></pre></td></tr></tbody></table></figure>
<h2 id="CUDA11-6"><a href="#CUDA11-6" class="headerlink" title="CUDA11.6"></a>CUDA11.6</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin</span><br><span class="line">sudo <span class="built_in">mv</span> cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda-repo-wsl-ubuntu-11-6-local_11.6.2-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-wsl-ubuntu-11-6-local_11.6.2-1_amd64.deb</span><br><span class="line">sudo apt-key add /var/cuda-repo-wsl-ubuntu-11-6-<span class="built_in">local</span>/7fa2af80.pub</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Load-library-path"><a href="#Load-library-path" class="headerlink" title="Load library path"></a>Load library path</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda/lib64:<span class="variable">$LD_LIBRARY_PAT</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Test-nvidia-smi"><a href="#Test-nvidia-smi" class="headerlink" title="Test nvidia-smi"></a>Test nvidia-smi</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Test-nvcc-V"><a href="#Test-nvcc-V" class="headerlink" title="Test nvcc -V"></a>Test nvcc -V</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></tbody></table></figure>
<h3 id="get-file-when-network-worse"><a href="#get-file-when-network-worse" class="headerlink" title="get file when network worse"></a>get file when network worse</h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">wget https://download.pytorch.org/whl/cu113/torch-1.10.2%2Bcu113-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">wget https://download.pytorch.org/whl/cu113/torchvision-0.11.3%2Bcu113-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">wget </span><br><span class="line">pip3 install ./torch-1.10.2+cu113-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">pip3 install ./torchvision-0.11.3+cu113-cp36-cp36m-linux_x86_64.whl</span><br></pre></td></tr></tbody></table></figure>]]></content>
  </entry>
  <entry>
    <title>计算机组成原理・Cache 和主存的映射替换算法和写策略</title>
    <url>/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E5%86%99%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="Cache和主存的映射·替换算法·写策略"><a href="#Cache和主存的映射·替换算法·写策略" class="headerlink" title="Cache和主存的映射·替换算法·写策略"></a>Cache 和主存的映射・替换算法・写策略</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>Cache 行中的信息是主存某个块的副本<br>地址映射：将主存地址空间映射到 Cache 地址空间，按某种规则将主存的信息装入 Cache<br>Cache 的行数比主存块少的多，只有一部分主存块的信息可以装入 Cache 中，因此在 Cache 中需要为每块加一个<strong>标记</strong>，指明它是主存的哪一块的副本，此标记相当于主存块的编号。为了说明 Cache 行中的信息是否有效还需要一个<strong>有效位</strong>，地址映射以下 3 种：</p>
<ul>
<li>直接映射</li>
<li>全相联映射</li>
<li>组相联映射</li>
</ul>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>Cache 行号 = 主存块号 mod Cache 总行数<br>假设 Cache : $2^c$ 行 主存 : $2^m$ 块<br>$0,2^c,2^{c+1},\dots$ 块映射到第 0 行<br>$1,2^c+1,2^{c+1}+1$ 块映射到第 1 行<br>低 c 位为装入的 Cache 行号，给每行设置一个长为 t=m-c 的标记，当某个主存块调入 Cache 后，将主存块号的高 t 位设置为对应 Cache 行中的标记<br>|t|c|b|<br>|-|-|-|<br>| 标记 | Cache 行号 | 块内地址 |  </p>
<p>CPU 访存过程：</p>
<ul>
<li>根据访存地址中间的 c 位找到对应 Cache 行</li>
<li> Cache 行标记与主存地址高 t 位标记比较，确定是否有效</li>
<li>相等且有效位为 1，访问 Cache 命中，根据主存地址低 b 位的块内地址，在对应 Cache 行中存取信息</li>
<li>不相等或有效位为 0，不命中，CPU 将主存读出该地址所在的一块信息送到相应的 Cache 行中，置有效位 1，并将标记设置为地址高 t 位，同时将地址中的内容送 CPU</li>
</ul>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p>主存的每一块可以装入 Cache 中的任何位置，每行<strong>标记</strong>用于指出该行取自主存的哪一块，CPU 访存时需要与所有 Cache 行的标记进行对比<br>|t|b|<br>|-|-|<br>| 标记 | 块内地址 |</p>
<h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p>将 Cache 分为 Q 个大小相等的组，每个主存块可以装入固定组的任意一行，即组间采用直接映射，而组内采用全相联映射，Q=1 变为全相联映射，Q=Cache 行数变为直接映射<br>假设 r 个 Cache 行，则称之为 r 路组相联映射<br>Cache 组号 = 主存块号 mod Cache 组数 (Q)<br>|t|g|b|<br>|-|-|-|<br>| 标记 | 组号 | 块内地址 |</p>
<p>CPU 访存：</p>
<ul>
<li>根据访存地址中间的 g 位组号找到对应的 Cache 组</li>
<li>将对应的 Cache 组的每个行标记与主存的高 t 位标记进行比较</li>
<li>相等且有效位为 1，命中，根据主存地址中的低 b 位块内地址，在对应的 Cache 行中存取信息</li>
<li>不相等或有效位为 0，未命中，CPU 从主存读出该地址所在的一块信息送到对应的 Cache 组的任意一个空行，有效位置 1，设置标记，同时将地址中的内容送 CPU</li>
</ul>
<h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p>在采用全相联映射或组相联映射方式时，主存向 Cache 传送一个新块，Cache 或 Cache 组空间已满替换的策略</p>
<ul>
<li>RAND</li>
<li>FIFO</li>
<li>LRU<h2 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h2>因为 Cache 中的内容是主存块副本，当对 Cache 中的内容进行更新时，就需选用写操作策略，使 Cache 内容和主存保持一致<br>对于 Cache 写命中：</li>
<li>全写法：当 CPU 对 Cache 写命中时，必须八数据同时写入 Cache 和内存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖。</li>
<li>回写法：当 CPU 对 Cache 写命中时，只把数据写入 Cache，而不立即写入主存，只有当此块被换出时，才写入主存。每个 Cache 行设置一个修改位（脏位），若修改位为 1，Cache 行被修改过，替换时需要写回主存，若为 0，则说明 Cache 行中的块未被命中，替换时无需写回</li>
</ul>
<p>对于 Cache 写不命中：</p>
<ul>
<li>写分配法：加载主存中的块到 Cache 中，然后更新这个 Cache 块</li>
<li>非写分配法：只写入主存，不进行调块</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理・中央处理器</title>
    <url>/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>控制器：负责协调并控制计算机各部件执行程序的指令序列：取指令、分析指令、执行指令<br>运算器：对数据加工</p>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>数据加工</li>
<li>时间控制</li>
<li>中断处理</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>运算器和控制器两大部分组成<br>运算器：</p>
<ul>
<li>算术逻辑单元（ALU）</li>
<li>暂存寄存器</li>
<li>累加寄存器（ACC）</li>
<li>通用寄存器组（AX/BX/CX/DX/SP）</li>
<li>程序状态字寄存器（PSW：OF/SF/ZF/CF）</li>
<li>移位器</li>
<li>计数器</li>
</ul>
<p>控制器（CU）：</p>
<ul>
<li>程序计数器（PC）</li>
<li>指令寄存器（IR）</li>
<li>指令译码器</li>
<li>存储器地址寄存器</li>
<li>存储器数据寄存器</li>
<li>时序系统</li>
<li>微操作信号发生器</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>CPU 从主存取出并执行一条指令的时间，指令周期通常使用若干机器周期表示，每个机器周期可等长或不等，一个机器周期包含若干时钟周期（节拍），每个机器周期内的时钟周期数可以不等</p>
<ul>
<li>无条件转移指令：执行阶段不需要访存，只包含取指阶段（取指和分析）和执行阶段</li>
<li>间接寻址指令：为了取操作数，需要先访 1 次，取出有效地址，然后访存，取出操作数，所有需要包含间址周期，介于取指和执行之间</li>
<li> CPU 采用中断方式实现主机和 I/O 设备的信息交换，CPU 在每条指令结束前，都要发送中断查询信号，若有中断请求，CPU 进入中断响应阶段（中断周期）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指周期</td>
<td>间址周期</td>
<td>执行周期</td>
<td>中断周期</td>
</tr>
</tbody>
</table>
</div>
<p>只有访存的目的不同，取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点<br>CPU 内设置了 4 个标志触发器 FE/IND/EX/INT</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>FE</th>
<th>IND</th>
<th>EX</th>
<th>INT</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fetch</td>
<td>Index</td>
<td>Execute</td>
<td>Interrupt</td>
</tr>
<tr>
<td> 取值</td>
<td>间址</td>
<td>执行</td>
<td>中断</td>
</tr>
</tbody>
</table>
</div>
<h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>根据 PC 中的内容从主存取出指令代码放入 IR  </p>
<ul>
<li>PC $\to$ IR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\to$ DataBus $\to$ MDR $\to$ Mem</li>
<li>Mem $\to$ DataBus $\to$ MDR $\to$ IR（存放指令）</li>
<li>CU $\stackrel{SignalControl::FE}{\longrightarrow}$ [(PC) + 1 $\to$ PC]</li>
</ul>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>取操作数有效地址，间址为例：指令中的地址码送到 MAR 并送至地址总线，CU 向存储器发送读命令，以获取有效地址并存在 MDR  </p>
<ul>
<li>Addr(IR) / MDR $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel {SignalI/O::READ}{\longrightarrow}$ ControlBus $\to$ Mem（存放有效地址）</li>
<li>Mem $\to$ DataBus $\to$ MDR</li>
</ul>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><p>取操作数，根据 IR 的指令字的操作码通过 ALU 操作产生执行结果</p>
<ul>
<li>无统一的数据流向</li>
</ul>
<h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>处理中断请求，假设程序断点存入堆栈，用 SP 指示栈顶地址，入栈操作是先修改栈顶指针，后存入数据</p>
<ul>
<li>CU $\stackrel{SignalStack::SP}{\longrightarrow}$ [(SP) - 1 $\to$ SP] $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI/O::WRITE}{\longrightarrow}$ ControlBus $\to$ Mem</li>
<li>PC $\to$ MDR $\to$ DataBus $\to$ Mem（程序断点存入主存）</li>
<li>CU $\to$ PC（中断服务程序的入口地址送至 PC）</li>
</ul>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul>
<li>单指令周期</li>
<li>多指令周期</li>
<li>流水线方案</li>
</ul>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>数据通路：数据在功能部件之间传输的路径<br>由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号<br>数据通路功能：实现 CPU 内部的运算器与寄存器以及寄存器之间的数据交换</p>
<h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>CPU 内部单总线模式<br>所有寄存器的输入输出端都连接在一条公共通路上，结构简单但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构，CPU 中有两条或更多的总线时，构成双总线结构或多总线结构</li>
<li> CPU 内部多总线模式<br>所有寄存器的输入输出端都连接在多条公共通路上，相比之下单总线在一个时钟内只允许传一个数据，因此指令执行效率很低，因此在多总线方式，同时在多总线上传输不同的数据，提高效率</li>
<li>专用数据通路方式<br>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大</li>
</ul>
<h4 id="寄存器之间的数据传输"><a href="#寄存器之间的数据传输" class="headerlink" title="寄存器之间的数据传输"></a>寄存器之间的数据传输</h4><p>通过内部总线完成<br>寄存器 AX 的输入输出由 AXout 和 AXin 控制  </p>
<ul>
<li>(PC) $\to$ MAR，PCout 和 MARin 有效</li>
</ul>
<h4 id="主存与CPU之间的数据传输"><a href="#主存与CPU之间的数据传输" class="headerlink" title="主存与CPU之间的数据传输"></a>主存与 CPU 之间的数据传输</h4><p>主存与 CPU 之间的数据传输需要借助 CPU 内部总线完成<br>主存内读取</p>
<ul>
<li>(PC) $\to$ MAR，PCout 和 MARin 有效  </li>
<li>1 $\to$ R，CU 发出读命令  </li>
<li>MEM (MAR) $\to$ MDR，MDRin 有效  </li>
<li>(MDR) $\to$ IR，MDRout 和 IRin 有效  </li>
</ul>
<h4 id="执行算术或逻辑算术"><a href="#执行算术或逻辑算术" class="headerlink" title="执行算术或逻辑算术"></a>执行算术或逻辑算术</h4><p>由于 ALU 没有内部存储功能，执行加法操作，相加的两个数必须在 ALU 的两个输入输出端同时有效</p>
<ul>
<li>(MDR) $\to$ MAR，MDRout 和 MARin 有效  </li>
<li>1 $\to$ R，CU 读命令</li>
<li> MEM (MAR) $\to$ 操作数从主存送至 MDR</li>
<li>(MDR) $\to$ Y，MDRout 和 Yin 有效</li>
<li> (ACC) + (Y) $\to$ Z ACCout 和 ALUin 有效</li>
<li> (Z) $\to$ ACC，Zout 和 ACCin 有效</li>
</ul>
<h2 id="控制器功能与原理"><a href="#控制器功能与原理" class="headerlink" title="控制器功能与原理"></a>控制器功能与原理</h2><h3 id="结构和功能"><a href="#结构和功能" class="headerlink" title="结构和功能"></a>结构和功能</h3><ul>
<li>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据</li>
<li>输入设备和输出设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传输数据</li>
<li>控制器部件从数据总线接受指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件通过运算所需的控制信号</li>
</ul>
<p>控制器功能：</p>
<ul>
<li>从主存取指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制 CPU、主存、输入输出设备之间的数据流动方向</li>
</ul>
<p>根据控制器产生微操作控制信号的方式不同，控制器可分为</p>
<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
</ul>
<p>两类控制器的 PC 和 IR 是相同的，但确定和表示指令执行步骤的办法以及给出控制部件各部件运算所需控制信号的方案不同</p>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul>
<li>根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号</li>
<li>由复杂的组合逻辑门电路和一些触发器构成</li>
</ul>
<h4 id="硬布线控制单元"><a href="#硬布线控制单元" class="headerlink" title="硬布线控制单元"></a>硬布线控制单元</h4><p>指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键<br>CU 的输入信号来源：</p>
<ul>
<li>经指令译码器译码产生的信息指令</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信号（标志）</li>
<li>系统总线（控制总线）控制信号（中断请求、DMA 请求）</li>
</ul>
<h4 id="硬布线控制器的时序系统及微操作"><a href="#硬布线控制器的时序系统及微操作" class="headerlink" title="硬布线控制器的时序系统及微操作"></a>硬布线控制器的时序系统及微操作</h4><ul>
<li>时钟周期<br>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度对应一个时钟周期，每个节拍内机器可以完成一个或几个需要同时执行的操作</li>
<li>机器周期<br>是所有指令执行过程的一个基准时间，访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期，在存储字长等于指令字长前提下，取指周期视为机器周期</li>
<li>指令周期</li>
<li>微操作命令分析<br>控制单元具有发出各种操作命令（控制信号）序列的功能，这些命令与指令有关</li>
</ul>
<p>执行过程，一条指令分为 3 个工作周期：取指周期、间址周期、执行周期  </p>
<p>取指周期  </p>
<ul>
<li>(PC) $\to$ MAR  </li>
<li>1 $\to$ R  </li>
<li>M(MAR) $\to$ MDR</li>
<li>(MDR) $\to$ IR</li>
<li>OP(IR) $\to$ CU</li>
<li>(PC) + 1  $\to$ PC</li>
</ul>
<p>间址周期</p>
<ul>
<li>Addr(IR) $\to$ MAR</li>
<li>1  $\to$ R</li>
<li>M(MAR)  $\to$ MDR</li>
</ul>
<p>执行周期  </p>
<ul>
<li>非访存指令  </li>
<li>访存指令</li>
</ul>
<h4 id="CPU控制方式"><a href="#CPU控制方式" class="headerlink" title="CPU控制方式"></a>CPU 控制方式</h4><ul>
<li>同步控制方式<br>具有统一的时钟，所有控制信号均来自统一的时钟信号</li>
<li>异步控制方式<br>不存在基准时标信号，各部件按自身固有的速度工作，以应答方式联络</li>
<li>联合控制方式<br>大部分采用同步控制，小部分采用异步控制</li>
</ul>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>采用存储逻辑实现，把微操作信号代码化，使每条机器指令转化为一段微程序并存入一个专门的存储器（控制存储器），微操作控制信号由微指令产生</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>微操作和微命令<br>一条机器指令可以分解为一系列微操作序列，微操作是计算机中最基本、不可再分解的操作；微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，是构成控制系列的最小单位<br>微命令有相容性和互斥性</p>
</li>
<li><p>微指令和微周期<br>微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为微地址<br>一条微地址包括：<br>（1）操作控制字段（微操作码）：用于产生某一步操作所需的各种操作控制信号<br>（2）顺序控制字段（微地址码）：用于控制产生下一条要执行的微指令地址<br>微周期是执行一条微指令所需的时间，通常为一个时钟周期  </p>
</li>
<li><p>主存储器和控制存储器<br>主存储器 M，用于存放程序和数据，在 CPU 外部，用 RAM 实现<br>控制存储器 CM，用于存放微程序，在 CPU 内部，用 ROM 实现</p>
</li>
<li><p>程序和微程序<br>程序是指令的有序集合，用于完成某些特定的功能<br>微程序是微指令的有序集合，一条指令的给你由一段微程序实现<br>微程序和程序是两个不同的概念，微程序由微指令组成，描述机器指令，微程序实质是机器指令的实时解释器，由计算机设计者实现编制并存放于控制存储器 CM 中，无需知道，而程序最终由机器指令组成，由软件设计人员事先编制并存放于主存储器或辅助存储器</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>MAR</td>
<td> 存放主存的读写地址</td>
<td> CMAR</td>
<td> 存放控制存储器的读写微指令地址</td>
</tr>
<tr>
<td> IR</td>
<td> 存放从主存中读出的指令</td>
<td> CMDR/$\mu$IR</td>
<td> 存放控制存储器中读出的微指令</td>
</tr>
</tbody>
</table>
</div>
<h4 id="组成-amp-过程"><a href="#组成-amp-过程" class="headerlink" title="组成&amp;过程"></a>组成 &amp; 过程</h4><ul>
<li>控制存储器：存放各指令对应的微程序</li>
<li>微指令寄存器：用于存放从 CM 中取出的微指令，位数同微指令字长相等</li>
<li>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行</li>
<li>微地址寄存器：接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备  </li>
</ul>
<p>在微程序控制器的控制下计算器执行机器指令的过程：  </p>
<ul>
<li>执行取微指令：自动将取指微程序的入口地址送入 CMAR，从 CM 中读取相应的微指令送入 CMDR（取指微程序的入口地址一般为 CM 的 0 号单元，当取指微程序执行完成，从主存取出的机器指令就已经存入指令寄存器中）</li>
<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令对应的微程序入口地址，并送入 CMAR</li>
<li> 从 CM 中逐条读取对应的微指令并执行</li>
<li>执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第一步</li>
</ul>
<p>微程序和机器指令：<br>一条机器指令对应一个微程序，由于机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编制为一个微程序，这个微程序只负责将指令从主存单元取出送入指令寄存器，也可编制对应的间址周期和中断周期的微程序<br>控制存储器 CM 中的微程序个数 = 机器指令数 + 取指 + 间址 + 中断</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>又称微指令的控制方式，如何对微指令的控制字段进行编码，以形成控制信号  </p>
<ul>
<li><p>直接编码（直接控制）<br>无需进行译码，微指令的微命令字段中每位代表一个微命令，设计微指令，选用某个微命令只需将微命令对应的字段设置为 1 或 0<br>优：简单直观速度快<br>缺：微指令字长过长，n 个微命令要求微指令的操作字段有 n 位，造成控制存储器容量极大</p>
</li>
<li><p>字段直接编码<br>将微指令的微命令字段分成若干小字段，互斥性微命令组合在同一字段，相容性微命令组合在不同字段，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关<br>优：可以缩短微指令字长<br>缺：需要通过编译电路后发出微命令，较直接编译慢</p>
</li>
</ul>
<h4 id="地址形成方式"><a href="#地址形成方式" class="headerlink" title="地址形成方式"></a>地址形成方式</h4><ul>
<li>直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址（断定方式）</li>
<li>根据机器指令的操作码形成，机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
<li>增量计算器法：(CMAR) + 1 $\to$ CMAR</li>
<li> 根据各种标志决定微指令分支转移地址</li>
<li>通过测试网络形成</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li>水平型：直接编码、字段直接编码、字段间接编码、混合编码</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td> $A_1$</td>
<td>$A_2$</td>
<td>$\dots$</td>
<td>$A_{n-1}$</td>
<td>$A_{n}$</td>
<td> 判断测试字段</td>
<td>后继地址字段</td>
</tr>
<tr>
<td>操作控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>顺序控制</td>
</tr>
</tbody>
</table>
</div>
<p>优：微程序短，执行速快<br>缺：微指令长，编写微程序复杂  </p>
<ul>
<li>垂直型：采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th> $\mu$OP</th>
<th>Rd</th>
<th>Rs</th>
</tr>
</thead>
<tbody>
<tr>
<td> 微操作码</td>
<td>目的地址</td>
<td>源地址</td>
</tr>
</tbody>
</table>
</div>
<p>优：微指令短、简单、规整，便于编写微程序<br>缺：微程序长，执行速度慢，工作效率低  </p>
<ul>
<li>混合型<br>在垂直型的基础上增加一些不太复杂的并行操作</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>水平型</th>
<th>垂直型</th>
</tr>
</thead>
<tbody>
<tr>
<td>并行能力</td>
<td>并行能力强、灵活性高、效率高</td>
<td>较差</td>
</tr>
<tr>
<td>执行时间</td>
<td>短</td>
<td>长</td>
</tr>
<tr>
<td>长度</td>
<td>微指令字较长，微程序较短</td>
<td>微指令字较短，微程序较长</td>
</tr>
<tr>
<td>难易程度</td>
<td>难</td>
<td>易</td>
</tr>
</tbody>
</table>
</div>
<h4 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h4><ul>
<li><p>动态微程序设计：根据用户的要求改变微程序，需要可写控制寄存器，使用 EPROM</p>
</li>
<li><p>毫微程序设计：硬件不由微程序直接控制，通过存放在第二级控制存储器中的毫微程序来解释</p>
<h4 id="微程序控制器和硬布线控制器比较"><a href="#微程序控制器和硬布线控制器比较" class="headerlink" title="微程序控制器和硬布线控制器比较"></a>微程序控制器和硬布线控制器比较</h4></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>微程序控制器</th>
<th>硬布线控制器</th>
</tr>
</thead>
<tbody>
<tr>
<td>工作原理</td>
<td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
<td>微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>规整性</td>
<td>较规整</td>
<td>烦琐、不规整</td>
</tr>
<tr>
<td>应用场合</td>
<td> CISC CPU</td>
<td>RISC CPU</td>
</tr>
<tr>
<td> 易扩充性</td>
<td>容易</td>
<td>困难</td>
</tr>
</tbody>
</table>
</div>
<h3 id="异常（内中断）和中断"><a href="#异常（内中断）和中断" class="headerlink" title="异常（内中断）和中断"></a>异常（内中断）和中断</h3><p>异常是由 CPU 内部产生的意外事件，分为硬故障中断和程序性异常<br>硬故障中断：是由硬连线出现异常引起（存储器校验异常、总线错误）<br>程序性异常（软件中断）：CPU 内部因执行指令而引起的（整除 0、溢出、断点、单步跟踪、非法指令）<br>按照异常发生的原因和返回方式，可进一步分为故障、自陷、终止</p>
<ul>
<li><p>故障（Fault）<br>引起故障的指令启动后、执行结束前被检测到的异常，因为无法通过异常处理程序恢复故障，因此不能回到原断点处执行，必须终止进程的执行  </p>
</li>
<li><p>自陷（Trap）<br>事先安排的一种异常事件，事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志人为设置一个陷阱，当执行到被设置了陷阱的指令时，CPU 在执行陷阱指令后，自动根据不同的陷阱类型进行相应的处理，然后返回到自陷程序下一条指令执行。当自陷指令是转移指令时，并不是返回到下一条指令执行，而不是返回到转移目标指令执行</p>
</li>
<li><p>终止（Abort）<br>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，程序将无法继续执行，只能终止，此时调出中断服务程序来重启系统，终止异常和外中断属于硬件中断</p>
</li>
</ul>
<p>中断是来自 CPU 外部、与 CPU 执行指令无关的事件引起的中断<br>中断的分类：</p>
<ul>
<li><p>可屏蔽中断<br>通过可屏蔽中断请求线 INTR 向 CPU 发出中断请求，CPU 可通过设置相应的屏蔽字来屏蔽或不屏蔽某个中断</p>
</li>
<li><p>不可屏蔽中断<br>通过专门的不可屏蔽中断请求 NMI 向 CPU 发出的中断请求，通常是非常紧急的硬件故障</p>
</li>
</ul>
<p>中断和异常的不同：  </p>
<ul>
<li><p>缺页或溢出等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成  </p>
</li>
<li><p>异常的检测由 CPU 完成，不通过外部的某个信号通知 CPU，中断 CPU 必须通过中断请求线获取中断源信息，才能知道哪个设备发生了何种中断</p>
</li>
</ul>
<h3 id="异常和中断响应过程"><a href="#异常和中断响应过程" class="headerlink" title="异常和中断响应过程"></a>异常和中断响应过程</h3><ul>
<li>关中断</li>
<li>保存断点和程序状态</li>
<li>识别异常和中断并转到相应的处理程序（软件识别和硬件识别）</li>
</ul>
<p>软件识别：CPU 设置一个异常状态寄存器，用于记录异常原因，操作系统使用一个统一的异常和中断查询程序，按优先级顺序查询异常状态寄存器，以检查异常和中断类型，先查询到的先处理，然后转到内核中相应的处理程序</p>
<p>硬件识别（向量中断）：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放于中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表内，类型号和中断向量一一对应</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>从两方面提高处理机的并行性：  </p>
<ul>
<li>时间并行：流水线技术</li>
<li>空间并行：超标量处理机</li>
</ul>
<h3 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h3><p>一条指令的执行过程分解为几个阶段，每个阶段由相应的功能部件完成</p>
<ul>
<li>取指 IF</li>
<li> 译码 / 读寄存器 ID</li>
<li> 执行 / 计算地址 EX</li>
<li> 访存 MEM</li>
<li> 写回 WB</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统-1"><a href="#指令系统-1" class="headerlink" title="指令系统"></a>指令系统</h2><p>是指令集体系结构 ISA 的核心<br>ISA 主要包括：</p>
<ul>
<li>指令格式</li>
<li>数据类型及格式</li>
<li>操作数的存放方式</li>
<li>程序可访问的寄存器个数、位数和编号 </li>
<li>存储空间大小和编址方式</li>
<li>寻址方式</li>
<li>指令执行过程的控制方式等<h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3>一条指令包括操作码和地址码字段<br>|||<br>|-|-|<br>| 操作码 | 地址码 |</li>
</ul>
<p>操作码:</p>
<ul>
<li>指出指令应执行的操作</li>
<li>识别指令</li>
<li>了解指令功能</li>
<li>区分操作数地址内容的组成和使用方法  </li>
</ul>
<p>地址码：</p>
<ul>
<li>给出被操作的信息的地址</li>
<li>参加运算的一个或多个操作数所在的地址</li>
<li>运算结果的保存地址</li>
<li>程序的转移地址</li>
<li>被调用的子程序的入口地址等</li>
</ul>
<p>指令长度是指一条指令中包含的二进制代码的位数<br>指令字长取决于</p>
<ul>
<li>操作码的长度</li>
<li>操作数地址码的长度</li>
<li>操作数地址个数  </li>
</ul>
<p>单字长指令：等于机器字长<br>半字长指令：一半机器字长<br>双字长指令：二倍机器字长<br>定长指令字结构：一个指令系统所有指令的长度都是相等的  </p>
<h4 id="零地址指令：无显示地址"><a href="#零地址指令：无显示地址" class="headerlink" title="零地址指令：无显示地址"></a>零地址指令：无显示地址</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li> 不需要操作数的指令</li>
<li>零地址运算指令仅用于堆栈计算机，通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出，送至运算器，运算结果再隐含的压入堆栈  </li>
</ul>
<p>一地址指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
</tr>
</tbody>
</table>
</div>
<p>OP($A_1$) $\to$ $A_1$</p>
<ul>
<li>只有目的操作数，按 $A_1$ 地址读取操作数，进行 OP 操作后，结果存回原地址  </li>
</ul>
<p>(ACC)OP($A_1$) $\to$ ACC</p>
<ul>
<li>隐含约定目的地址的双操作数指令，按指令地址 $A_1$ 地址读取操作数，指令可隐含约定另一个操作数由 ACC 提供，运算结果也将存放在 ACC 中</li>
<li>若指令长度为 32 位，操作码占 8 位，1 个地址码字段占 24 位，指令操作数直接寻址范围 $2^{24}=16M$</li>
</ul>
<h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
</tr>
</tbody>
</table>
</div>
<p>($A_1$)OP($A_2$) $\to$ $A_1$</p>
<ul>
<li>常用的算术和逻辑运算指令，需要两个操作数，需要分别给出目的操作数和源操作数，其中目的操作数地址还用于存放本次运算结果</li>
<li>指令字长位 32 位，操作码占 8 位，两个地址码各占 12 位，则指令操作数的直接寻址范围 $2^{12}=4K$</li>
</ul>
<h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$(结果)</td>
</tr>
</tbody>
</table>
</div>
<p>($A_1$)OP($A_2$) $\to$ $A_3$</p>
<ul>
<li>指令字长位 32 位，操作码占 8 位，3 个地址码各占 8 位，直接寻址范围 $2^8=256$，地址字段为主存地址，则完成一条三地址需要 4 次访存，取指令 1 次，取两个操作数 2 次，存放结果 1 次</li>
</ul>
<h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>$A_4$</td>
</tr>
</tbody>
</table>
</div>
<p>($A_1$) OP ($A_2$) $\to$ $A_3$ ，$A_4$ = 下一条执行指令的地址</p>
<ul>
<li>地址字长为 32 位，操作码占 8 位，4 个地址码各占 6 位，直接寻址范围 $2^6=64$</li>
</ul>
<h3 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h3><p>在指令字的最高位部分分配固定的若干位（定长）表示操作码。<br>n 位操作码字段的指令系统最大能表示 $2^{n}$ 条指令</p>
<h3 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h3><ul>
<li>不允许短码是长码的前缀</li>
<li>各指令的操作码一定不能重复</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td> 0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
</tr>
<tr>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
</tr>
<tr>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td> 操作码情况</td>
<td> OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td> 说明</td>
</tr>
<tr>
<td> 15 条三地址</td>
<td> 0000-1110</td>
<td></td>
<td></td>
<td></td>
<td> 余出 16-15=1，1*2^4=16 种</td>
</tr>
<tr>
<td> 12 条二地址</td>
<td> 1111</td>
<td>0000-1011</td>
<td></td>
<td></td>
<td> 余出 16-12=4，4*2^4=64 种</td>
</tr>
<tr>
<td> 62 条一地址</td>
<td> 1111</td>
<td>(1100-1110)/1111</td>
<td>(0000-1111)/(0000-1101)</td>
<td></td>
<td> 余出 64-62=2，2*2^4=32 种</td>
</tr>
<tr>
<td> 32 条零地址</td>
<td> 1111</td>
<td>1111</td>
<td>1110-1111</td>
<td>0000-1111</td>
</tr>
</tbody>
</table>
</div>
<h3 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h3><ul>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位</li>
<li>转移</li>
<li>输入输出</li>
</ul>
<h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><p>确定本条指令的数据地址以及下一条待执行指令的地址，分为：</p>
<ul>
<li><p>指令寻址：寻找下条要执行的指令<br>（1）顺序寻址<br>通过 PC+(1)，自动形成下一条指令<br>（2）跳跃寻址<br>通过转移指令实现，下条指令的地址不由 PC 自动给出，而由本条指令给出下条指令地址的计算方式。是否可跳跃受到状态寄存器和操作数的控制，跳跃的结果是当前指令修改 PC 值，下一条指令仍通过 PC 给出</p>
</li>
<li><p>数据寻址：寻找本条指令的数据<br>通常在指令字中设一个字段指明寻址方式</p>
<p>  ||||<br>  |-|-|-|<br>  | 操作码 | 寻址特征 | 形式地址 A|</p>
</li>
</ul>
<h3 id="常见数据寻址方式"><a href="#常见数据寻址方式" class="headerlink" title="常见数据寻址方式"></a>常见数据寻址方式</h3><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>不明显的给出操作数，在指令中隐含操作数地址</p>
<ul>
<li>优：有利于缩短指令字长</li>
<li>缺：需要增加存储操作数或隐含地址的硬件</li>
</ul>
<h4 id="立即（数）寻址"><a href="#立即（数）寻址" class="headerlink" title="立即（数）寻址"></a>立即（数）寻址</h4><p>指令的地址字段指出的不是操作数地址，而是操作数本身，又称立即数，# 表示立即寻址特征，使用补码表示</p>
<ul>
<li>优：指令在执行阶段不访问主存，指令执行时间最短</li>
<li>缺：A 的位数限制立即数的范围</li>
</ul>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>指令中的形式地址 A 是操作数的真实地址 EA，EA=A  </p>
<ul>
<li>优：简单，访存 1 次，不需要专门计算操作数的地址</li>
<li>缺：A 的位数决定了指令操作数的寻址范围，操作数的地址不易修改</li>
</ul>
<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址的存储单元地址，EA=(A)，间接寻址可以迭代多次<br>间接寻址，主存第一位表示是否为多次间址</p>
<ul>
<li>优：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数），便于编制程序（用间址寻址可方便的完成子程序返回）</li>
<li>缺：访问速度慢</li>
</ul>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>指令字中直接给出操作数所在的寄存器编号 EA= $R_i$，操作数在由 $R_i$ 所指的寄存器内</p>
<ul>
<li>优：指令执行阶段不访存，只访问寄存器，寄存器对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量 / 矩阵运算</li>
<li>缺：寄存器昂贵，有限</li>
</ul>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>寄存器 $R_i$ 中给出的不是一个操作数，而是操作数所在主存单元的地址 EA=($R_i$)</p>
<ul>
<li>优：与一般间址寻址速度快</li>
<li>缺：需要访存</li>
</ul>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>PC 的内容加上指令格式的形式地址 A 而形成操作数的有效地址 EA=(PC)+A，A 是相对于当前 PC 的值的位移量，可正可负，用补码表示，A 的位数决定寻址范围</p>
<ul>
<li>操作数的地址是不固定的，随 PC 的值变化而变化，且与指令地址之间相差一个固定值，便于程序浮动，广泛用于转移指令</li>
<li> JMP A，CPU 从存储器取出一字节，自动执行 (PC)+1 $\to$ PC，若转移指令的地址为 X，且占 2B，取出该指令后，PC 自增 2，(PC)=X+2，执行完该指令，会自动跳转至 X+2+A 的地址继续执行</li>
</ul>
<h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>将 CPU 的基址寄存器 BR 的内容加上指令格式的形式地址 A 形成操作数的有效地址 EA=(BR)+A，基址寄存器可采用专用寄存器也可为通用寄存器</p>
<ul>
<li>基址寄存器面向操作系统，内容通过操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性</li>
<li>执行过程中基址寄存器内容不变，形式地址可变（偏移量）</li>
<li><p>采用通用寄存器作为基址寄存器，用户可决定使用哪个寄存器，内容由操作系统确定</p>
</li>
<li><p>优：可扩大寻址范围（基址寄存器位数大于形式地址 A 的位数），用户不必考虑自己的程序存于主存哪个区域，有利于多道程序设计，可用于制成浮动程序</p>
</li>
<li>缺：偏移量位数较短</li>
</ul>
<h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容之和，EA=(IX)+A</p>
<ul>
<li>IX 可使用专用寄存器或通用寄存器</li>
<li>变址寄存器面向用户，在程序执行过程，变址寄存器内容可由用户改变（作为偏移量），形式地址 A 不变（作为基地址）</li>
<li>可扩大寻址范围（变址寄存器位数大于形式地址 A 的位数），适合编制循环程序，偏移量的位数（IX）足以表示整个存储空间</li>
</ul>
<h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>堆栈是存储器（或专用寄存器组）中一块特定的、按照后进先出（LIFO）的原则管理的存储区，存储区读写单元地址是用一个特定寄存器给出的称为堆栈指针 (SP)，分为硬堆栈（不适合做大容量堆栈）和软堆栈（主存划出一段区域）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>有效地址</th>
<th>访存次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>隐含寻址</td>
<td>程序指定</td>
<td> 0</td>
</tr>
<tr>
<td> 立即寻址</td>
<td> A 是操作数</td>
<td> 0</td>
</tr>
<tr>
<td> 直接寻址</td>
<td> EA=A</td>
<td>1</td>
</tr>
<tr>
<td> 一次间接寻址</td>
<td> EA=(A)</td>
<td>2</td>
</tr>
<tr>
<td> 寄存器寻址</td>
<td> EA= $R_i$</td>
<td>0</td>
</tr>
<tr>
<td> 寄存器间接一次寻址</td>
<td> EA = ($R_i$)</td>
<td>1</td>
</tr>
<tr>
<td> 相对寻址</td>
<td> EA=(PC)+A</td>
<td>1</td>
</tr>
<tr>
<td> 基址寻址</td>
<td> EA=(BR)+A</td>
<td>1</td>
</tr>
<tr>
<td> 变址寻址</td>
<td> EA=(IX)+A</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理・数据表示与运算</title>
    <url>/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="数据表示和运算"><a href="#数据表示和运算" class="headerlink" title="数据表示和运算"></a>数据表示和运算</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li><strong>r 进制</strong><br>$K<em>{n} K</em>{n-1} K<em>{n-2} \dots K</em>{0} K<em>{-1} \dots K</em>{-m}$<br>数值表示 $K<em>{n} r^{n} + K</em>{n-1} r^{n-1} + \dots + K<em>{0} r^{0} + K</em>{-1} r^{-1} + \dots + K<em>{-m} r^{-m} = \sum</em>{i=n}^{-m} K_{i} r^{i}$</li>
<li> 二进制<br>$01 \space r=2$</li>
<li> 八进制<br>$01234567 \space r=8=2^3$</li>
<li> 十六进制<br>$0123456789ABCDEF \space r=16=2^4$<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2>4 位二进制数码与 1 位十六进制数码相对应<br>3 位二进制数码与 1 位八进制数码相对应  </li>
</ul>
<h2 id="原反补移"><a href="#原反补移" class="headerlink" title="原反补移"></a>原反补移</h2><ul>
<li><p>原码</p>
</li>
<li><p>反码</p>
</li>
<li>补码</li>
<li>移码</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理・虚拟存储器页式段式和段页式</title>
    <url>/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="虚拟存储器·页式·段式·段页式"><a href="#虚拟存储器·页式·段式·段页式" class="headerlink" title="虚拟存储器·页式·段式·段页式"></a>虚拟存储器・页式・段式・段页式</h1><p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>
<ul>
<li>实地址 = 主存页号 + 页内字地址</li>
<li>虚地址 = 虚存页号 + 页内字地址</li>
<li>辅存地址 = 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>
</ul>
<p>CPU 使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>
<ul>
<li>在内存，通过地址变换，CPU 可直接访问主存指示的数据单元</li>
<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>
</ul>
<h2 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h2><p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong>  </p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td> 有效位</td>
<td>脏位</td>
<td>引用位</td>
<td>物理页</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>有效位（装入位）：表示对应页是否在主存</li>
<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>
<li>引用位（使用位）：配合替换算法进行设置</li>
</ul>
<p>CPU 运行指令时，虚地址转实地址：</p>
<ul>
<li>页表基址寄存器存放进程的页表首地址</li>
<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>
<li>装入位为 1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>
<li>装入位为 0，说明缺页，需要操作系统进行缺页处理</li>
</ul>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表 (TLB)</h3><p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>快表通常采用组相联或全相联方式<br>|t|r|p|<br>|-|-|-|<br>| 标记 | 有效位 | 实页号 |</p>
<h3 id="具有TLB和Cache的多级存储系统"><a href="#具有TLB和Cache的多级存储系统" class="headerlink" title="具有TLB和Cache的多级存储系统"></a>具有 TLB 和 Cache 的多级存储系统</h3><p>三种缺失的情况<br>||TLB|Page|Cache | 说明 |<br>|-|-|-|-|-|<br>|1 | 命中 | 命中 | 命中 | TLB 命中则 Page 一定命中，信息在主存，就可能在 Cache|<br>|2 | 命中 | 命中 | 缺失 | TLB 命中则 Page 一定命中，信息在主存，也可能不在 Cache|<br>|3 | 缺失 | 命中 | 命中 | TLB 缺失但 Page 可能命中，信息在主存，就可能在 Cache|<br>|4 | 缺失 | 命中 | 缺失 | TLB 缺失但 Page 一定命中，信息在主存，也可能不在 Cache|<br>|5 | 缺失 | 缺失 | 缺失 | TLB 缺失则 Page 也可能缺失，信息不在主存，也一定不在 Cache|</p>
<h2 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h2><p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表<br>|||||<br>|-|-|-|-|<br>| 段号 | 段首地址 | 装入位 | 段长 |</p>
<p>CPU 访存时：</p>
<ul>
<li>根据段号与段表基地址拼接成对应的段表行</li>
<li>根据段表行的装入位判断是否调入内存</li>
<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址<h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍<br>||||<br>|-|-|-|<br>| 段号 | 段内页号 | 页内地址 |</li>
</ul>
<p>CPU 访存：</p>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成实地址<h2 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与 Cache 的比较</h2>| 相同 | 不同 |<br>|-|-|<br>| 目的均为提供系统性能 | Cache 主要解决系统速度，虚拟存储器解决主存容量 |<br>| 均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大 | Cache 由硬件实现，对程序员透明，虚拟存储器由 OS 和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明 |<br>| 都有地址的映射、替换算法、更新策略 ||<br>| 均依据程序的局部性原理 ||</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络・传输层</title>
    <url>/2023/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;传输层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;功能概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;提供应用进程间的逻辑通信&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;复用和分用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;复用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;发送方不同的应用进程使用同一个传输层协议&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;分用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;接收方的传输层在剥去报文首部后能把这些数据正确交付至目的应用进程&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;差错检测（首部和数据部分）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;TCP和UDP&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;寻址与端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;端口作用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;让应用层各应用程序将其数据通过端口向下交付给传输层&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;端口号&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;长度16bit <span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>65536</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{16}=65536</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.8141079999999999em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>1</span><span class=\&quot;mord mtight\&quot;>6</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2777777777777778em;\&quot;></span><span class=\&quot;mrel\&quot;>=</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2777777777777778em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>6</span><span class=\&quot;mord\&quot;>5</span><span class=\&quot;mord\&quot;>5</span><span class=\&quot;mord\&quot;>3</span><span class=\&quot;mord\&quot;>6</span></span></span></span>个不同的端口号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;端口划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;服务器端使用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;熟知端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;0 ~ 1023&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;FTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;21&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;TELNET&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;23&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;SMTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;25&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;DNS&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;53&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;TFTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;69&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;80&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;SNMP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;161&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;登记端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;1024 ~ 49151&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;客户端使用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;客户进程运行时动态选择&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;又称临时端口&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;套接字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;端口和IP拼接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;Socket = (IP地址:端口号)&quot;}]}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;UDP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;在IP数据报基础上增加&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;复用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;分用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;差错检测&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;无需建立连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;无连接状态&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;分组首部开销小&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;不保证可靠交付&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;面向报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;IP协议字段17&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;报文长度由发送程序决定&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;首部格式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;8B 4字段构成&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;源端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;需要对方回信时选用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;不需要可用全0&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;目的端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;终点交付报文时必须使用&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;长度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;最小值8（仅首部）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;校验和&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;检测UDP数据报传输过程是否有错&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;有错丢弃&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;源主机不想计算校验和填写全0&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;校验&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;计算校验和在UDP数据报前增加12B伪首部&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;伪首部不是UDP真正首部只用于计算校验和&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;TCP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;面向连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;可靠交付&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;全双工通信&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;允许双方任何时候都能发送数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;两端设有缓存暂存数据&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;发送缓存&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;发送程序传给发送方TCP准备的数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;TCP已发送尚未收到确认的数据&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;接收缓存&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;按序到达但尚未被接收程序读取的数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;不按序到达的数据&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;面向字节流&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;仅视为一连串无结构的字节流&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;报文长度由接受方给出的窗口值和当前网络拥塞程度决定&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;报文段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;源端口和目的端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;2B + 2B&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;序号&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;4B&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;0 ~ <span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{32}-1</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.897438em;vertical-align:-0.08333em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>3</span><span class=\&quot;mord mtight\&quot;>2</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span><span class=\&quot;mbin\&quot;>−</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>1</span></span></span></span>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;面向字节流&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;TCP连接传送的字节流的每个字节都按顺序编号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;本报文段发送的数据的第一个字节的序号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;确认号&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;4B&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;期望收到对方下一报文段的第一个数据字节的序号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;确认号为N表明到序号N-1为止的所有数据都已正确收到&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;数据偏移&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;表示首部长度&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;指出TCP报文段的数据起始处距离TCP报文段的起始处有多远&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;保留&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;占6位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;今后使用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;目前置0&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;紧急位URG&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;URG=1&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;表明紧急指针字段有效&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;应尽快传送&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;确认位ACK&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;ACK=1&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;确认号字段才有效&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;ACK=0&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;确认号无效&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;推送位PSH&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;接收方TCP收到PSH=1的报文段&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[120,121]},&quot;v&quot;:&quot;尽快交付给接收应用进程&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;不等到缓存满在交付&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;复位位RST&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;RST=1&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[124,125]},&quot;v&quot;:&quot;表明TCP连接中出现严重错误&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;必须释放链接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;重新建立连接&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;同步位SYN&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;SYN=1表明这是一个连接请求或连接接受报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[129,132]},&quot;v&quot;:&quot;SYN=1 ACK=0表明这是一个连接请求报文<br>\n对方同意建立连接<br>\n则响应报文中使用SYN=1 ACK=1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;终止位FIN&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;用来释放一个连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;FIN=1 表明此报文段的发送方的数据已经发送完毕&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;并要求释放运输链接&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[136,137]},&quot;v&quot;:&quot;窗口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;2B&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{16}-1</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.897438em;vertical-align:-0.08333em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>1</span><span class=\&quot;mord mtight\&quot;>6</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span><span class=\&quot;mbin\&quot;>−</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>1</span></span></span></span>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;现在允许对方发送的数据量&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;设确认号为701 窗口字段1000&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[141,144]},&quot;v&quot;:&quot;从701起发送此报文段的一方<br>\n还有接受1000字节数据的接受缓存空间<br>\n701~1700&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;校验和&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[145,146]},&quot;v&quot;:&quot;2B&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;校验和字段检验的范围包括首部和数据两部分&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[147,148]},&quot;v&quot;:&quot;紧急指针&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;选项&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[149,150]},&quot;v&quot;:&quot;填充&quot;}]}]}]}"></svg>
</div>

]]></content>
  </entry>
  <entry>
    <title>计算机网络・网络层</title>
    <url>/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;网络层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;功能概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;数据报服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;简单灵活&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;无连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;尽最大努力交付&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,9]},&quot;v&quot;:&quot;为了使路由器简单<br>\n可靠通信由传输层负责<br>\n传送分组可能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;出错&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;丢失&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;重复&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;失序&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;超时&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;异构网络互连&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;各层中继系统&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;物理层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;转发器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;集线器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;数据链路层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;网桥&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;交换机&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;网络层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<strong>路由器</strong>&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;网络层以上&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;网关&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;路由与转发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;路由选择（确定哪一条路径）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[28,32]},&quot;v&quot;:&quot;按照分布式算法<br>\n根据从各相邻的路由器<br>\n所得的关于整个网络拓扑的变化情况<br>\n动态改变选择的路由&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;分组转发（一个分组到达时采取的动作）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[33,36]},&quot;v&quot;:&quot;根据转发表<br>\n将用户IP数据报<br>\n从合适端口转发出去&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;SDN Software Define Network&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;网络层定义&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;数据平面&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;转发&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;控制平面&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;路由选择&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;SDN网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;数据、控制平面分离&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[44,46]},&quot;v&quot;:&quot;&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[44,46]},&quot;v&quot;:&quot;数据平面&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;控制平面&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;集中式&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;拥塞控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;开环控制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;闭环控制&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;静态路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;非自适应路由算法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;网络管理员手动配置&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;拓扑结构发生变化手动修改静态路由&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;小型网络&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;动态路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;自适应路由算法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;互连的路由器间彼此交换路由表&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;距离-向量算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[62,65]},&quot;v&quot;:&quot;所有节点定期<br>\n将各自整个路由选择表<br>\n转发到相邻节点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;每条路径的目的地&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;路径的代价（距离）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;RIP算法&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;链路状态路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[69,71]},&quot;v&quot;:&quot;每个参与算法的节点<br>\n均具有完全的拓扑信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;主动测试所有相邻节点&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;定期将链路状态传播所有其他节点&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;OSPF算法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;洪泛法发送信息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;所有路由器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;路由器相邻的所有路由链路状态&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;度量 metric&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;费用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;距离&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;时延&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;带宽&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;链路状态变化才发送&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;层次路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[84,86]},&quot;v&quot;:&quot;网络规模增大<br>\n路由表增大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[86,88]},&quot;v&quot;:&quot;整个互联网划分<br>\n划分为很多较小的自治系统&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;内部网关协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;RIP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;OSPF&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;外部网关协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;BGP&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;IPV4&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;IPV4分组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;首部长度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;占4位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;最大十进制数15&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;最大值15 * 4B = 60B&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;总长度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;首部和数据之和&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;单位为字节&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[102,104]},&quot;v&quot;:&quot;以太网帧的最大传送单元<br>\nMTU=1500B&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;最大长度<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>65535</mn><mi>B</mi></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{16}=65535B</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.8141079999999999em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>1</span><span class=\&quot;mord mtight\&quot;>6</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2777777777777778em;\&quot;></span><span class=\&quot;mrel\&quot;>=</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2777777777777778em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.68333em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>6</span><span class=\&quot;mord\&quot;>5</span><span class=\&quot;mord\&quot;>5</span><span class=\&quot;mord\&quot;>3</span><span class=\&quot;mord\&quot;>5</span><span class=\&quot;mord mathnormal\&quot; style=\&quot;margin-right:0.05017em;\&quot;>B</span></span></span></span>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;标识&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;占16位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;计数器 i++&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[108,112]},&quot;v&quot;:&quot;数据报长度超过网络MTU<br>\n必须分片<br>\n此时每个数据报片<br>\n均复制一次标识号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;标志&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;占3位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[114,117]},&quot;v&quot;:&quot;标志字段最低位MF<br>\nMF=1表示后面还有分片<br>\nMF=0表示最后一个分片&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[117,119]},&quot;v&quot;:&quot;标志字段中间的一位DF<br>\nDF=0时才允许分片&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;片偏移&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[120,121]},&quot;v&quot;:&quot;占13位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[121,123]},&quot;v&quot;:&quot;较长的分组在分片后<br>\n某片在原分组中相对位置&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;以8个字节为偏移单位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[124,127]},&quot;v&quot;:&quot;除最后一个分片<br>\n每个分片的长度一定<br>\n是8B的整数倍&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;生存时间 TTL&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;占8位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;数据报可通过路由数最大值&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;确保分组不会永远在网络中循环&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;占8位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;TCP : 6&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;UDP : 17&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;首部校验和&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[136,137]},&quot;v&quot;:&quot;占16位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;只校验分组的首部&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;不校验数据部分&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;源地址字段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;占4B&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[141,142]},&quot;v&quot;:&quot;目的地址字段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;占4B&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[143,144]},&quot;v&quot;:&quot;数据报分片&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[144,146]},&quot;v&quot;:&quot;链路承载最大数据量<br>\n最大传送单元MTU&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[146,151]},&quot;v&quot;:&quot;IP数据报4000B<br>\n首部20B 数据3980B<br>\nMTU=1500B 标识=777<br>\nMF=0 DF=0<br>\n<strong>分片大小为8B的倍数=1480</strong>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[151,152]},&quot;v&quot;:&quot;分片1&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;标识=777&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[153,154]},&quot;v&quot;:&quot;片偏移=0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;MF=1 DF=0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[155,156]},&quot;v&quot;:&quot;有效数据1480B&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;分片2&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[157,158]},&quot;v&quot;:&quot;标识=777&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;片偏移=185&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[159,160]},&quot;v&quot;:&quot;MF=1 DF=0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;有效数据1480B&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[161,162]},&quot;v&quot;:&quot;分片3&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;标识=777&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[163,164]},&quot;v&quot;:&quot;片偏移=370&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;MF=0 DF=0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[165,166]},&quot;v&quot;:&quot;有效数据(3980-1480*2)B&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;IPV4地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[167,168]},&quot;v&quot;:&quot;A类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[168,169]},&quot;v&quot;:&quot;1 ~ 126&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[169,171]},&quot;v&quot;:&quot;<strong>0</strong>000,0000;0;0;0 ~<br>\n<strong>0</strong>111,1111;1;1;1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[171,172]},&quot;v&quot;:&quot;B类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;128 ~ 191&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[173,175]},&quot;v&quot;:&quot;<strong>10</strong>00,0000;0;0;0<br>\n<strong>10</strong>11,1111;1;1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[175,176]},&quot;v&quot;:&quot;C类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;192 ~ 223&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[177,179]},&quot;v&quot;:&quot;<strong>110</strong>0,0000;0;0;0 ~<br>\n<strong>110</strong>1,1111;1;1;1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[179,180]},&quot;v&quot;:&quot;D类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;224 ~ 239&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[181,183]},&quot;v&quot;:&quot;<strong>1110</strong>,0000;0;0;0 ~<br>\n<strong>1110</strong>,1111;1;1;1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[183,184]},&quot;v&quot;:&quot;E类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;240 ~ 255&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[185,187]},&quot;v&quot;:&quot;<strong>1111</strong>,0000;0;0;0 ~<br>\n<strong>1111</strong>,1111;1;1;1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[187,188]},&quot;v&quot;:&quot;IP::={&amp;lt;网络号&amp;gt;,&amp;lt;主机号&amp;gt;}&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;主机号全为0表示本网络&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[189,190]},&quot;v&quot;:&quot;主机号全1表示本网络广播地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[190,191]},&quot;v&quot;:&quot;127.x.x.x为环回自检地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;表示任意主机自身&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[192,194]},&quot;v&quot;:&quot;目的地址为127.x的<br>\nIP数据报不会出现在任何网络&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[194,195]},&quot;v&quot;:&quot;32位全为0表示本网络上本主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;32位全为1表示整个TCP/IP网络的广播地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;IP地址使用范围&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[197,198]},&quot;v&quot;:&quot;A&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[198,199]},&quot;v&quot;:&quot;最大网络可用数=<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{7}-2</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.897438em;vertical-align:-0.08333em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>7</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span><span class=\&quot;mbin\&quot;>−</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>2</span></span></span></span>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[199,200]},&quot;v&quot;:&quot;第一个可用的网络号=1&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;最后一个可用的网络号=126&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[201,202]},&quot;v&quot;:&quot;每个网络中最大的主机=<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{24}-2</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.897438em;vertical-align:-0.08333em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>2</span><span class=\&quot;mord mtight\&quot;>4</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span><span class=\&quot;mbin\&quot;>−</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>2</span></span></span></span>&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;B&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[203,204]},&quot;v&quot;:&quot;最大网络可用数=<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{14}</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.8141079999999999em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>1</span><span class=\&quot;mord mtight\&quot;>4</span></span></span></span></span></span></span></span></span></span></span></span>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;第一个可用的网络号=128.0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[205,206]},&quot;v&quot;:&quot;最后一个可用的网络号=191.255&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;每个网络中最大的主机=<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{16}-2</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.897438em;vertical-align:-0.08333em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>1</span><span class=\&quot;mord mtight\&quot;>6</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span><span class=\&quot;mbin\&quot;>−</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>2</span></span></span></span>&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[207,208]},&quot;v&quot;:&quot;C&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[208,209]},&quot;v&quot;:&quot;最大网络可用数=<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{21}</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.8141079999999999em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>2</span><span class=\&quot;mord mtight\&quot;>1</span></span></span></span></span></span></span></span></span></span></span></span>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[209,210]},&quot;v&quot;:&quot;第一个可用的网络号=192.0.0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[210,211]},&quot;v&quot;:&quot;最后一个可用的网络号=223.255.255&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[211,212]},&quot;v&quot;:&quot;每个网络中最大的主机=<span class=\&quot;katex\&quot;><span class=\&quot;katex-mathml\&quot;><math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding=\&quot;application/x-tex\&quot;>2^{8}-2</annotation></semantics></math></span><span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.897438em;vertical-align:-0.08333em;\&quot;></span><span class=\&quot;mord\&quot;><span class=\&quot;mord\&quot;>2</span><span class=\&quot;msupsub\&quot;><span class=\&quot;vlist-t\&quot;><span class=\&quot;vlist-r\&quot;><span class=\&quot;vlist\&quot; style=\&quot;height:0.8141079999999999em;\&quot;><span style=\&quot;top:-3.063em;margin-right:0.05em;\&quot;><span class=\&quot;pstrut\&quot; style=\&quot;height:2.7em;\&quot;></span><span class=\&quot;sizing reset-size6 size3 mtight\&quot;><span class=\&quot;mord mtight\&quot;><span class=\&quot;mord mtight\&quot;>8</span></span></span></span></span></span></span></span></span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span><span class=\&quot;mbin\&quot;>−</span><span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2222222222222222em;\&quot;></span></span><span class=\&quot;base\&quot;><span class=\&quot;strut\&quot; style=\&quot;height:0.64444em;vertical-align:0em;\&quot;></span><span class=\&quot;mord\&quot;>2</span></span></span></span>&quot;}]}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[212,213]},&quot;v&quot;:&quot;NAT&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[213,215]},&quot;v&quot;:&quot;专门网络地址转换为公用地址<br>\n而对外隐藏内部管理的IP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[215,216]},&quot;v&quot;:&quot;划分私有IP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[216,217]},&quot;v&quot;:&quot;只用于LAN&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[217,218]},&quot;v&quot;:&quot;不用于WAN&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[218,219]},&quot;v&quot;:&quot;私有IP不能直接接入Internet&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[219,220]},&quot;v&quot;:&quot;通过网关利用NAT&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;私有IP转为Internet中合法的全球IP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[221,222]},&quot;v&quot;:&quot;网段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[222,223]},&quot;v&quot;:&quot;A&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[223,224]},&quot;v&quot;:&quot;1个A类&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[224,225]},&quot;v&quot;:&quot;10.0.0.0 ~ 10.255.255.255&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[225,226]},&quot;v&quot;:&quot;B&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[226,227]},&quot;v&quot;:&quot;16个B类&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[227,228]},&quot;v&quot;:&quot;172.16.0.0 ~ 172.31.255.255&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[228,229]},&quot;v&quot;:&quot;C&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[229,230]},&quot;v&quot;:&quot;256个C类&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[230,231]},&quot;v&quot;:&quot;192.168.0.0 ~ 192.168.255.255&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[231,232]},&quot;v&quot;:&quot;目的地址为私有IP不进行转发：本地互联网&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[232,233]},&quot;v&quot;:&quot;NAT转换表&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[233,234]},&quot;v&quot;:&quot;WAN : LAN&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;138.76.29.7:5001 | 192.168.0.2:2233&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[235,236]},&quot;v&quot;:&quot;普通路由器转发IP数据报，不改变源IP和目的IP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[236,237]},&quot;v&quot;:&quot;NAT路由器转发IP数据报，一定改变&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[237,238]},&quot;v&quot;:&quot;子网划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[238,239]},&quot;v&quot;:&quot;两级IP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[239,240]},&quot;v&quot;:&quot;缺点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[240,241]},&quot;v&quot;:&quot;地址空间利用率低&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[241,242]},&quot;v&quot;:&quot;每分配一个网络号会是路由表变得太大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[242,243]},&quot;v&quot;:&quot;网络性能变坏&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[243,244]},&quot;v&quot;:&quot;不够灵活&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[244,245]},&quot;v&quot;:&quot;划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[245,246]},&quot;v&quot;:&quot;对内表现为子网划分，对外表现为没有划分的网络&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[246,247]},&quot;v&quot;:&quot;从主机号借用若干比特作为子网号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[247,248]},&quot;v&quot;:&quot;IP = {&amp;lt;网络号&amp;gt;,&amp;lt;子网号&amp;gt;,&amp;lt;主机号&amp;gt;}&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[248,254]},&quot;v&quot;:&quot;从其他网络发送给本单位某主机的IP<br>\n仍然根据IP目的网络<br>\n找到连接本单位网络的路由<br>\n该路由收到IP<br>\n按目的网络和子网找到目的子网<br>\n最后交付IP至目的主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[254,257]},&quot;v&quot;:&quot;划分只根据主机号借用位作子网号<br>\n不改变网络号<br>\n从一个IP地址或首部无法判断是否子网划分&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[257,258]},&quot;v&quot;:&quot;子网掩码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[258,259]},&quot;v&quot;:&quot;表达对原网络主机号的借位&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[259,260]},&quot;v&quot;:&quot;将IP与子网掩码按位相与<em>AND</em>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[260,261]},&quot;v&quot;:&quot;得到相应的子网地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[261,262]},&quot;v&quot;:&quot;要求&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[262,263]},&quot;v&quot;:&quot;主机设置IP地址必须设置子网掩码&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[263,264]},&quot;v&quot;:&quot;同属一个子网的所有主机及路由器的相应端口必须设置相同的子网掩码&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[264,265]},&quot;v&quot;:&quot;路由器的路由表所包含信息：目的网络地址、子网掩码、下一跳地址&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[265,266]},&quot;v&quot;:&quot;CIDR&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[266,267]},&quot;v&quot;:&quot;在变成子网掩码基础上消除ABC类网络划分&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[267,268]},&quot;v&quot;:&quot;在软件下实现超网构成&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[268,269]},&quot;v&quot;:&quot;IP = {&amp;lt;网络前缀&amp;gt;,&amp;lt;主机号&amp;gt;}&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[269,270]},&quot;v&quot;:&quot;斜线记法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[270,271]},&quot;v&quot;:&quot;IP地址/网络前缀所占比特数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[271,272]},&quot;v&quot;:&quot;128.14.32.5/20&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[272,273]},&quot;v&quot;:&quot;IP:      1000,0000;0000,1110;0010,0000;0000,0101&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[273,274]},&quot;v&quot;:&quot;子网掩码: 1111,1111;1111,1111;1111,0000;0000,0000&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[274,276]},&quot;v&quot;:&quot;网络前缀: <em>1000,0000;0000,1110;0010</em>,0000;0000,0000<br>\n128.14.32.0&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[276,277]},&quot;v&quot;:&quot;CIDR不使用子网，仍使用掩码&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[277,278]},&quot;v&quot;:&quot;CIDR地址块&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[278,279]},&quot;v&quot;:&quot;网络前缀相同的连续IP组成&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[279,280]},&quot;v&quot;:&quot;206.1.0.0/17&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[280,281]},&quot;v&quot;:&quot;<em>1100,1010;0000,0001;0</em>000,0000;0000,0000&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[281,282]},&quot;v&quot;:&quot;206.1.128.0/17&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[282,283]},&quot;v&quot;:&quot;<em>1100,1010;0000,0001;1</em>000,0000;0000,0000&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[283,284]},&quot;v&quot;:&quot;206.1.0.0/16&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[284,285]},&quot;v&quot;:&quot;<em>1100,1010;0000,0001</em>;0000,0000;0000,0000&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[285,286]},&quot;v&quot;:&quot;最长前缀匹配（最佳匹配）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[286,292]},&quot;v&quot;:&quot;路由表中的每个项目由&amp;lt;网络前缀&amp;gt;&amp;lt;下一跳地址&amp;gt;组成<br>\n在查找路由表时可能不止一个匹配结果<br>\n匹配结果中选择具有最长网络前缀的路由<br>\n网络前缀越长<br>\n地址块越小<br>\n路由越具体&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[292,293]},&quot;v&quot;:&quot;网络层转发分组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[293,295]},&quot;v&quot;:&quot;基于目的主机所在的网络<br>\n网络数远小于主机数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[295,298]},&quot;v&quot;:&quot;分组到达路由器<br>\n路由器根据目的IP地址的网络前缀查找转发表<br>\n确定下一跳应到哪个路由器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[298,302]},&quot;v&quot;:&quot;转发表中每条路由必须有下面两条信息<br>\n(目的网络, 下一跳地址)<br>\nIP数据报最终一定可以找到目的主机所在目的网络上的路由器<br>\n达到最后一个路由器，向目的主机进行直接交付&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[302,303]},&quot;v&quot;:&quot;ARP、DHCP、ICMP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[303,304]},&quot;v&quot;:&quot;IP地址与硬件地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[304,305]},&quot;v&quot;:&quot;IP地址是网络层使用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[305,306]},&quot;v&quot;:&quot;MAC地址是数据链路层使用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[306,312]},&quot;v&quot;:&quot;网络层及网络层之上使用IP<br>\nIP地址放在IP数据报首部<br>\nMAC地址放在MAC帧首部<br>\n数据封装后<br>\nIP数据报分组封装为MAC帧<br>\n数据链路层看不见数据报分组中的IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[312,313]},&quot;v&quot;:&quot;决定了MAC地址无法跨网络通信&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[313,314]},&quot;v&quot;:&quot;ARP Address Resolution Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[314,317]},&quot;v&quot;:&quot;无论网络层使用什么协议<br>\n在实际网络的链路上传输数据帧<br>\n必须使用硬件地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[317,318]},&quot;v&quot;:&quot;使用ARP进行映射&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[318,319]},&quot;v&quot;:&quot;每台主机设有ARP映射表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[319,320]},&quot;v&quot;:&quot;工作原理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[320,325]},&quot;v&quot;:&quot;主机A向本局域网上某台主机B发送IP数据报<br>\n先在ARP高速缓存中查找有无主机B的IP<br>\n有则将对应MAC地址写入MAC帧<br>\n无则通过目的MAC地址<br>\nFFFF-FF-FF-FF-FF的帧封装并广播ARP请求分组&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[325,327]},&quot;v&quot;:&quot;主机B收到该ARP请求分组，向ARP响应分组（单播）<br>\n分组包含B的IP与MAC地址的映射&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[327,330]},&quot;v&quot;:&quot;主机A收到ARP响应分组<br>\n写入ARP缓存<br>\n按查询到的硬件地址发送MAC帧&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[330,331]},&quot;v&quot;:&quot;DHCP Dynamic Host Configuration Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[331,332]},&quot;v&quot;:&quot;动态分配地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[332,333]},&quot;v&quot;:&quot;即插即用联网机制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[333,334]},&quot;v&quot;:&quot;应用层协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[334,335]},&quot;v&quot;:&quot;UDP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[335,336]},&quot;v&quot;:&quot;客户/服务器模式&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[336,337]},&quot;v&quot;:&quot;工作原理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[337,340]},&quot;v&quot;:&quot;需要IP地址的主机在启动时<br>\n就向DHCP服务器广播发送发现报文<br>\n主机成为DHCP客户&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[340,342]},&quot;v&quot;:&quot;DHCP客户只能在一段有限的时间内<br>\n使用分配到的IP地址：租用期&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[342,343]},&quot;v&quot;:&quot;ICMP Internet Control Message Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[343,346]},&quot;v&quot;:&quot;提高IP数据报交付成功机会<br>\n在网络层使用网际控制报文协议<br>\n让主机或路由器报告差错和异常情况&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[346,349]},&quot;v&quot;:&quot;ICMP报文作为IP层数据报的数据<br>\n加上数据报的首部<br>\n组成IP数据报发送出去&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[349,350]},&quot;v&quot;:&quot;网络层协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[350,351]},&quot;v&quot;:&quot;报文种类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[351,352]},&quot;v&quot;:&quot;差错报告报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[352,353]},&quot;v&quot;:&quot;询问报文&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[353,354]},&quot;v&quot;:&quot;5种常用类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[354,355]},&quot;v&quot;:&quot;终点不可达&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[355,356]},&quot;v&quot;:&quot;源点抑制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[356,357]},&quot;v&quot;:&quot;时间超过&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[357,358]},&quot;v&quot;:&quot;参数问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[358,359]},&quot;v&quot;:&quot;改变路由&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[359,360]},&quot;v&quot;:&quot;PING使用ICMP回答请求和回答报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[360,361]},&quot;v&quot;:&quot;Tracert使用ICMP时间超过报文&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[361,362]},&quot;v&quot;:&quot;IPV6&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[392,393]},&quot;v&quot;:&quot;路由协议&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[456,457]},&quot;v&quot;:&quot;IP组播&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[475,476]},&quot;v&quot;:&quot;移动IP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[494,495]},&quot;v&quot;:&quot;网络层设备&quot;}]}"></svg>
</div>

<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul>
<li>数据报服务<ul>
<li>简单灵活 </li>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>为了使路由器简单<br>  可靠通信由传输层负责<br>  传送分组可能<ul>
<li>出错</li>
<li>丢失</li>
<li>重复</li>
<li>失序</li>
<li>超时</li>
</ul>
</li>
</ul>
</li>
<li>异构网络互连<ul>
<li>各层中继系统<ul>
<li>物理层<ul>
<li>转发器</li>
<li>集线器</li>
</ul>
</li>
<li>数据链路层<ul>
<li>网桥</li>
<li>交换机</li>
</ul>
</li>
<li>网络层<ul>
<li><strong>路由器</strong></li>
</ul>
</li>
<li>网络层以上<ul>
<li>网关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>路由与转发<ul>
<li>路由选择（确定哪一条路径）<ul>
<li>按照分布式算法<br>  根据从各相邻的路由器<br>  所得的关于整个网络拓扑的变化情况<br>  动态改变选择的路由</li>
</ul>
</li>
<li>分组转发（一个分组到达时采取的动作）<ul>
<li>根据转发表<br>  将用户 IP 数据报<br>  从合适端口转发出去</li>
</ul>
</li>
</ul>
</li>
<li> SDN Software Define Network<ul>
<li> 网络层定义<ul>
<li>数据平面<ul>
<li>转发</li>
</ul>
</li>
<li>控制平面<ul>
<li>路由选择</li>
</ul>
</li>
</ul>
</li>
<li> SDN 网络<ul>
<li>数据、控制平面分离</li>
<li>数据平面<br>  - </li>
<li>控制平面<ul>
<li>集中式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>开环控制</li>
<li>闭环控制</li>
</ul>
</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><ul>
<li>静态路由算法<ul>
<li>非自适应路由算法</li>
<li>网络管理员手动配置</li>
<li>拓扑结构发生变化手动修改静态路由</li>
<li>小型网络</li>
</ul>
</li>
<li>动态路由算法<ul>
<li>自适应路由算法</li>
<li>互连的路由器间彼此交换路由表</li>
</ul>
</li>
<li>距离 - 向量算法<ul>
<li>所有节点定期<br>  将各自整个路由选择表<br>  转发到相邻节点<ul>
<li>每条路径的目的地</li>
<li>路径的代价（距离）</li>
<li>RIP 算法</li>
</ul>
</li>
</ul>
</li>
<li>链路状态路由算法<ul>
<li>每个参与算法的节点<br>  均具有完全的拓扑信息<ul>
<li>主动测试所有相邻节点</li>
<li>定期将链路状态传播所有其他节点</li>
</ul>
</li>
<li> OSPF 算法</li>
<li>洪泛法发送信息</li>
<li>所有路由器</li>
<li>路由器相邻的所有路由链路状态</li>
<li>度量 metric<ul>
<li> 费用</li>
<li>距离</li>
<li>时延</li>
<li>带宽</li>
</ul>
</li>
<li>链路状态变化才发送</li>
</ul>
</li>
<li>层次路由<ul>
<li>网络规模增大<br>  路由表增大</li>
<li>整个互联网划分<br>  划分为很多较小的自治系统</li>
<li>内部网关协议<ul>
<li> RIP</li>
<li>OSPF</li>
</ul>
</li>
<li> 外部网关协议<ul>
<li> BGP<h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2></li>
</ul>
</li>
</ul>
</li>
<li>IPV4 分组<ul>
<li>首部长度<ul>
<li>占 4 位</li>
<li>最大十进制数 15</li>
<li> 最大值 15 * 4B = 60B</li>
</ul>
</li>
<li> 总长度<ul>
<li>首部和数据之和</li>
<li>单位为字节</li>
<li>以太网帧的最大传送单元<br>  MTU=1500B</li>
<li> 最大长度 $2^{16}=65535B$</li>
<li> 标识 <ul>
<li>占 16 位</li>
<li>计数器 i++</li>
<li> 数据报长度超过网络 MTU<br>  必须分片<br>  此时每个数据报片<br>  均复制一次标识号</li>
</ul>
</li>
<li>标志<ul>
<li>占 3 位</li>
<li>标志字段最低位 MF<br>  MF=1 表示后面还有分片<br>  MF=0 表示最后一个分片</li>
<li>标志字段中间的一位 DF<br>  DF=0 时才允许分片</li>
</ul>
</li>
<li>片偏移<ul>
<li>占 13 位</li>
<li>较长的分组在分片后<br>  某片在原分组中相对位置</li>
<li>以 8 个字节为偏移单位</li>
<li>除最后一个分片<br>  每个分片的长度一定<br>  是 8B 的整数倍</li>
</ul>
</li>
<li>生存时间 TTL<ul>
<li> 占 8 位</li>
<li>数据报可通过路由数最大值</li>
<li>确保分组不会永远在网络中循环</li>
</ul>
</li>
<li>协议<ul>
<li>占 8 位</li>
<li> TCP : 6</li>
<li>UDP : 17</li>
</ul>
</li>
<li> 首部校验和<ul>
<li>占 16 位</li>
<li>只校验分组的首部</li>
<li>不校验数据部分</li>
</ul>
</li>
<li>源地址字段<ul>
<li>占 4B</li>
</ul>
</li>
<li> 目的地址字段<ul>
<li>占 4B</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> 数据报分片<ul>
<li>链路承载最大数据量<br>  最大传送单元 MTU</li>
<li>IP 数据报 4000B<br>  首部 20B 数据 3980B<br>  MTU=1500B 标识 = 777<br>  MF=0 DF=0<br>  <strong>分片大小为 8B 的倍数 = 1480</strong><ul>
<li> 分片 1<ul>
<li> 标识 = 777 </li>
<li>片偏移 = 0</li>
<li>MF=1 DF=0</li>
<li> 有效数据 1480B</li>
</ul>
</li>
<li> 分片 2<ul>
<li> 标识 = 777 </li>
<li>片偏移 = 185</li>
<li>MF=1 DF=0</li>
<li> 有效数据 1480B </li>
</ul>
</li>
<li>分片 3<ul>
<li> 标识 = 777 </li>
<li>片偏移 = 370</li>
<li>MF=0 DF=0</li>
<li> 有效数据 (3980-1480*2) B</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>IPV4 地址<ul>
<li> A 类<ul>
<li> 1 ~ 126</li>
<li><strong>0</strong>000,0000;0;0;0 ~<br>  <strong>0</strong>111,1111;1;1;1</li>
</ul>
</li>
<li>B 类<ul>
<li> 128 ~ 191</li>
<li><strong>10</strong>00,0000;0;0;0<br>  <strong>10</strong>11,1111;1;1</li>
</ul>
</li>
<li>C 类<ul>
<li> 192 ~ 223</li>
<li><strong>110</strong>0,0000;0;0;0 ~<br>  <strong>110</strong>1,1111;1;1;1</li>
</ul>
</li>
<li>D 类<ul>
<li> 224 ~ 239</li>
<li><strong>1110</strong>,0000;0;0;0 ~<br>  <strong>1110</strong>,1111;1;1;1</li>
</ul>
</li>
<li>E 类<ul>
<li> 240 ~ 255</li>
<li><strong>1111</strong>,0000;0;0;0 ~<br>  <strong>1111</strong>,1111;1;1;1</li>
</ul>
</li>
<li>IP::={&lt;网络号&gt;,&lt; 主机号 &gt;}<ul>
<li> 主机号全为 0 表示本网络</li>
<li>主机号全 1 表示本网络广播地址</li>
<li> 127.x.x.x 为环回自检地址</li>
<li>表示任意主机自身</li>
<li>目的地址为 127.x 的<br>  IP 数据报不会出现在任何网络</li>
<li> 32 位全为 0 表示本网络上本主机</li>
<li> 32 位全为 1 表示整个 TCP/IP 网络的广播地址</li>
<li> IP 地址使用范围<ul>
<li> A<ul>
<li> 最大网络可用数 =$2^{7}-2$</li>
<li> 第一个可用的网络号 = 1</li>
<li> 最后一个可用的网络号 = 126</li>
<li> 每个网络中最大的主机 =$2^{24}-2$</li>
</ul>
</li>
<li>B<ul>
<li> 最大网络可用数 =$2^{14}$</li>
<li> 第一个可用的网络号 = 128.0</li>
<li> 最后一个可用的网络号 = 191.255</li>
<li> 每个网络中最大的主机 =$2^{16}-2$</li>
</ul>
</li>
<li>C<ul>
<li> 最大网络可用数 =$2^{21}$</li>
<li> 第一个可用的网络号 = 192.0.0</li>
<li> 最后一个可用的网络号 = 223.255.255</li>
<li> 每个网络中最大的主机 =$2^{8}-2$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>NAT<ul>
<li> 专门网络地址转换为公用地址<br>  而对外隐藏内部管理的 IP</li>
<li> 划分私有 IP<ul>
<li> 只用于 LAN</li>
<li> 不用于 WAN</li>
<li> 私有 IP 不能直接接入 Internet</li>
<li> 通过网关利用 NAT</li>
<li> 私有 IP 转为 Internet 中合法的全球 IP</li>
<li> 网段<ul>
<li> A<ul>
<li>1 个 A 类</li>
<li> 10.0.0.0 ~ 10.255.255.255</li>
</ul>
</li>
<li>B<ul>
<li>16 个 B 类</li>
<li> 172.16.0.0 ~ 172.31.255.255</li>
</ul>
</li>
<li>C<ul>
<li>256 个 C 类</li>
<li> 192.168.0.0 ~ 192.168.255.255</li>
</ul>
</li>
</ul>
</li>
<li> 目的地址为私有 IP 不进行转发：本地互联网</li>
</ul>
</li>
<li> NAT 转换表<ul>
<li> WAN : LAN</li>
<li>138.76.29.7:5001 | 192.168.0.2:2233</li>
</ul>
</li>
<li> 普通路由器转发 IP 数据报，不改变源 IP 和目的 IP</li>
<li>NAT 路由器转发 IP 数据报，一定改变</li>
</ul>
</li>
<li>子网划分<ul>
<li>两级 IP<ul>
<li> 缺点<ul>
<li>地址空间利用率低</li>
<li>每分配一个网络号会是路由表变得太大</li>
<li>网络性能变坏</li>
<li>不够灵活</li>
</ul>
</li>
</ul>
</li>
<li>划分<ul>
<li>对内表现为子网划分，对外表现为没有划分的网络</li>
<li>从主机号借用若干比特作为子网号</li>
<li> IP = {&lt;网络号&gt;,&lt; 子网号 &gt;,&lt; 主机号 &gt;}</li>
<li> 从其他网络发送给本单位某主机的 IP<br>  仍然根据 IP 目的网络<br>  找到连接本单位网络的路由<br>  该路由收到 IP<br>  按目的网络和子网找到目的子网<br>  最后交付 IP 至目的主机</li>
<li>划分只根据主机号借用位作子网号<br>  不改变网络号<br>  从一个 IP 地址或首部无法判断是否子网划分</li>
</ul>
</li>
</ul>
</li>
<li>子网掩码<ul>
<li>表达对原网络主机号的借位</li>
<li>将 IP 与子网掩码按位相与 <em>AND</em></li>
<li> 得到相应的子网地址</li>
<li>要求<ul>
<li>主机设置 IP 地址必须设置子网掩码</li>
<li>同属一个子网的所有主机及路由器的相应端口必须设置相同的子网掩码</li>
<li>路由器的路由表所包含信息：目的网络地址、子网掩码、下一跳地址</li>
</ul>
</li>
</ul>
</li>
<li> CIDR<ul>
<li> 在变成子网掩码基础上消除 ABC 类网络划分</li>
<li>在软件下实现超网构成</li>
<li> IP = {&lt;网络前缀&gt;,&lt; 主机号 &gt;}</li>
<li> 斜线记法<ul>
<li> IP 地址 / 网络前缀所占比特数</li>
<li> 128.14.32.5/20<ul>
<li>IP:      1000,0000;0000,1110;0010,0000;0000,0101</li>
<li> 子网掩码: 1111,1111;1111,1111;1111,0000;0000,0000</li>
<li> 网络前缀: <em>1000,0000;0000,1110;0010</em>,0000;0000,0000<br>  128.14.32.0</li>
</ul>
</li>
</ul>
</li>
<li>CIDR 不使用子网，仍使用掩码</li>
<li> CIDR 地址块<ul>
<li>网络前缀相同的连续 IP 组成</li>
<li> 206.1.0.0/17<ul>
<li><em>1100,1010;0000,0001;0</em>000,0000;0000,0000</li>
</ul>
</li>
<li>206.1.128.0/17<ul>
<li><em>1100,1010;0000,0001;1</em>000,0000;0000,0000</li>
</ul>
</li>
<li>206.1.0.0/16<ul>
<li><em>1100,1010;0000,0001</em>;0000,0000;0000,0000</li>
</ul>
</li>
</ul>
</li>
<li> 最长前缀匹配（最佳匹配）<ul>
<li>路由表中的每个项目由 &lt;网络前缀&gt;&lt; 下一跳地址 &gt; 组成<br>  在查找路由表时可能不止一个匹配结果<br>  匹配结果中选择具有最长网络前缀的路由<br>  网络前缀越长<br>  地址块越小<br>  路由越具体</li>
</ul>
</li>
<li>网络层转发分组<ul>
<li>基于目的主机所在的网络<br>  网络数远小于主机数</li>
<li>分组到达路由器<br>  路由器根据目的 IP 地址的网络前缀查找转发表<pre><code>  确定下一跳应到哪个路由器
</code></pre></li>
<li>转发表中每条路由必须有下面两条信息<br>  (目的网络，下一跳地址)<br>  IP 数据报最终一定可以找到目的主机所在目的网络上的路由器<br>  达到最后一个路由器，向目的主机进行直接交付</li>
</ul>
</li>
</ul>
</li>
<li> ARP、DHCP、ICMP<ul>
<li>IP 地址与硬件地址<ul>
<li> IP 地址是网络层使用</li>
<li> MAC 地址是数据链路层使用</li>
<li>网络层及网络层之上使用 IP<br>  IP 地址放在 IP 数据报首部<br>  MAC 地址放在 MAC 帧首部<br>  数据封装后<br>  IP 数据报分组封装为 MAC 帧<br>  数据链路层看不见数据报分组中的 IP 地址</li>
<li>决定了 MAC 地址无法跨网络通信</li>
</ul>
</li>
<li> ARP Address Resolution Protocol<ul>
<li> 无论网络层使用什么协议<br>  在实际网络的链路上传输数据帧<br>  必须使用硬件地址</li>
<li>使用 ARP 进行映射</li>
<li>每台主机设有 ARP 映射表</li>
<li>工作原理<ul>
<li>主机 A 向本局域网上某台主机 B 发送 IP 数据报<br>  先在 ARP 高速缓存中查找有无主机 B 的 IP<br>  有则将对应 MAC 地址写入 MAC 帧<br>  无则通过目的 MAC 地址<br>  FFFF-FF-FF-FF-FF 的帧封装并广播 ARP 请求分组</li>
<li>主机 B 收到该 ARP 请求分组，向 ARP 响应分组（单播）<br>  分组包含 B 的 IP 与 MAC 地址的映射</li>
<li>主机 A 收到 ARP 响应分组<br>  写入 ARP 缓存<br>  按查询到的硬件地址发送 MAC 帧</li>
</ul>
</li>
</ul>
</li>
<li> DHCP Dynamic Host Configuration Protocol<ul>
<li> 动态分配地址</li>
<li>即插即用联网机制</li>
<li>应用层协议</li>
<li> UDP</li>
<li> 客户 / 服务器模式</li>
<li>工作原理<ul>
<li>需要 IP 地址的主机在启动时<br>  就向 DHCP 服务器广播发送发现报文<br>  主机成为 DHCP 客户</li>
<li> DHCP 客户只能在一段有限的时间内<br>  使用分配到的 IP 地址：租用期</li>
</ul>
</li>
</ul>
</li>
<li> ICMP Internet Control Message Protocol<ul>
<li> 提高 IP 数据报交付成功机会<br>  在网络层使用网际控制报文协议<br>  让主机或路由器报告差错和异常情况</li>
<li> ICMP 报文作为 IP 层数据报的数据<br>  加上数据报的首部<br>  组成 IP 数据报发送出去</li>
<li>网络层协议</li>
<li>报文种类<ul>
<li>差错报告报文</li>
<li>询问报文</li>
</ul>
</li>
<li> 5 种常用类型<ul>
<li>终点不可达</li>
<li>源点抑制</li>
<li>时间超过</li>
<li>参数问题</li>
<li>改变路由</li>
</ul>
</li>
<li> PING 使用 ICMP 回答请求和回答报文</li>
<li> Tracert 使用 ICMP 时间超过报文<h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2></li>
</ul>
</li>
<li> 特点<ul>
<li>解决 IP 地址耗尽问题</li>
<li>采用 CIDR、NAT</li>
<li>128 位</li>
<li>即插即用</li>
<li>只有在包的源结点才能分片</li>
<li>传输路径中的路由器不能分片</li>
<li>首部长度必须 8B 的整数倍</li>
</ul>
</li>
<li>地址<ul>
<li>目的地址<ul>
<li>单播<ul>
<li>点对点</li>
</ul>
</li>
<li>多播<ul>
<li>一对多</li>
</ul>
</li>
<li>任播<ul>
<li>目的站是一组计算机</li>
<li>数据报交付其中的一台计算机</li>
<li>距离最近的计算机</li>
</ul>
</li>
</ul>
</li>
<li>缩写表示法<ul>
<li> 4BF5:0000:0000:0000:BA5F:039A:000A:2176</li>
<li>4BF5:0:0:0:BA5F:39A:A:2176</li>
</ul>
</li>
<li> 双冒号缩写 [::]<ul>
<li>4BF5:0000:0000:0000:BA5F:039A:000A:2176</li>
<li>4BF5::BA5F:39A:A:2176</li>
</ul>
</li>
</ul>
</li>
<li> 双协议栈<ul>
<li>设备同时安装 IPV4 和 IPV6 协议栈</li>
<li>路由器不同接口配置</li>
</ul>
</li>
<li>隧道技术<ul>
<li> IPV6 数据报进入 IPV4 网络<br>  封装到 IPV4 数据报的数据部分<h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2></li>
</ul>
</li>
<li>自治系统 AS Autonomous System<ul>
<li> 本自治系统内必须连通</li>
</ul>
</li>
<li>域内路由与域间路由<ul>
<li>域内路由 RIP、OSPF</li>
<li> 域间路由 BGP</li>
</ul>
</li>
<li>RIP<ul>
<li> 基于距离 - 向量算法</li>
<li>简单</li>
<li>距离称为跳数，经过一个路由距离 + 1</li>
<li> 路由器维护自身到其他每个目的网络的距离记录</li>
<li>定义好的路由就是通过路由器数目少</li>
<li>一跳路径最多 15 跳</li>
<li>距离为 16 表示网络不可达<br>  为了防止出现环路</li>
<li>默认两个使用 RIP 的路由之间 30 秒广播一次 RIP 路由更新信息</li>
<li>仅和相邻路由器交换信息</li>
<li>交换自己的路由表（全部信息）</li>
<li>距离向量算法<ul>
<li>路由表项<ul>
<li> &lt;目的网络 N, 距离 d, 下一跳路由器地址&gt;</li>
</ul>
</li>
<li> 地址 X 的相邻路由器发来的 RIP 报文<br>  修改下一跳字段的地址改为 X<br>  距离向量 + 1</li>
<li> 原有路由表没有目的网络 N，加入</li>
<li>有目的网络 N，下一跳地址为 X，替换</li>
<li>有目的网络 N，下一跳地址不为 X<br>  发来的 d 小于路由表的 d，替换<br>  否则什么也不做</li>
</ul>
</li>
<li>限制了网络的规模</li>
<li>坏消息传得慢，收敛时间长</li>
<li>应用层协议</li>
<li> UDP 端口 520</li>
</ul>
</li>
<li>OSPF<ul>
<li> 分布式链路状态路由算法</li>
<li>洪泛法</li>
<li>向自治系统所有路由器发送信息</li>
<li>发送与本路由器相邻的所有路由器链路状态</li>
<li>只有链路发生变化，才发送</li>
<li>快收敛</li>
<li>网络层协议</li>
<li> IP 协议字段 89</li>
<li> 每个链路状态都带一个 32 位序号<br>  序号越大代表状态越新</li>
<li>使用 Dijkstra 算法计算最优路径</li>
<li> OSPF 五种分组<ul>
<li>问候</li>
<li>数据库描述</li>
<li>链路状态请求</li>
<li>链路状态更新</li>
<li>链路状态确认</li>
</ul>
</li>
</ul>
</li>
<li> BGP<ul>
<li> 基于路径 - 向量算法</li>
<li>寻找一条能够达到目的网络且比较好的路由<br>  不能有环路并非最佳路由</li>
<li>应用层协议</li>
<li>基于 TCP</li>
<li> 每个自治系统的管理员<br>  至少选择一个路由作为 BGP 发言人</li>
<li> BGP-4 使用 4 种报文<ul>
<li>打开</li>
<li>更新</li>
<li>保活</li>
<li>通知<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP 组播</h2></li>
</ul>
</li>
</ul>
</li>
<li>组播<ul>
<li>应用于 UDP</li>
<li> 有的应用程序把一个分组发送给多个目的主机</li>
<li> IPV4 的 D 类地址</li>
</ul>
</li>
<li> IP 组播地址<ul>
<li> D 类地址前 4 位：1110<ul>
<li>224.0.0.0 ~ 239.255.255.255</li>
</ul>
</li>
<li>D 类 IP 与以太网组播地址映射<ul>
<li> IP 组播地址 1110,<strong>xxxx;x</strong>yyy,yyyy;y;y<br>  xxxxx 不做映射</li>
<li> 48 位 MAC 地址后 23 位装载 IP 组播地址后 23 位</li>
</ul>
</li>
</ul>
</li>
<li> IGMP Internet Group Management Protocol<ul>
<li> 组播路由选择<ul>
<li>找出以源主机为根节点的组播转发树</li>
</ul>
</li>
<li>三种算法<ul>
<li>基于链路状态</li>
<li>基于距离 - 向量</li>
<li>建立在任何路由器协议，协议无关组播<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动 IP</h2></li>
</ul>
</li>
</ul>
</li>
<li> 概念<ul>
<li>以固定的网络 IP 地址实现跨越不同网段的漫游功能</li>
<li>并保证基于网络 IP 的网络权限在漫游过程不发生改变</li>
</ul>
</li>
<li>功能实体<ul>
<li>移动节点</li>
<li>本地代理</li>
<li>外地代理</li>
</ul>
</li>
<li>通信过程<ul>
<li>移动站在归属网络，按照 TCP/IP 通信</li>
<li>漫游到外地网络，向外地代理登记获得临时转交地址<br>  外地代理向移动站归属代理登记转交地址</li>
<li>归属代理登记转交地址后，构建一条通向转交地址的隧道<br>  并将截获的发送给移动站的 IP 分组进行封装<br>  通过隧道发送给被访问网络的外地代理</li>
<li>外地代理收到封装的数据报进行拆封<br>  恢复原始 IP 分组转发给移动站</li>
<li>移动站向外部发送数据报仍使用自己的永久地址作为源地址<br>  无需通过归属代理转发直接通过被访网络的外部代理<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2></li>
</ul>
</li>
<li>冲突域<ul>
<li>连接在同一物理介质上的所有节点集合</li>
<li>节点存在对介质的争用现象</li>
<li>集线器、中继器不能划分冲突域</li>
<li>网桥、交换机、路由器可以划分冲突域</li>
</ul>
</li>
<li>广播域<ul>
<li>接收同样广播消息的节点集合</li>
<li>路由器可以划分广播域</li>
<li> LAN 特指使用路由器分割的网络也就是广播域</li>
</ul>
</li>
<li>路由器组成和功能<ul>
<li>多输入 / 输出的专用计算机</li>
<li>连接不同的网络完成路由转发</li>
</ul>
</li>
<li>直接交付<ul>
<li>源主机和目标主机在同一个网络<br>  无需通过路由器</li>
</ul>
</li>
<li>间接交付<ul>
<li>源主机和目标主机不在同一个网络<br>  需要路由器按照转发表指出的路由<br>  将数据报转发给下一个路由器</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
