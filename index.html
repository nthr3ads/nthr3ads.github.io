<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-数据库·简述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%C2%B7%E7%AE%80%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.367Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据库DB"><a href="#数据库DB" class="headerlink" title="数据库DB"></a>数据库DB</h1><h2 id="一、数据库系统概论"><a href="#一、数据库系统概论" class="headerlink" title="一、数据库系统概论"></a>一、数据库系统概论</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>数据库的四个基本概念：数据、数据库、数据库管理系统、数据库系统  </p>
<ul>
<li>数据DATA：描述事物的符号记录，数据的含义称为数据的语义，数据与其语义不可分  </li>
<li>数据库DB：长期存储在计算机内、有组织的、可共享的大量数据的集合，数据库中的数据按一定数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性、易扩展性 </li>
<li>数据库管理系统DBMS：位于操作系统和用户之间的一层数据管理软件，包括：数据定义、组织、存储、管理、操纵；数据库的事务管理、运行管理、建立、维护；其他；</li>
<li>数据库系统DBS：由数据库、数据库管理系统、应用程序、数据库管理员DBA组成的存储、管理、处理和维护的系统<!--more--</li>
</ul>
<h4 id="数据库技术发展"><a href="#数据库技术发展" class="headerlink" title="数据库技术发展"></a>数据库技术发展</h4><p>人工管理阶段、文件系统阶段、数据库系统阶段</p>
<h4 id="数据库系统特点"><a href="#数据库系统特点" class="headerlink" title="数据库系统特点"></a>数据库系统特点</h4><ul>
<li>数据结构化：是与文件系统的本质区别</li>
<li>数据的共享性高、冗余度低且易扩充</li>
<li>数据独立性高</li>
<li>数据由数据库管理系统统一管理和控制：安全性保护、完整性保护、并发控制、数据库恢复</li>
</ul>
<h3 id="数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础"><a href="#数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础" class="headerlink" title="数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础"></a>数据模型：是对现实世界数据特征的抽象，是数据库系统的核心和基础</h3><h4 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h4><ul>
<li>第一类概念模型（信息模型）：按用户的观点对数据和信息建模，主要用于数据库设计——<em>面向用户</em></li>
<li>第二类逻辑模型：包括层次模型、网状模型、关系模型、面向对象模型、对象关系模型、半结构化模型；是按计算机系统的观点对数据建模——<em>面向设计人员</em></li>
<li>第二类物理模型：是对数据最底层的抽象，面向计算机系统</li>
</ul>
<h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li>实体：客观存在并且可相互区别的事物</li>
<li>属性：实体具有的某一特性  </li>
<li>码：唯一标识实体的属性集  </li>
<li>实体型：用实体名及属性名集合来抽象和刻画同类实体  </li>
<li>实体集：同一类型实体的集合  </li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系，一对一、一对多、多对多等类型</li>
</ul>
<h5 id="一种表示方法：实体-联系方法"><a href="#一种表示方法：实体-联系方法" class="headerlink" title="一种表示方法：实体-联系方法"></a>一种表示方法：实体-联系方法</h5><ul>
<li>E-R模型</li>
</ul>
<h4 id="组成要素：数据模型通常由数据结构、数据操作、数据的完整性约束条件组成"><a href="#组成要素：数据模型通常由数据结构、数据操作、数据的完整性约束条件组成" class="headerlink" title="组成要素：数据模型通常由数据结构、数据操作、数据的完整性约束条件组成"></a>组成要素：数据模型通常由<strong>数据结构</strong>、<strong>数据操作</strong>、<strong>数据的完整性约束条件</strong>组成</h4><ul>
<li>数据结构：描述数据库的组成对象以及对象之间的关系 </li>
<li>数据操作：对数据库中的各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则（SQL）</li>
<li>数据的完整性约束条件：是一组完整性规则，保证数据的正确、有效和相容，任何关系需满足实体完整性和参照完整性（DBMS自动完成，之外的由设计人员完成，用户自己的完整性也需设计人员完成）；在某个表中某一个属性不能重复且不能为空</li>
</ul>
<h4 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h4><ul>
<li>层次模型（非关系模型）</li>
<li>网状模型（非关系模型）</li>
<li>关系模型（表）</li>
<li>面向对象模型（对象）</li>
<li>对象关系模型</li>
<li>半结构化模型</li>
</ul>
<h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>早期的数据组织方式，IBM的IMS，在数据库中定义满足  </p>
<ul>
<li>有且只有一个结点没有双亲结点，这个结点叫根结点</li>
<li>根以外的其他结点有且只有一个双亲结点</li>
</ul>
<p>层次模型更像是一颗倒立的树</p>
<h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><ul>
<li>允许一个以上的结点无双亲  </li>
<li>一个结点可以有多于一个的双亲</li>
</ul>
<p>层次模型中子女结点与双亲结点的联系是唯一的，网状模型不唯一</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>IBM E.F.Codd</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>关系：一个关系对应一个表</li>
<li>元组：表中的一行</li>
<li>属性：表中的一列</li>
<li>码：表中某个属性组，可以唯一确定一个元组</li>
<li>域：一组有相同数据类型的集合</li>
<li>分量：元组的一个属性值</li>
<li>关系模式：关系的描述（关系名（属性1，属性2，…，属性n））</li>
</ul>
<p>要求关系必须规范化，每一个分量必须是一个不可分的数据项</p>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户-浏览器结构</li>
<li>浏览器-应用服务器、数据库服务器多层结构</li>
</ul>
<h4 id="系统模式的概念"><a href="#系统模式的概念" class="headerlink" title="系统模式的概念"></a>系统模式的概念</h4><p>在数据模型中有“型”和“值”的概念，型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值<br>模式是数据库中全体数据的逻辑结构和特征的描述，涉及型的描述，不涉及具体的值<br>模式是相对稳定的，而实例是相对变动的</p>
<h4 id="数据库系统的三级模式：外模式、模式、内模式"><a href="#数据库系统的三级模式：外模式、模式、内模式" class="headerlink" title="数据库系统的三级模式：外模式、模式、内模式"></a>数据库系统的三级模式：外模式、模式、内模式</h4><ul>
<li>模式：又称逻辑模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据试图，是与某一用户有关的数据的逻辑表示</li>
<li>外模式：通常是模式的子集，一个数据库可以有多个外模式，如果不同的用户在应用需求、看待的数据方式、对数据保密的要求等方面存在差异，则其外模式描述是不同的；同一模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式</li>
<li>内模式：又称存储模式或物理模式，一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</li>
</ul>
<h4 id="数据库二级映像功能与数据独立性"><a href="#数据库二级映像功能与数据独立性" class="headerlink" title="数据库二级映像功能与数据独立性"></a>数据库二级映像功能与数据独立性</h4><ul>
<li>外模式&#x2F;模式映像：模式描述的是数据全局逻辑结构，外模式描述的是数据的局部逻辑结构，对于每一个外模式，数据库系统都有一个外模式&#x2F;模式映像，定义了外模式与模式之间的对应关系，通常包含在各自的外模式描述中；当模式改变时，有数据库管理员对各个外模式&#x2F;模式的映像做相应改变，可使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li>
<li>模式&#x2F;内模式映像：数据库只有一个模式，也只有一个内模式，模式&#x2F;内模式是唯一的，定义了数据全局逻辑结构与存储结构之间的对应关系；当数据库的存储结构发生改变，由数据库管理员对模式&#x2F;内模式映像作相应改变，可使模式保持不变，从而应用程序不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性</li>
</ul>
<h4 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h4><ul>
<li>硬件平台&amp;数据库</li>
<li>软件</li>
<li>人员</li>
</ul>
<h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><p>《Communications of the ACM》E.F.Codd</p>
<h3 id="关系数据结构及形式化定义-单一的数据结构，在用户看来逻辑结构是一张二维表"><a href="#关系数据结构及形式化定义-单一的数据结构，在用户看来逻辑结构是一张二维表" class="headerlink" title="关系数据结构及形式化定义:单一的数据结构，在用户看来逻辑结构是一张二维表"></a>关系数据结构及形式化定义:单一的数据结构，在用户看来逻辑结构是一张二维表</h3><ul>
<li><p>域：一组具有相同数据结构的值的集合<br>$$<br>\begin{aligned}<br>&amp;D_1, D_2, \dots, D_n\<br>\end{aligned}<br>$$</p>
</li>
<li><p>笛卡尔积：域上的一种集合运算<br>$$<br>\begin{aligned}<br>&amp;D_1 * D_2 * \dots * D_n &#x3D; {(d_1, d_2, \dots, d_n)|d_i\in D_i, i &#x3D; 1, 2, \dots, n}\<br>&amp;每一个元素(d_1, d_2, \dots, d_n)叫做一个n元组\<br>&amp;元组每一个值d_i叫做一个分量\<br>&amp;基数：一个域允许的不同取值个数M&#x3D;\prod_{i&#x3D;1}^{n}{m_i}<br>\end{aligned}<br>$$</p>
</li>
<li><p>关系：<br>$$<br>\begin{aligned}<br>&amp;D_1 * D_2 * \dots * D_n的子集叫做在域D_1, D_2, \dots\<br>&amp;D_n上的关系，表示为R(D_1, D_2, \dots, D_n)\<br>&amp;R表示为关系的名字，n是关系的目或度\<br>&amp;n&#x3D;1，单元关系\<br>&amp;n&#x3D;2，二元关系\<br>&amp;某一个属性组的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码\<br>&amp;若一个关系有多个候选码，则选定一个为主码\<br>&amp;候选码的诸属性成为主属性，不包含在任何候选码中的属性成为非主属性或非码属性\<br>&amp;在最简单情况下，候选码只包含一个属性；在最极端情况下，关系模式的所有属性是这个关系模式的候选码，称为全码\<br>&amp;关系有三种类型：\<br>&amp;基本关系（基本表或基表）：实际存在的表，实际存储数据的逻辑表示；\<br>&amp;查询表：查询结果对应的表；\<br>&amp;视图表：基本表或其他视图表导出的表，虚表，不对应实际存储的数据\<br>&amp;关系是一个无限的集合，由于笛卡尔积的域不满足交换律\<br>&amp;(d_1, d_2, \dots, d_n) \neq (d_2, d_1, \dots, d_n)(i, j &#x3D;1, 2, \dots, n)\<br>&amp;对关系数据模型的限定和扩充：\<br>&amp;(1)无限关系在数据库系统中是无意义的，限定关系数据模型中的关系必须是有限集合\<br>&amp;(2)通过关系的每个列附加一个属性名的方法取消属性的有序性\<br>&amp;基本关系的性质：\<br>&amp;(1)列是同质的\<br>&amp;(2)不同列可出自同一个域\<br>&amp;(3)列顺序可无序\<br>&amp;(4)任意两个元组的候选码不能取同值\<br>&amp;(5)行的顺序可无序\<br>&amp;(6)分量必须取原子值\<br>&amp;这些规范中最基本的是每一个分量必须是一个不可分的数据项\<br>\end{aligned}<br>$$</p>
</li>
</ul>
<h3 id="关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系"><a href="#关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系" class="headerlink" title="关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系"></a>关系模式：必须指出这个元组集合的结构，即由哪些属性构成，属性来自哪些域，属性和域之间的映像关系</h3><p>$$<br>\begin{aligned}<br>&amp;关系模式：R(U, D, DOM, F)\<br>&amp;R：关系名\<br>&amp;D：U中属性所来自的域\<br>&amp;DOM：属性向域的映射集合\<br>&amp;F：属性间数据的依赖关系\<br>\end{aligned}<br>$$<br>关系模式是静态的、稳定的，而关系是的动态的、随时间变化的；</p>
<h3 id="关系数据库-有型和值的区分"><a href="#关系数据库-有型和值的区分" class="headerlink" title="关系数据库:有型和值的区分"></a>关系数据库:有型和值的区分</h3><ul>
<li>型：关系数据库模式，是对关系数据库的描述</li>
<li>值：关系模式在某一时刻对应的关系的集合</li>
</ul>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><h4 id="基本操作：查询、插入、删除、修改"><a href="#基本操作：查询、插入、删除、修改" class="headerlink" title="基本操作：查询、插入、删除、修改"></a>基本操作：查询、插入、删除、修改</h4><p>查询：选择、投影、连接、除、并、差、笛卡尔积；{选择、投影、并、差、笛卡尔积}是5种基本操作<br>关系操作的特点：集合操作方式，一次一集合操作；非关系模型的数据操作为一次一记录方式</p>
<h3 id="关系数据语言：关系代数、关系演算"><a href="#关系数据语言：关系代数、关系演算" class="headerlink" title="关系数据语言：关系代数、关系演算"></a>关系数据语言：关系代数、关系演算</h3><ul>
<li>关系代数：用对关系的运算来表达查询要求</li>
<li>关系演算：用谓词来表达查询要求，按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算</li>
</ul>
<p>SQL(Structured Query Language)是集查询、数据定义语言、数据操纵语言和数据控制语言DCL(Data Control Language)于一体的关系数据语言</p>
<ul>
<li>关系代数语言:ISBL</li>
<li>关系演算语言:元组关系演算语言：ALPHA、QUEL；域关系演算语言：QBE</li>
<li>关系代数&amp;关系演算-语言:<strong>SQL</strong></li>
</ul>
<h2 id="关系的完整性：是对关系的某种约束条件，有三类约束："><a href="#关系的完整性：是对关系的某种约束条件，有三类约束：" class="headerlink" title="关系的完整性：是对关系的某种约束条件，有三类约束："></a>关系的完整性：是对关系的某种约束条件，有三类约束：</h2><h3 id="实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证"><a href="#实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证" class="headerlink" title="实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证"></a>实体完整性：若属性A是基本关系R的主属性，则A不能取空值；关系数据库中每个元组是可区分的，是唯一的，这点用实体的完整性来保证</h3><p>实体完整性规则说明：<br>（1）实体完整性是针对基本关系而言，一个基本表对应现实世界的一个实体集<br>（2）现实世界中的实体是可区分的，即它们具有某种唯一标识<br>（3）关系模型中以主码作为唯一性标识<br>（4）主码中的属性即主属性不能取空值</p>
<h3 id="参照完整性：定义外码与主码之间的引用规则"><a href="#参照完整性：定义外码与主码之间的引用规则" class="headerlink" title="参照完整性：定义外码与主码之间的引用规则"></a>参照完整性：定义外码与主码之间的引用规则</h3><p>$$<br>\begin{aligned}<br>&amp;设F是基本关系R的一个或一组属性，但不是关系R的码，K_s是基本关系S的主码\<br>&amp;如果F与K_s相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系\<br>&amp;关系R和S不一定是不同的关系\<br>&amp;目标关系S的主码与K_s和参照关系R的外码F必须定义在同一个（同一组）\<br>\end{aligned}<br>$$</p>
<p>参照完整性规则<br>$$<br>\begin{aligned}<br>&amp;若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码K_s相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须\<br>&amp;取空值 \space 等于S中某个元组的主码值  \space空值  \space非空值\<br>\end{aligned}<br>$$</p>
<h3 id="用户定义的完整：与现实语义相结合"><a href="#用户定义的完整：与现实语义相结合" class="headerlink" title="用户定义的完整：与现实语义相结合"></a>用户定义的完整：与现实语义相结合</h3><h3 id="关系代数：抽象的查询语言，使用对关系的运算来表达查询-运算对象、运算符、运算结果-；按运算符分为传统的集合运算和专门的关系运算"><a href="#关系代数：抽象的查询语言，使用对关系的运算来表达查询-运算对象、运算符、运算结果-；按运算符分为传统的集合运算和专门的关系运算" class="headerlink" title="关系代数：抽象的查询语言，使用对关系的运算来表达查询[运算对象、运算符、运算结果]；按运算符分为传统的集合运算和专门的关系运算"></a>关系代数：抽象的查询语言，使用对关系的运算来表达查询[运算对象、运算符、运算结果]；按运算符分为传统的集合运算和专门的关系运算</h3><h4 id="传统的集合运算（二目运算）：并、差、交、笛卡尔积"><a href="#传统的集合运算（二目运算）：并、差、交、笛卡尔积" class="headerlink" title="传统的集合运算（二目运算）：并、差、交、笛卡尔积"></a>传统的集合运算（二目运算）：并、差、交、笛卡尔积</h4><p>$$<br>\begin{aligned}<br>&amp;设关系R和S具有相同的目n（即两个关系都有的n个属性）\<br>&amp;具有相应的属性取自同一个域，t是元组变量，t\in R表示t是R的一个元组\<br>&amp;（1）并\<br>&amp;R \cup S &#x3D; { t | t\in R \vee t\in S}\<br>&amp;（2）差\<br>&amp;R - S &#x3D; { t | t\in R \wedge t\notin S}\<br>&amp;（3）交\<br>&amp;R \cap S &#x3D; { t | t\in R \wedge t\in S}\<br>&amp;（4）广义笛卡尔积\<br>&amp;R \times S &#x3D; { \widehat{t_r t_s}  | t_r\in R \wedge t_S\in S}\<br>\end{aligned}<br>$$<br>$\large{R}$:</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>$a_1$</td>
<td>$b_1$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$\large{S}$:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_3$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$\large{R\cup S}$:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_1$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_3$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$\large{R\cap S}$:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$\large{R\times S}$:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>R.A</td>
<td>R.B</td>
<td>R.C</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_1$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_1$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_1$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_1$</td>
<td>$b_2$</td>
<td>$c_2$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
<tr>
<td>$a_2$</td>
<td>$b_2$</td>
<td>$c_1$</td>
</tr>
</tbody></table>
<h4 id="专门的关系运算：选择、投影、连接、除运算"><a href="#专门的关系运算：选择、投影、连接、除运算" class="headerlink" title="专门的关系运算：选择、投影、连接、除运算"></a>专门的关系运算：选择、投影、连接、除运算</h4><p>（1）设关系模式为R($A_1$,$A_2$,$\dots$,$A_n$)，它的一个关系为R<br>    $t\in R$表示t是R的一个元组<br>    t$[A_i]$表示元组中相应的属性$A_i$的一个分量<br>（2）若$A&#x3D;{A_{i1}, A_{i2}, \dots, A_{ik}}$ ，其中$A_{i1}, A_{i2}, \dots, A_{ik}$是$A_1, A_2, \dots, A_n$中的一部分，则$A$称为属性列或属性组<br>    $t[A]&#x3D;(t[A_{i1}], t[A_{i2}], \dots, t[A_{ik}])$表示元组$t$在属性列$A$上诸多分量的集合<br>    $\overline{A}$则表示$A&#x3D;{A_{1}, A_{2}, \dots, A_{n}}$中去掉$A&#x3D;{A_{i1}, A_{i2}, \dots, A_{ik}}$后剩余的属性组<br>（3）$R$为$n$目关系，$S$为$m$目关系，$t_r\in R, t_s \in S$，$\widehat{t_r t_s}$ 为元组的连接（串接）<br>    是一个$n+m$的元组<br>（4）给定一个关系$R(X,Z)$，$X$和$Z$为属性组<br>    $t[X]&#x3D;x$，$x$在$R$中的象集：$Z_x&#x3D;{t[Z]|t\in R, t[X]&#x3D;x}$<br>    表示R中属性组X上的值为x的诸多元组在Z上的分量集合<br>$\large{R}$</p>
<table>
<thead>
<tr>
<th>$x$</th>
<th>$Z$</th>
</tr>
</thead>
<tbody><tr>
<td>$x_1$</td>
<td>$Z_1$</td>
</tr>
<tr>
<td>$x_1$</td>
<td>$Z_2$</td>
</tr>
<tr>
<td>$x_1$</td>
<td>$Z_3$</td>
</tr>
<tr>
<td>$x_2$</td>
<td>$Z_2$</td>
</tr>
<tr>
<td>$x_2$</td>
<td>$Z_3$</td>
</tr>
<tr>
<td>$x_3$</td>
<td>$Z_1$</td>
</tr>
<tr>
<td>$x_3$</td>
<td>$Z_3$</td>
</tr>
</tbody></table>
<p>$x_1$在$R$中的象集$Z_{x_1}&#x3D;{Z_1, Z_2, Z_3}$<br>$x_2$在$R$中的象集$Z_{x_2}&#x3D;{Z_2, Z_3}$<br>$x_3$在$R$中的象集$Z_{x_3}&#x3D;{Z_1, Z_3}$</p>
<p>（1）选择（限制）：在关系$R$中选择满足条件的诸多元组<br>$\sigma_{F}(R)&#x3D;{t|t\in R \cap F(t)&#x3D;’True’}$  $F(t)&#x3D;X_1 \theta Y_1$  $\theta$:比较远算符<br>（2）投影：关系$R$选择出若干属性列组成新的关系<br>$\prod_A(R)&#x3D;{t[A|t \in R}$  $A$是$R$的属性列<br>投影之后不仅取消原关系中的某些列，而且还可能取消某些组</p>
<p>查询关系Student在所在属性上的投影$\large{\prod_{Sdept}(Stud)}$</p>
<p>$\LARGE{b &#x3D; \prod_{Sdept}(a)}$</p>
<p>$\LARGE{a}$</p>
<table>
<thead>
<tr>
<th>Sname</th>
<th>Sdept</th>
</tr>
</thead>
<tbody><tr>
<td>Nick</td>
<td>CS</td>
</tr>
<tr>
<td>Cay</td>
<td>CS</td>
</tr>
<tr>
<td>John</td>
<td>MA</td>
</tr>
<tr>
<td>West</td>
<td>IS</td>
</tr>
</tbody></table>
<p>$\LARGE{b}$</p>
<table>
<thead>
<tr>
<th>Sdept</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>–</td>
</tr>
<tr>
<td>MA</td>
<td>–</td>
</tr>
<tr>
<td>IS</td>
<td>–</td>
</tr>
</tbody></table>
<p>（3）连接（$\theta$连接）：从两个关系的笛卡尔积中选取属性间满足一定条件的元组<br>$R\mathop{\bowtie}\limits_{A \theta B} S &#x3D;{\widehat{t_r t_s}|t_r \in R \cap t_s \in S \cap t_r[A] \theta t_s[B]}$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%C2%B7%E7%AE%80%E8%BF%B0/" data-id="clmdavay300044w8kapxfa55u" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构·栈和队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.352Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li>栈(Stack)：只允许在一端插入或删除的线性表</li>
<li>栈顶：线性表允许进行插入或删除的那一端</li>
<li>栈底：固定的，不允许进行插入和删除的另一端</li>
<li>特点：是受限的线性表，拥有线性关系；后进先出<strong>LIFO</strong></li>
</ul>
<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><ul>
<li>使用顺序存储，自底向上存储数据元素，指针指向栈顶元素的位置</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.top = <span class="number">-1</span>;             <span class="comment">//判空</span></span><br><span class="line">s.data[++s.top] = x;    <span class="comment">//进栈</span></span><br><span class="line">x = s.data[s.top--];    <span class="comment">//出栈</span></span><br><span class="line">x = s.data[s.top];      <span class="comment">//读取栈顶元素</span></span><br></pre></td></tr></table></figure>

<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><ul>
<li>两个栈共享一个一维数组空间</li>
<li>两个栈分别设置在共享空间两端</li>
<li>栈顶指向中间延伸位置</li>
<li>有利于空间使用</li>
</ul>
<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><ul>
<li>采用链式存储</li>
<li>便于多个栈共享存储空间</li>
<li>效率高</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li>允许在一端插入，另一端删除的线性表</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>先进先出<strong>FIFO</strong></li>
</ul>
<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><ul>
<li>连续的存储单元</li>
<li>头指针指向队头元素</li>
<li>尾指针指向队尾元素</li>
</ul>
<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><ul>
<li>首尾相连的顺序存储的队列</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q.rear = Q.front = <span class="number">0</span>;                           <span class="comment">// 初始化</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % MaxSize;                    <span class="comment">// 入队</span></span><br><span class="line">front = (front + <span class="number">1</span>) % MaxSize;                  <span class="comment">// 出队</span></span><br><span class="line">queueLen = (rear + MaxSize - front) % MaxSize;  <span class="comment">// 队列长度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断空队列或满队列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个单元区分队空或队满</span></span><br><span class="line">(Q.rear + <span class="number">1</span>) % MaxSize = Q.front;   <span class="comment">//</span></span><br><span class="line">Q.front = Q.rear;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 类型中增加表示个数的数据成员</span></span><br><span class="line">Q.size = <span class="number">0</span>;                         <span class="comment">//</span></span><br><span class="line">Q.size = MaxSize;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 增加tag成员</span></span><br><span class="line">tag = <span class="number">0</span>;                            <span class="comment">//</span></span><br><span class="line">tag = <span class="number">1</span>;                            <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><ul>
<li>允许两端可以入队和出队</li>
<li>输出受限的双端队列：允许一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="栈在括号匹配的应用"><a href="#栈在括号匹配的应用" class="headerlink" title="栈在括号匹配的应用"></a>栈在括号匹配的应用</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>空栈，一次读入一个符号</li>
<li>右括号：使栈顶元素消解，或不合法（序列不匹配，退出程序）</li>
<li>左括号：放入栈顶，作为更高优先级的一个元素，栈为空，否则括号序列不匹配</li>
</ul>
<h3 id="栈在表达式中的应用"><a href="#栈在表达式中的应用" class="headerlink" title="栈在表达式中的应用"></a>栈在表达式中的应用</h3><ul>
<li>中缀表达式转换后缀表达式</li>
</ul>
<h3 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h3><ul>
<li>原理：将原始问题转换为相同属性的小规模问题</li>
<li>求出递归表达式</li>
<li>边界条件（递归出口）</li>
</ul>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><h3 id="队列在层次遍历的应用"><a href="#队列在层次遍历的应用" class="headerlink" title="队列在层次遍历的应用"></a>队列在层次遍历的应用</h3><h3 id="队列在计算机系统中的应用"><a href="#队列在计算机系统中的应用" class="headerlink" title="队列在计算机系统中的应用"></a>队列在计算机系统中的应用</h3><ul>
<li>解决主机与外设之间速度不匹配的问题</li>
<li>解决多用户引起的资源竞争问题</li>
</ul>
<h1 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h1><h2 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h2><ul>
<li>行优先：先存储行号较小的元素，行号相等先存储列号小的元素</li>
<li>列优先：先存储列好较小的元素，列号相等先存储行号小的元素</li>
</ul>
<h2 id="n阶对称矩阵"><a href="#n阶对称矩阵" class="headerlink" title="n阶对称矩阵"></a>n阶对称矩阵</h2><ul>
<li>上三角、主对角线、下三角，其中上下三角元素相同</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k$</li>
<li>元素下标之间的对于关系<br>$i \ge j , k &#x3D; \frac{i*(i-1)}{2+j}-1(下三角区和主对角线元素)$<br>$i &lt; j , k &#x3D; \frac{j*(j-1)}{2+i}-1(上三角区元素)$</li>
</ul>
<h2 id="n阶三角矩阵"><a href="#n阶三角矩阵" class="headerlink" title="n阶三角矩阵"></a>n阶三角矩阵</h2><ul>
<li>下三角矩阵（上三角区元素为常量）和上三角矩阵（下三角矩阵元素为常量）</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k</li>
<li>下三角矩阵的的元素下表之间的对应关系</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" data-id="clmdavay800074w8k7jd1avhh" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构·线性表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.336Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、逻辑结构和基本操作"><a href="#一、逻辑结构和基本操作" class="headerlink" title="一、逻辑结构和基本操作"></a>一、逻辑结构和基本操作</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1. 逻辑结构"></a>1. 逻辑结构</h3><ul>
<li>具有相同数据类型的n个数据元素的有限序列，表长n，n&#x3D;0为空表</li>
<li>表头：第一个元素</li>
<li>表尾：最后一个元素</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>
<li>除最后一个元素外，每个元素有且仅有一个直接后继</li>
</ul>
<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initList</span>(&amp;L);</span><br><span class="line"><span class="built_in">len</span>(L);</span><br><span class="line"><span class="built_in">locateElem</span>(L, i);</span><br><span class="line"><span class="built_in">getElem</span>(L, i);</span><br><span class="line"><span class="built_in">listInsert</span>(&amp;L, i, e);</span><br><span class="line"><span class="built_in">listDelete</span>(&amp;L, i, &amp;e);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"><span class="built_in">isEmptyList</span>(L);</span><br><span class="line"><span class="built_in">destroyList</span>(&amp;L);</span><br></pre></td></tr></table></figure>

<h2 id="二、顺序存储结构"><a href="#二、顺序存储结构" class="headerlink" title="二、顺序存储结构"></a>二、顺序存储结构</h2><h3 id="1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻"><a href="#1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻" class="headerlink" title="1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻"></a>1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻</h3><ul>
<li>存储空间的起始位置data[ ]</li>
<li>顺序表最大存储容量MaxSize</li>
<li>顺序表当前最大长度len<br>特点</li>
<li>随机访存，O(1)时间复杂度访问</li>
<li>存储密度高，每个结点只存储数据元素</li>
<li>无需花费空间建立数据之间的逻辑关系，由物理位置相邻特性决定</li>
<li>逻辑上物理上均相邻，插入删除操作需要移动大量元素</li>
</ul>
<h3 id="2-基本操作-1"><a href="#2-基本操作-1" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3><p>（1）插入元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.len = MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = L.len; j  i; j--)</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">	L.len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>最好情况：在表尾插入 **(i&#x3D;n+1)**，不需要移动元素，时间复杂度为O(1)  </li>
<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>
<li>平均情况：假设$P_i$ **($P_i &#x3D; \frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n}{2}$，其时间复杂度为O(n)<br>（2）删除元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	e = L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.len; j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">	L.len--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
分析</li>
<li>最好情况：在表尾插入 **(i&#x3D;n)**，不需要移动元素，时间复杂度为O(1)  </li>
<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>
<li>平均情况：假设$P_i$ **($P_i &#x3D; \frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n-1}{2}$，其时间复杂度为O(n)<br>（3）查找元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList &amp;L, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.len; i++)</span><br><span class="line">		<span class="keyword">if</span>(e == L.data[i])</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
分析</li>
<li>最好情况：查找的元素在表头，仅需比较1次，时间复杂度O(1)</li>
<li>最坏情况：查找的元素在表尾或不存在，需要比较n次，时间复杂度O(n)  </li>
<li>平均情况：假设$P_i$ **($P_i &#x3D; \frac{1}{n}$)**是在第i个位置上结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n+1}{2}$，其时间复杂度为O(n)</li>
</ul>
<h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><h2 id="1-创建单链表"><a href="#1-创建单链表" class="headerlink" title="1.创建单链表"></a>1.创建单链表</h2><h3 id="（1）头插法"><a href="#（1）头插法" class="headerlink" title="（1）头插法"></a>（1）头插法</h3><ul>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表头(头结点位置)</li>
<li>链表结点的次序与输入的顺序相反</li>
</ul>
<h3 id="（2）尾插法"><a href="#（2）尾插法" class="headerlink" title="（2）尾插法"></a>（2）尾插法</h3><ul>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表尾(尾结点位置)</li>
<li>链表中的结点顺序与输入顺序一致</li>
</ul>
<h2 id="2-按值查找结点"><a href="#2-按值查找结点" class="headerlink" title="2.按值查找结点"></a>2.按值查找结点</h2><ul>
<li>在链表中从第一个结点出发，顺指针next逐个向下搜索，直到找到第i个结点，否则返回最后一个结点的指针域NULL</li>
</ul>
<h2 id="3-按序号查找结点"><a href="#3-按序号查找结点" class="headerlink" title="3.按序号查找结点"></a>3.按序号查找结点</h2><ul>
<li>从链表第一个结点开始，由前往后按照序号递增定位到相应结点的位置，返回该值，需检查序号是否越界</li>
</ul>
<h2 id="4-插入"><a href="#4-插入" class="headerlink" title="4.插入"></a>4.插入</h2><ul>
<li>插入操作是将值为x的新结点插入到单链表的第i个位置</li>
<li>先检查插入位置是否合法</li>
<li>找到待插入位置的前驱结点</li>
<li>在其后将结点插入<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">s-next = p-next;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h2><ul>
<li>将单链表的第i个结点删除</li>
<li>先检查插入位置是否合法</li>
<li>找到待删除位置的前驱结点</li>
<li>删除其后结点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">q = p-next;</span><br><span class="line">q-next = p-next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><ul>
<li>双链表有两个指针prior和next，分别指向前驱和后继结点</li>
<li>插入操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-next = p-next;</span><br><span class="line">p-next-prior = s;</span><br><span class="line">s-prior = p;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></table></figure></li>
<li>删除操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-next = q-next;</span><br><span class="line">q-next-prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><ul>
<li>循环双链表和循环单链表</li>
<li>静态链表使用数组来描述线性表的链式存储结构</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%BA%BF%E6%80%A7%E8%A1%A8/" data-id="clmdavayb00094w8k0im46p63" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构·简述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%80%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.320Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="一、数据结构：相互存在一种或多种特定关系的集合"><a href="#一、数据结构：相互存在一种或多种特定关系的集合" class="headerlink" title="一、数据结构：相互存在一种或多种特定关系的集合"></a>一、数据结构：相互存在一种或多种特定关系的集合</h2><ul>
<li>结构：任何问题，数据元素不孤立存在，之间存在关系  </li>
<li>逻辑结构</li>
<li>存储结构（物理结构）</li>
<li>数据的运算</li>
<li>逻辑结构和存储结构密不可分</li>
<li>算法设计取决于逻辑结构，实现依赖存储结构</li>
</ul>
<h2 id="二、逻辑结构：数据元素之间的逻辑关系"><a href="#二、逻辑结构：数据元素之间的逻辑关系" class="headerlink" title="二、逻辑结构：数据元素之间的逻辑关系"></a>二、逻辑结构：数据元素之间的逻辑关系</h2><ul>
<li>与存储无关，独立于计算机</li>
<li>分为线性结构和非线性结构<br>线性结构：线性表、栈、队列、串、数组、广义表<br>非线性结构：树、二叉树、有向图、无向图</li>
</ul>
<h2 id="三、存储结构（物理结构）：数据结构在计算机中的映像"><a href="#三、存储结构（物理结构）：数据结构在计算机中的映像" class="headerlink" title="三、存储结构（物理结构）：数据结构在计算机中的映像"></a>三、存储结构（物理结构）：数据结构在计算机中的映像</h2><ul>
<li>数据结构的表示</li>
<li>关系的表示</li>
<li>依赖于计算机语言</li>
<li>分为顺序存储、链式存储、索引存储、散列存储</li>
</ul>
<h3 id="1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻"><a href="#1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻" class="headerlink" title="1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻"></a>1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻</h3><ul>
<li>优：实现随机存取、每个元素占用的内存少</li>
<li>缺：只能使用相邻的一块存储单元，产生较多的外部碎片</li>
</ul>
<h3 id="2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素"><a href="#2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素" class="headerlink" title="2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素"></a>2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素</h3><ul>
<li>优：无碎片产生、充分利用存储单元</li>
<li>缺：只能顺序存储</li>
</ul>
<h3 id="3-索引存储：类似目录"><a href="#3-索引存储：类似目录" class="headerlink" title="3. 索引存储：类似目录"></a>3. 索引存储：类似目录</h3><h3 id="4-散列存储：通过关键字直接计算出元素的物理地址"><a href="#4-散列存储：通过关键字直接计算出元素的物理地址" class="headerlink" title="4. 散列存储：通过关键字直接计算出元素的物理地址"></a>4. 散列存储：通过关键字直接计算出元素的物理地址</h3><h2 id="四、数据运算"><a href="#四、数据运算" class="headerlink" title="四、数据运算"></a>四、数据运算</h2><h2 id="五、算法的五个特征"><a href="#五、算法的五个特征" class="headerlink" title="五、算法的五个特征"></a>五、算法的五个特征</h2><ul>
<li>有穷性：执行有限步后结束</li>
<li>确定性：每条指令都有确定的含义，相同输入得到相同的输出</li>
<li>可行性：通过实现的基本运算执行有限次得到确定的结果</li>
<li>输入：有零或多个输入</li>
<li>输出：一个或多个程序输出结果</li>
</ul>
<h2 id="六、算法的复杂度"><a href="#六、算法的复杂度" class="headerlink" title="六、算法的复杂度"></a>六、算法的复杂度</h2><h3 id="1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢"><a href="#1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢" class="headerlink" title="1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢"></a>1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢</h3><h3 id="2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢"><a href="#2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢" class="headerlink" title="2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢"></a>2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%80%E8%BF%B0/" data-id="clmdavaya00084w8kfge8a5t5" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构·基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.304Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> Data Structure Notes</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Author : <span class="string">&quot;ebxeax&quot;</span></span><br><span class="line">Version : <span class="number">1.0</span></span><br><span class="line">Refresh Date <span class="number">2020.11</span><span class="number">.26</span></span><br><span class="line">Description : </span><br><span class="line">Just record <span class="keyword">and</span> review some points about Data Structure.</span><br><span class="line">Have mistakes that please correct it yourself.</span><br></pre></td></tr></table></figure>

<p> 数据结构的基本概念</p>
<p>  1.数据</p>
<p>  2.数据元素：</p>
<p>   数据的基本单位，一个数据元素可有若干个数据项构成，数据项是不可分割的最小单位</p>
<p>  3.数据类型</p>
<p>  4.抽象数据类型(ADT[Abstract Data Type]):</p>
<p>  数学模型在计算机的一种实现，包括数据对象、数据关系、基本操作，如建立一个有限状态机模型</p>
<p>  5.数据结构：数据元素之间的关系称之为结构，数据结构包括三方面：逻辑结构、存储结构、数据运算(程序&#x3D;算法+数据结构)</p>
<p>  6.逻辑结构：数据间的逻辑关系，与数据存储独立，分为线性结构和非线性结构</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">逻辑结构--线性结构</span><br><span class="line">逻辑结构--非线性结构</span><br><span class="line">线性结构--一般线性表</span><br><span class="line">线性结构--受限线性表</span><br><span class="line">线性结构--线性表推广</span><br><span class="line">受限线性表--栈和队列</span><br><span class="line">受限线性表--串</span><br><span class="line">线性表推广--数组</span><br><span class="line">线性表推广--广义表</span><br><span class="line">非线性结构--非线性表</span><br><span class="line">非线性表--集合</span><br><span class="line">非线性表--树形结构</span><br><span class="line">非线性表--图形结构</span><br><span class="line">树形结构--一般树</span><br><span class="line">树形结构--二叉树</span><br><span class="line">图形结构--有向图</span><br><span class="line">图形结构--无向图</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  7.物理结构：数据元素的表示以及关系的表示，主要有：顺序存储、链式存储、索引存储、散列存储</p>
<p>  8.算法评估</p>
<p>  （1）特性：有穷、确定、可行、输入、输出</p>
<p>  （2）时间复杂度：衡量算法随问题规模的增大，算法执行的时间增长的快慢</p>
<p>   T(n)&#x3D;O(f(n))，f(n)为算法运算频度，一般采用最坏情况下的时间复杂度</p>
<p>   计算方法：取算法时间增长最快的函数项，忽略其系数</p>
<p>   a加法规则：</p>
<pre><code>$$
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
$$

多项式相加，只保留最高阶的项，且系数变为1
</code></pre>
<p>   b乘法规则：</p>
<pre><code>$$
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
$$

多项式相乘，都保留
</code></pre>
<p>   从左到右性能依次降低：</p>
<pre><code>$$
O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)
$$
</code></pre>
<p>   单循环体型：</p>
<pre><code>例题1：计算下列程序的时间复杂度

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,sum	<span class="comment">//执行1次</span></span><br><span class="line">sum=<span class="number">0</span>	<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//int i=0执行1次，i&lt;=n执行n+2次，i++执行n+1次</span></span><br><span class="line">	sum+=i;	<span class="comment">//执行n+1次</span></span><br></pre></td></tr></table></figure>

时间分析： 该算法执行了3n+6个语句。 假设每个语句执行时间一致，均为常数t。则总时间 
$$
T=(3n+6)*t
$$
随着问题规模n的增大，总时间的增长率与n的增长率一致，所以复杂度为
$$
O(n)
$$


结论： 

 复杂度是关于增长率的，所以可以直接忽视常数项

  一般可以直接关注循环段基本操作语句

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=i;</span><br></pre></td></tr></table></figure>
 
  

 的执行次数
</code></pre>
<p>   例题2：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum,i;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= n;i=<span class="number">2</span>*i)&#123;</span><br><span class="line">	sum=sum+i;</span><br></pre></td></tr></table></figure>
<p>   时间分析：</p>
<p>   i 取值：1,2,4,8…<br>   满足条件：2^𝑘 ≤ n<br>   K𝑙𝑜𝑔_2𝑛时， 跳出循环<br>   所以循环体执行次数：⌈𝑙𝑜𝑔_2𝑛⌉ 故时间复杂度为O(logn).i 取值：1,2,4,8</p>
<p>  多循环体型</p>
<p>  两个运算法则：乘法规则（嵌套循环）、加法规则（若干循环）</p>
<p>  例题3：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	x++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		y++;</span><br></pre></td></tr></table></figure>
<p>  两个循环体是独立的，采用加法规则：<br>  $$<br>  T(n)&#x3D;T_1(n)+T_2(n)<br>  $$</p>
<p>  $$<br>  &#x3D;max(T_1(n),T_2(n)) &#x3D;O(n^2)<br>  $$</p>
<p>  例题4：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j,sum;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j=<span class="number">2</span>*j)</span><br><span class="line">		sum=sum+j;</span><br></pre></td></tr></table></figure>
<p>  两个循环体是嵌套的，采用乘法规则：</p>
<p>  $$<br>  T(n)&#x3D;T_1(n)*T_2(n)<br>  $$</p>
<p>  $$<br>  &#x3D;O(nlogn)<br>  $$</p>
<p>  （3）空间复杂度：衡量算法随问题规模的增大，算法所需空间的快慢</p>
<p>   S(n)&#x3D;O(g(n))，算法所需空间的增长率和g(n)的增长率相同</p>
<p>   空间复杂度S(n)指算法运行过程中所使用的辅助空间的大小</p>
<p>线性表</p>
<p> 1.定义：线性表是具有相同数据类型的n个数据类型的有限序列，n为表长</p>
<p> 线性表中第一个元素称为表头元素，最后一个元素称为表位元素</p>
<p> 除第一个元素外，每个元素仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继</p>
<p>顺序存储</p>
<p>线性表的顺序存储又称顺序表</p>
<p>使用一组地址连续的存储单元(数组等)依次存储线性表的数据元素，从而使得逻辑相邻的两个元素在物理位置上也相邻</p>
<p>三个属性：</p>
<p> 1.存储空间的起始位置</p>
<p> 2.顺序表最大存储容量</p>
<p> 3.顺序表当前的长度</p>
<p>宏定义</p>
<p>静态分配大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Elemtype elem[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>动态分配大小(这里动态指空间大小运行时决定，但分配大小后，空间大小被固定)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Elemtype *elem;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>优点：访问效率高、存储密度高</p>
<p>缺点：插入删除操作复杂</p>
<p>顺序存储线性表操作</p>
<p>1.初始化顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initLinklist</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	L.elem=<span class="keyword">new</span> Elemtype[MaxSize];</span><br><span class="line"><span class="keyword">if</span>(!L.elem)</span><br><span class="line">   <span class="built_in">exit</span>(OVERFLOWS);</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）创建一个顺序存储表后，需要初始化，首先根据数组大小通过new在堆空间开辟一段连续的空间赋值于先前创建的顺序存储表的elem空间</p>
<p>（2）检查elem是否存在，不存在溢出退出程序</p>
<p>（3）将length元素赋值为0，即设置顺序存储线性表长度为0</p>
<p>2.销毁顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.elem)</span><br><span class="line">   <span class="built_in">delete</span>(L.elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果线性表存在，删除线性表elem开辟的空间</p>
<p>3.清空顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将线性表的长度置为0</p>
<p>4.判断顺序存储线性表是否为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断线性表长度是否为0，并返回相应bool值</p>
<p>5.引用类型按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i,type&amp;e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> e=L.elem[i<span class="number">-1</span>];</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）通过访问elem内数据存入引用类型变量内</p>
<p>6.按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> <span class="keyword">return</span> L.elem[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）通过访问elem内数据并返回</p>
<p>7.引用类型按值查询顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e,<span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量赋值于引用类型下标变量</p>
<p>8.按值获取顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量返回</p>
<p>9.按下标插入元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listInsert</span><span class="params">(SqList &amp;L,type e,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> ++L.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j=i<span class="number">-1</span>;j--)</span><br><span class="line">     L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line"> L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）增加线性表长度</p>
<p> （3）按照目标元素位置，将其尾部元素后移1偏移量</p>
<p> （4）将目标元素存入下标位置</p>
<p> <strong>时间复杂度分析:</strong></p>
<p>  （1）<br>  $$<br>  最好情况：在表尾插入(即i&#x3D;n+1)<br>  $$</p>
<p>  $$<br>  元素后移语句执行的时间复杂度为O(1)<br>  $$</p>
<p>  （2）<br>  $$<br>  最坏情况：在表头插入(即i&#x3D;1)<br>  $$</p>
<p>  $$<br>  元素后移语句执行n次，时间复杂度为O(n)<br>  $$</p>
<p>  （3）<br>  $$<br>  平均情况：假设p_i(p_i&#x3D;1&#x2F;(n+1))<br>  $$</p>
<p>  $$<br>  是第i个位置上插入一个结点的概率<br>  $$</p>
<p>  $$<br>  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  f &#x3D; \sum_{i&#x3D;1}^{n+1}p_i(n-i-1)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\sum_{i&#x3D;1}^{n+1}{\frac{n+1}{n-i+1}}</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\frac{1}{n+1} \sum_{i&#x3D;1}^{n+1}(n-i-1)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  &#x3D;\frac{1}{n+1}\frac{n(n+2)}{2}&#x3D;\frac{n}{2}<br>  $$</p>
<p>  $$<br>  因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>  $$</p>
<p>10.按下标删除元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i  L.length))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; i &lt;= L.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">		--L.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）按照目标元素位置，将其头部元素前移1偏移量</p>
<p> （3）减少线性表长度</p>
<p> <strong>时间复杂度分析:</strong></p>
<p>  （1）<br>  $$<br>  最好情况：在表尾插入(即i&#x3D;n)<br>  $$</p>
<p>  $$<br>  无需移动元素，时间复杂度为O(1)<br>  $$</p>
<p>  （2）<br>  $$<br>  最坏情况：在表头插入(即i&#x3D;1)<br>  $$</p>
<p>  $$<br>  需移动除第一个元素外的所有元素，时间复杂度为O(n)<br>  $$</p>
<p>  （3）<br>  $$<br>  平均情况：假设p_i(p_i&#x3D;1&#x2F;(n+1))<br>  $$</p>
<p>  $$<br>  是第i个位置上插入一个结点的概率<br>  $$</p>
<p>  $$<br>  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  f &#x3D; \sum_{i&#x3D;1}^{n}p_i(n-i)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\sum_{i&#x3D;1}^{n}{\frac{n}{n-i}}</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\frac{1}{n} \sum_{i&#x3D;1}^{n}(n-i)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  &#x3D;\frac{1}{n}\frac{n(n-1)}{2}&#x3D;\frac{n-1}{2}<br>  $$</p>
<p>  $$<br>  因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>  $$</p>
<p>11.创建顺序存储线性表</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	type e;</span><br><span class="line">	L.length = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please in put an element:&quot;</span>;</span><br><span class="line">		cin  e;</span><br><span class="line">		L.elem[i] = e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.打印顺序存储线性表内元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nList&#x27;s element：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;elem[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] =&quot;</span> &lt;&lt; L.elem[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="clmdavay500054w8k81qn2uqk" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构·查找算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.285Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h2><h3 id="一般表"><a href="#一般表" class="headerlink" title="一般表"></a>一般表</h3><p>（1）代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> tableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchSeq</span><span class="params">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[e] = key;   <span class="comment">//设置哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;ST.tableLen; i++)</span><br><span class="line">        <span class="keyword">return</span> i;   <span class="comment">//存在返回, 不存在返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）设置哨兵：可以不必判断是否越界，注意数据下表从1开始<br>（3）ASL<br>$$<br>如果不能知道查找概率，可先对记录的查找概率进行排序，是表中的记录按查找概率从小到大\<br>ASL_{success} &#x3D; \sum_{i&#x3D;1}^{n} P_i(n-i+1) &#x3D; \frac{n+1}{2}\<br>ASL_{unsuccess} &#x3D; n+1\<br>$$<br>（4）优缺点<br>优点：对数据的存储无要求，顺序存储或者链式存储皆可<br>缺点：当n较大，平均查找长度较大，效率低</p>
<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1((10))--id2((20))</span><br><span class="line">id1((10)).--infinity,10</span><br><span class="line">id2((20))--id3((30))</span><br><span class="line">id2((20)).--infinity,20</span><br><span class="line">id3((30))--id4((40))</span><br><span class="line">id3((30)).--infinity,30</span><br><span class="line">id4((40))--id5((50))</span><br><span class="line">id4((40)).--infinity,40</span><br><span class="line">id5((50))--id6((60))</span><br><span class="line">id5((50)).--infinity,50</span><br><span class="line">id6((60))--60,=</span><br><span class="line">id6((60)).--infinity,60</span><br></pre></td></tr></table></figure>
<p>（1）一旦查到某个元素大于该元素便停止查找<br>（2）方框是虚构的节点，查找长度&#x3D;方框上的圆环<br>（3)ASL<br>$$<br>ASL_{success} &#x3D; \sum_{i&#x3D;1}^{n} P_i(n-i+1) &#x3D; \frac{n+1}{2}\<br>ASL_{unsuccess} &#x3D; \sum_{j&#x3D;1}^{n} Q_j(l_j-1) &#x3D;  \frac{1+2+…+n+n}{n+1} &#x3D; \frac{n}{2} +  \frac{n}{n+1}\<br>$$</p>
<h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id29((29))--id37((37))--id41((41))--id43((43))</span><br><span class="line">id43((43))--43,+infinity</span><br><span class="line">id43((43))--37,43</span><br><span class="line">id37((37))--id32((32))--id33((33))</span><br><span class="line">id32((32))--29,32</span><br><span class="line">id33((33))--33,37</span><br><span class="line">id33((33))--32,33</span><br><span class="line">id13((13))--id16((16))--id19((19))--19,29</span><br><span class="line">id19((19))--16,19</span><br><span class="line">id29((29))--id13((13))--id7((7))--id10((10))--10,13</span><br><span class="line">id10((10))--7,10</span><br><span class="line">id7((7))---infinity,7</span><br></pre></td></tr></table></figure>
<p>（1）仅适用于顺序表<br>（2）代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid = <span class="number">0</span>, L.tableLen, <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]  key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）ASL<br>$$<br>ASL &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n} l_i &#x3D; \frac{1}{n}(1<em>1+2</em>2+…+h*2^{h-1}) &#x3D; \frac{n+1}{n} log_2(n+1)-1 &#x3D; log_2(n+1)-1\<br>h&#x3D;[log_2(n+1)]（向上取整）<br>$$</p>
<h4 id="查找11"><a href="#查找11" class="headerlink" title="查找11"></a>查找11</h4><h5 id="low-7-high-43-mid-29"><a href="#low-7-high-43-mid-29" class="headerlink" title="low&#x3D;7, high&#x3D;43, mid&#x3D;29"></a>low&#x3D;7, high&#x3D;43, mid&#x3D;29</h5><h5 id="11"><a href="#11" class="headerlink" title="11&lt;29"></a>11&lt;29</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29--mid</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43--high</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-7-high-mid-1-19-mid-13"><a href="#low-7-high-mid-1-19-mid-13" class="headerlink" title="low&#x3D;7, high&#x3D;mid-1&#x3D;19, mid&#x3D;13"></a>low&#x3D;7, high&#x3D;mid-1&#x3D;19, mid&#x3D;13</h5><h5 id="11-1"><a href="#11-1" class="headerlink" title="11&lt;13"></a>11&lt;13</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13--mid</span><br><span class="line">16</span><br><span class="line">19--high</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="low-7-high-mid-1-7-mid-10"><a href="#low-7-high-mid-1-7-mid-10" class="headerlink" title="low&#x3D;7, high&#x3D;mid-1&#x3D;7, mid&#x3D;10"></a>low&#x3D;7, high&#x3D;mid-1&#x3D;7, mid&#x3D;10</h5><h5 id="117"><a href="#117" class="headerlink" title="117"></a>117</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low--mid</span><br><span class="line">10--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-mid-1-10-high-10-mid-10"><a href="#low-mid-1-10-high-10-mid-10" class="headerlink" title="low&#x3D;mid+1&#x3D;10, high&#x3D;10, mid&#x3D;10"></a>low&#x3D;mid+1&#x3D;10, high&#x3D;10, mid&#x3D;10</h5><h5 id="1010-×"><a href="#1010-×" class="headerlink" title="1010 ×"></a>1010 ×</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7</span><br><span class="line">10--low--mid--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="没找到，停在low"><a href="#没找到，停在low" class="headerlink" title="没找到，停在low"></a>没找到，停在low</h5><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>（1）将查找表分为若干子块，块内可以无序，但块之间有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">id24((24))--id((索引块24,54,78,88))</span><br><span class="line">id21((21))</span><br><span class="line">id6((6))</span><br><span class="line">id11((11))</span><br><span class="line">id8((8))</span><br><span class="line">id22((22))</span><br><span class="line">id32((32))--id((索引块24,54,78,88))</span><br><span class="line">id31((31))</span><br><span class="line">id54((54))</span><br><span class="line">id72((72))--id((索引块24,54,78,88))</span><br><span class="line">id61((61))</span><br><span class="line">id78((78))</span><br><span class="line">id88((88))--id((索引块24,54,78,88))</span><br><span class="line">id83((83))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）ASL<br>$$<br>n:长度\<br>b:分块个数\<br>s:每块s个记录\<br>P:等概率\<br>ASL &#x3D; L_I+L_S &#x3D; \frac{b+1}{2}+\frac{s+1}{2}&#x3D;\frac{s^2+2s+n}{2s}\<br>s&#x3D;\sqrt{n},ASL&#x3D;\sqrt{n}+1\<br>采用折半查找：ASL&#x3D;L_I+L_S&#x3D;[log_2(b+1)]+\frac{s+1}{2}（向上取整）<br>$$</p>
<p>###B树（多路平衡查找树）<br>$$<br>m阶B树或空树\<br>每棵子树至多m棵子树，最多包含m-1个关键字\<br>若根节点不是终端节点，至少两棵子树\<br>除根结点外所有非叶节点至少[\frac{m}{2}]（向上取整）棵子树（关键字）\<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">id[22]--id0[5,11]</span><br><span class="line">id[22]--id1[36,45]</span><br><span class="line">id0[5,11]--id00[1,3]</span><br><span class="line">id0[5,11]--id01[6,8,9]</span><br><span class="line">id0[5,11]--id02[13,15]</span><br><span class="line">id1[36,45]--id10[30,35]</span><br><span class="line">id1[36,45]--id11[40,42]</span><br><span class="line">id1[36,45]--id12[47,48,50,56]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" data-id="clmdavay700064w8k7es1bvsa" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理·中央处理器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.269Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>控制器：负责协调并控制计算机各部件执行程序的指令序列：取指令、分析指令、执行指令<br>运算器：对数据加工</p>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>数据加工</li>
<li>时间控制</li>
<li>中断处理</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>运算器和控制器两大部分组成<br>运算器：</p>
<ul>
<li>算术逻辑单元（ALU）</li>
<li>暂存寄存器</li>
<li>累加寄存器（ACC）</li>
<li>通用寄存器组（AX&#x2F;BX&#x2F;CX&#x2F;DX&#x2F;SP）</li>
<li>程序状态字寄存器（PSW：OF&#x2F;SF&#x2F;ZF&#x2F;CF）</li>
<li>移位器</li>
<li>计数器</li>
</ul>
<p>控制器（CU）：</p>
<ul>
<li>程序计数器（PC）</li>
<li>指令寄存器（IR）</li>
<li>指令译码器</li>
<li>存储器地址寄存器</li>
<li>存储器数据寄存器</li>
<li>时序系统</li>
<li>微操作信号发生器</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>CPU从主存取出并执行一条指令的时间，指令周期通常使用若干机器周期表示，每个机器周期可等长或不等，一个机器周期包含若干时钟周期（节拍），每个机器周期内的时钟周期数可以不等</p>
<ul>
<li>无条件转移指令：执行阶段不需要访存，只包含取指阶段（取指和分析）和执行阶段</li>
<li>间接寻址指令：为了取操作数，需要先访1次，取出有效地址，然后访存，取出操作数，所有需要包含间址周期，介于取指和执行之间</li>
<li>CPU采用中断方式实现主机和I&#x2F;O设备的信息交换，CPU在每条指令结束前，都要发送中断查询信号，若有中断请求，CPU进入中断响应阶段（中断周期）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>取指周期</td>
<td>间址周期</td>
<td>执行周期</td>
<td>中断周期</td>
</tr>
</tbody></table>
<p>只有访存的目的不同，取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点<br>CPU内设置了4个标志触发器FE&#x2F;IND&#x2F;EX&#x2F;INT</p>
<table>
<thead>
<tr>
<th>FE</th>
<th>IND</th>
<th>EX</th>
<th>INT</th>
</tr>
</thead>
<tbody><tr>
<td>Fetch</td>
<td>Index</td>
<td>Execute</td>
<td>Interrupt</td>
</tr>
<tr>
<td>取值</td>
<td>间址</td>
<td>执行</td>
<td>中断</td>
</tr>
</tbody></table>
<h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>根据PC中的内容从主存取出指令代码放入IR  </p>
<ul>
<li>PC $\to$ IR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\to$ DataBus $\to$ MDR $\to$ Mem</li>
<li>Mem $\to$ DataBus $\to$ MDR $\to$ IR（存放指令）</li>
<li>CU $\stackrel{SignalControl::FE}{\longrightarrow}$ [(PC) + 1 $\to$ PC]</li>
</ul>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>取操作数有效地址，间址为例：指令中的地址码送到MAR并送至地址总线，CU向存储器发送读命令，以获取有效地址并存在MDR  </p>
<ul>
<li>Addr(IR) &#x2F; MDR $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI&#x2F;O::READ}{\longrightarrow}$ ControlBus $\to$ Mem（存放有效地址）</li>
<li>Mem $\to$ DataBus $\to$ MDR</li>
</ul>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><p>取操作数，根据IR的指令字的操作码通过ALU操作产生执行结果</p>
<ul>
<li>无统一的数据流向</li>
</ul>
<h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>处理中断请求，假设程序断点存入堆栈，用SP指示栈顶地址，入栈操作是先修改栈顶指针，后存入数据</p>
<ul>
<li>CU $\stackrel{SignalStack::SP}{\longrightarrow}$ [(SP) - 1 $\to$ SP] $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI&#x2F;O::WRITE}{\longrightarrow}$ ControlBus $\to$ Mem</li>
<li>PC $\to$ MDR $\to$ DataBus $\to$ Mem（程序断点存入主存）</li>
<li>CU $\to$ PC（中断服务程序的入口地址送至PC）</li>
</ul>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul>
<li>单指令周期</li>
<li>多指令周期</li>
<li>流水线方案</li>
</ul>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>数据通路：数据在功能部件之间传输的路径<br>由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号<br>数据通路功能：实现CPU内部的运算器与寄存器以及寄存器之间的数据交换</p>
<h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>CPU内部单总线模式<br>所有寄存器的输入输出端都连接在一条公共通路上，结构简单但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构，CPU中有两条或更多的总线时，构成双总线结构或多总线结构</li>
<li>CPU内部多总线模式<br>所有寄存器的输入输出端都连接在多条公共通路上，相比之下单总线在一个时钟内只允许传一个数据，因此指令执行效率很低，因此在多总线方式，同时在多总线上传输不同的数据，提高效率</li>
<li>专用数据通路方式<br>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大</li>
</ul>
<h4 id="寄存器之间的数据传输"><a href="#寄存器之间的数据传输" class="headerlink" title="寄存器之间的数据传输"></a>寄存器之间的数据传输</h4><p>通过内部总线完成<br>寄存器AX的输入输出由AXout和AXin控制  </p>
<ul>
<li>(PC) $\to$ MAR，PCout和MARin有效</li>
</ul>
<h4 id="主存与CPU之间的数据传输"><a href="#主存与CPU之间的数据传输" class="headerlink" title="主存与CPU之间的数据传输"></a>主存与CPU之间的数据传输</h4><p>主存与CPU之间的数据传输需要借助CPU内部总线完成<br>主存内读取</p>
<ul>
<li>(PC) $\to$ MAR，PCout和MARin有效  </li>
<li>1 $\to$ R，CU发出读命令  </li>
<li>MEM(MAR) $\to$ MDR，MDRin有效  </li>
<li>(MDR) $\to$ IR，MDRout和IRin有效</li>
</ul>
<h4 id="执行算术或逻辑算术"><a href="#执行算术或逻辑算术" class="headerlink" title="执行算术或逻辑算术"></a>执行算术或逻辑算术</h4><p>由于ALU没有内部存储功能，执行加法操作，相加的两个数必须在ALU的两个输入输出端同时有效</p>
<ul>
<li>(MDR) $\to$ MAR，MDRout和MARin有效  </li>
<li>1 $\to$ R，CU读命令</li>
<li>MEM(MAR) $\to$ 操作数从主存送至MDR</li>
<li>(MDR) $\to$ Y，MDRout和Yin有效</li>
<li>(ACC) + (Y) $\to$ Z ACCout和ALUin有效</li>
<li>(Z) $\to$ ACC，Zout和ACCin有效</li>
</ul>
<h2 id="控制器功能与原理"><a href="#控制器功能与原理" class="headerlink" title="控制器功能与原理"></a>控制器功能与原理</h2><h3 id="结构和功能"><a href="#结构和功能" class="headerlink" title="结构和功能"></a>结构和功能</h3><ul>
<li>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据</li>
<li>输入设备和输出设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传输数据</li>
<li>控制器部件从数据总线接受指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件通过运算所需的控制信号</li>
</ul>
<p>控制器功能：</p>
<ul>
<li>从主存取指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、主存、输入输出设备之间的数据流动方向</li>
</ul>
<p>根据控制器产生微操作控制信号的方式不同，控制器可分为</p>
<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
</ul>
<p>两类控制器的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制部件各部件运算所需控制信号的方案不同</p>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul>
<li>根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号</li>
<li>由复杂的组合逻辑门电路和一些触发器构成</li>
</ul>
<h4 id="硬布线控制单元"><a href="#硬布线控制单元" class="headerlink" title="硬布线控制单元"></a>硬布线控制单元</h4><p>指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键<br>CU的输入信号来源：</p>
<ul>
<li>经指令译码器译码产生的信息指令</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信号（标志）</li>
<li>系统总线（控制总线）控制信号（中断请求、DMA请求）</li>
</ul>
<h4 id="硬布线控制器的时序系统及微操作"><a href="#硬布线控制器的时序系统及微操作" class="headerlink" title="硬布线控制器的时序系统及微操作"></a>硬布线控制器的时序系统及微操作</h4><ul>
<li>时钟周期<br>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度对应一个时钟周期，每个节拍内机器可以完成一个或几个需要同时执行的操作</li>
<li>机器周期<br>是所有指令执行过程的一个基准时间，访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期，在存储字长等于指令字长前提下，取指周期视为机器周期</li>
<li>指令周期</li>
<li>微操作命令分析<br>控制单元具有发出各种操作命令（控制信号）序列的功能，这些命令与指令有关</li>
</ul>
<p>执行过程，一条指令分为3个工作周期：取指周期、间址周期、执行周期  </p>
<p>取指周期  </p>
<ul>
<li>(PC) $\to$ MAR  </li>
<li>1 $\to$ R  </li>
<li>M(MAR) $\to$ MDR</li>
<li>(MDR) $\to$ IR</li>
<li>OP(IR) $\to$ CU</li>
<li>(PC) + 1  $\to$ PC</li>
</ul>
<p>间址周期</p>
<ul>
<li>Addr(IR) $\to$ MAR</li>
<li>1  $\to$ R</li>
<li>M(MAR)  $\to$ MDR</li>
</ul>
<p>执行周期  </p>
<ul>
<li>非访存指令  </li>
<li>访存指令</li>
</ul>
<h4 id="CPU控制方式"><a href="#CPU控制方式" class="headerlink" title="CPU控制方式"></a>CPU控制方式</h4><ul>
<li>同步控制方式<br>具有统一的时钟，所有控制信号均来自统一的时钟信号</li>
<li>异步控制方式<br>不存在基准时标信号，各部件按自身固有的速度工作，以应答方式联络</li>
<li>联合控制方式<br>大部分采用同步控制，小部分采用异步控制</li>
</ul>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>采用存储逻辑实现,把微操作信号代码化,使每条机器指令转化为一段微程序并存入一个专门的存储器（控制存储器），微操作控制信号由微指令产生</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>微操作和微命令<br>一条机器指令可以分解为一系列微操作序列，微操作是计算机中最基本、不可再分解的操作；微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，是构成控制系列的最小单位<br>微命令有相容性和互斥性</p>
</li>
<li><p>微指令和微周期<br>微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为微地址<br>一条微地址包括：<br>（1）操作控制字段（微操作码）：用于产生某一步操作所需的各种操作控制信号<br>（2）顺序控制字段（微地址码）：用于控制产生下一条要执行的微指令地址<br>微周期是执行一条微指令所需的时间，通常为一个时钟周期  </p>
</li>
<li><p>主存储器和控制存储器<br>主存储器M，用于存放程序和数据，在CPU外部，用RAM实现<br>控制存储器CM，用于存放微程序，在CPU内部，用ROM实现</p>
</li>
<li><p>程序和微程序<br>程序是指令的有序集合，用于完成某些特定的功能<br>微程序是微指令的有序集合，一条指令的给你由一段微程序实现<br>微程序和程序是两个不同的概念，微程序由微指令组成，描述机器指令，微程序实质是机器指令的实时解释器，由计算机设计者实现编制并存放于控制存储器CM中，无需知道，而程序最终由机器指令组成，由软件设计人员事先编制并存放于主存储器或辅助存储器</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAR</td>
<td>存放主存的读写地址</td>
<td>CMAR</td>
<td>存放控制存储器的读写微指令地址</td>
</tr>
<tr>
<td>IR</td>
<td>存放从主存中读出的指令</td>
<td>CMDR&#x2F;$\mu$IR</td>
<td>存放控制存储器中读出的微指令</td>
</tr>
</tbody></table>
<h4 id="组成-过程"><a href="#组成-过程" class="headerlink" title="组成&amp;过程"></a>组成&amp;过程</h4><ul>
<li>控制存储器：存放各指令对应的微程序</li>
<li>微指令寄存器：用于存放从CM中取出的微指令，位数同微指令字长相等</li>
<li>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行</li>
<li>微地址寄存器：接收微地址形成部件送来的微地址，为在CM中读取微指令作准备</li>
</ul>
<p>在微程序控制器的控制下计算器执行机器指令的过程：  </p>
<ul>
<li>执行取微指令：自动将取指微程序的入口地址送入CMAR，从CM中读取相应的微指令送入CMDR（取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完成，从主存取出的机器指令就已经存入指令寄存器中）</li>
<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令对应的微程序入口地址，并送入CMAR</li>
<li>从CM中逐条读取对应的微指令并执行</li>
<li>执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第一步</li>
</ul>
<p>微程序和机器指令：<br>一条机器指令对应一个微程序，由于机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编制为一个微程序，这个微程序只负责将指令从主存单元取出送入指令寄存器，也可编制对应的间址周期和中断周期的微程序<br>控制存储器CM中的微程序个数 &#x3D; 机器指令数+取指+间址+中断</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>又称微指令的控制方式，如何对微指令的控制字段进行编码，以形成控制信号  </p>
<ul>
<li><p>直接编码（直接控制）<br>无需进行译码，微指令的微命令字段中每位代表一个微命令，设计微指令，选用某个微命令只需将微命令对应的字段设置为1或0<br>优：简单直观速度快<br>缺：微指令字长过长，n个微命令要求微指令的操作字段有n位，造成控制存储器容量极大</p>
</li>
<li><p>字段直接编码<br>将微指令的微命令字段分成若干小字段，互斥性微命令组合在同一字段，相容性微命令组合在不同字段，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关<br>优:可以缩短微指令字长<br>缺：需要通过编译电路后发出微命令，较直接编译慢</p>
</li>
</ul>
<h4 id="地址形成方式"><a href="#地址形成方式" class="headerlink" title="地址形成方式"></a>地址形成方式</h4><ul>
<li>直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址（断定方式）</li>
<li>根据机器指令的操作码形成，机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
<li>增量计算器法：(CMAR) + 1 $\to$ CMAR</li>
<li>根据各种标志决定微指令分支转移地址</li>
<li>通过测试网络形成</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li>水平型：直接编码、字段直接编码、字段间接编码、混合编码</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$\dots$</td>
<td>$A_{n-1}$</td>
<td>$A_{n}$</td>
<td>判断测试字段</td>
<td>后继地址字段</td>
</tr>
<tr>
<td>操作控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>顺序控制</td>
<td></td>
</tr>
</tbody></table>
<p>优：微程序短，执行速快<br>缺：微指令长，编写微程序复杂  </p>
<ul>
<li>垂直型：采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>
</ul>
<table>
<thead>
<tr>
<th>$\mu$OP</th>
<th>Rd</th>
<th>Rs</th>
</tr>
</thead>
<tbody><tr>
<td>微操作码</td>
<td>目的地址</td>
<td>源地址</td>
</tr>
</tbody></table>
<p>优：微指令短、简单、规整，便于编写微程序<br>缺：微程序长，执行速度慢，工作效率低  </p>
<ul>
<li>混合型<br>在垂直型的基础上增加一些不太复杂的并行操作</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>水平型</th>
<th>垂直型</th>
</tr>
</thead>
<tbody><tr>
<td>并行能力</td>
<td>并行能力强、灵活性高、效率高</td>
<td>较差</td>
</tr>
<tr>
<td>执行时间</td>
<td>短</td>
<td>长</td>
</tr>
<tr>
<td>长度</td>
<td>微指令字较长，微程序较短</td>
<td>微指令字较短，微程序较长</td>
</tr>
<tr>
<td>难易程度</td>
<td>难</td>
<td>易</td>
</tr>
</tbody></table>
<h4 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h4><ul>
<li><p>动态微程序设计：根据用户的要求改变微程序，需要可写控制寄存器，使用EPROM</p>
</li>
<li><p>毫微程序设计：硬件不由微程序直接控制，通过存放在第二级控制存储器中的毫微程序来解释</p>
</li>
</ul>
<h4 id="微程序控制器和硬布线控制器比较"><a href="#微程序控制器和硬布线控制器比较" class="headerlink" title="微程序控制器和硬布线控制器比较"></a>微程序控制器和硬布线控制器比较</h4><table>
<thead>
<tr>
<th></th>
<th>微程序控制器</th>
<th>硬布线控制器</th>
</tr>
</thead>
<tbody><tr>
<td>工作原理</td>
<td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
<td>微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>规整性</td>
<td>较规整</td>
<td>烦琐、不规整</td>
</tr>
<tr>
<td>应用场合</td>
<td>CISC CPU</td>
<td>RISC CPU</td>
</tr>
<tr>
<td>易扩充性</td>
<td>容易</td>
<td>困难</td>
</tr>
</tbody></table>
<h3 id="异常（内中断）和中断"><a href="#异常（内中断）和中断" class="headerlink" title="异常（内中断）和中断"></a>异常（内中断）和中断</h3><p>异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常<br>硬故障中断：是由硬连线出现异常引起（存储器校验异常、总线错误）<br>程序性异常（软件中断）：CPU内部因执行指令而引起的（整除0、溢出、断点、单步跟踪、非法指令）<br>按照异常发生的原因和返回方式，可进一步分为故障、自陷、终止</p>
<ul>
<li><p>故障（Fault）<br>引起故障的指令启动后、执行结束前被检测到的异常，因为无法通过异常处理程序恢复故障，因此不能回到原断点处执行，必须终止进程的执行  </p>
</li>
<li><p>自陷（Trap）<br>事先安排的一种异常事件，事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志人为设置一个陷阱，当执行到被设置了陷阱的指令时，CPU在执行陷阱指令后，自动根据不同的陷阱类型进行相应的处理，然后返回到自陷程序下一条指令执行。当自陷指令是转移指令时，并不是返回到下一条指令执行，而不是返回到转移目标指令执行</p>
</li>
<li><p>终止（Abort）<br>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，程序将无法继续执行，只能终止，此时调出中断服务程序来重启系统，终止异常和外中断属于硬件中断</p>
</li>
</ul>
<p>中断是来自CPU外部、与CPU执行指令无关的事件引起的中断<br>中断的分类：</p>
<ul>
<li><p>可屏蔽中断<br>通过可屏蔽中断请求线INTR向CPU发出中断请求，CPU可通过设置相应的屏蔽字来屏蔽或不屏蔽某个中断</p>
</li>
<li><p>不可屏蔽中断<br>通过专门的不可屏蔽中断请求NMI向CPU发出的中断请求，通常是非常紧急的硬件故障</p>
</li>
</ul>
<p>中断和异常的不同：  </p>
<ul>
<li><p>缺页或溢出等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成  </p>
</li>
<li><p>异常的检测由CPU完成，不通过外部的某个信号通知CPU，中断CPU必须通过中断请求线获取中断源信息，才能知道哪个设备发生了何种中断</p>
</li>
</ul>
<h3 id="异常和中断响应过程"><a href="#异常和中断响应过程" class="headerlink" title="异常和中断响应过程"></a>异常和中断响应过程</h3><ul>
<li>关中断</li>
<li>保存断点和程序状态</li>
<li>识别异常和中断并转到相应的处理程序（软件识别和硬件识别）</li>
</ul>
<p>软件识别：CPU设置一个异常状态寄存器，用于记录异常原因，操作系统使用一个统一的异常和中断查询程序，按优先级顺序查询异常状态寄存器，以检查异常和中断类型，先查询到的先处理，然后转到内核中相应的处理程序</p>
<p>硬件识别（向量中断）：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放于中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表内，类型号和中断向量一一对应</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>从两方面提高处理机的并行性：  </p>
<ul>
<li>时间并行：流水线技术</li>
<li>空间并行：超标量处理机</li>
</ul>
<h3 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h3><p>一条指令的执行过程分解为几个阶段，每个阶段由相应的功能部件完成</p>
<ul>
<li>取指IF</li>
<li>译码&#x2F;读寄存器ID</li>
<li>执行&#x2F;计算地址EX</li>
<li>访存MEM</li>
<li>写回WB</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" data-id="clmdavayj000c4w8k03tfbcob" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理·指令系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.253Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统-1"><a href="#指令系统-1" class="headerlink" title="指令系统"></a>指令系统</h2><p>是指令集体系结构ISA的核心<br>ISA主要包括：</p>
<ul>
<li>指令格式</li>
<li>数据类型及格式</li>
<li>操作数的存放方式</li>
<li>程序可访问的寄存器个数、位数和编号 </li>
<li>存储空间大小和编址方式</li>
<li>寻址方式</li>
<li>指令执行过程的控制方式等</li>
</ul>
<h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3><p>一条指令包括操作码和地址码字段</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>操作码</td>
<td>地址码</td>
</tr>
</tbody></table>
<p>操作码:</p>
<ul>
<li>指出指令应执行的操作</li>
<li>识别指令</li>
<li>了解指令功能</li>
<li>区分操作数地址内容的组成和使用方法</li>
</ul>
<p>地址码：</p>
<ul>
<li>给出被操作的信息的地址</li>
<li>参加运算的一个或多个操作数所在的地址</li>
<li>运算结果的保存地址</li>
<li>程序的转移地址</li>
<li>被调用的子程序的入口地址等</li>
</ul>
<p>指令长度是指一条指令中包含的二进制代码的位数<br>指令字长取决于</p>
<ul>
<li>操作码的长度</li>
<li>操作数地址码的长度</li>
<li>操作数地址个数</li>
</ul>
<p>单字长指令：等于机器字长<br>半字长指令：一半机器字长<br>双字长指令：二倍机器字长<br>定长指令字结构：一个指令系统所有指令的长度都是相等的  </p>
<h4 id="零地址指令：无显示地址"><a href="#零地址指令：无显示地址" class="headerlink" title="零地址指令：无显示地址"></a>零地址指令：无显示地址</h4><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
</tr>
</tbody></table>
<ul>
<li>不需要操作数的指令</li>
<li>零地址运算指令仅用于堆栈计算机，通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出，送至运算器，运算结果再隐含的压入堆栈</li>
</ul>
<p>一地址指令：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
</tr>
</tbody></table>
<p>OP($A_1$) $\to$ $A_1$</p>
<ul>
<li>只有目的操作数，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址</li>
</ul>
<p>(ACC)OP($A_1$) $\to$ ACC</p>
<ul>
<li>隐含约定目的地址的双操作数指令，按指令地址$A_1$地址读取操作数，指令可隐含约定另一个操作数由ACC提供，运算结果也将存放在ACC中</li>
<li>若指令长度为32位，操作码占8位，1个地址码字段占24位，指令操作数直接寻址范围$2^{24}&#x3D;16M$</li>
</ul>
<h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
</tr>
</tbody></table>
<p>($A_1$)OP($A_2$) $\to$ $A_1$</p>
<ul>
<li>常用的算术和逻辑运算指令，需要两个操作数，需要分别给出目的操作数和源操作数，其中目的操作数地址还用于存放本次运算结果</li>
<li>指令字长位32位，操作码占8位，两个地址码各占12位，则指令操作数的直接寻址范围$2^{12}&#x3D;4K$</li>
</ul>
<h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$(结果)</td>
</tr>
</tbody></table>
<p>($A_1$)OP($A_2$) $\to$ $A_3$</p>
<ul>
<li>指令字长位32位，操作码占8位，3个地址码各占8位，直接寻址范围$2^8&#x3D;256$，地址字段为主存地址，则完成一条三地址需要4次访存，取指令1次，取两个操作数2次，存放结果1次</li>
</ul>
<h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>$A_4$</td>
</tr>
</tbody></table>
<p>($A_1$)OP($A_2$) $\to$ $A_3$ ，$A_4$ &#x3D; 下一条执行指令的地址</p>
<ul>
<li>地址字长为32位，操作码占8位，4个地址码各占6位，直接寻址范围$2^6&#x3D;64$</li>
</ul>
<h3 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h3><p>在指令字的最高位部分分配固定的若干位（定长）表示操作码。<br>n位操作码字段的指令系统最大能表示$2^{n}$条指令</p>
<h3 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h3><ul>
<li>不允许短码是长码的前缀</li>
<li>各指令的操作码一定不能重复</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
</tr>
<tr>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
</tr>
<tr>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>操作码情况</td>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>说明</td>
</tr>
<tr>
<td>15条三地址</td>
<td>0000-1110</td>
<td></td>
<td></td>
<td></td>
<td>余出16-15&#x3D;1，1*2^4&#x3D;16种</td>
</tr>
<tr>
<td>12条二地址</td>
<td>1111</td>
<td>0000-1011</td>
<td></td>
<td></td>
<td>余出16-12&#x3D;4，4*2^4&#x3D;64种</td>
</tr>
<tr>
<td>62条一地址</td>
<td>1111</td>
<td>(1100-1110)&#x2F;1111</td>
<td>(0000-1111)&#x2F;(0000-1101)</td>
<td></td>
<td>余出64-62&#x3D;2，2*2^4&#x3D;32种</td>
</tr>
<tr>
<td>32条零地址</td>
<td>1111</td>
<td>1111</td>
<td>1110-1111</td>
<td>0000-1111</td>
<td></td>
</tr>
</tbody></table>
<h3 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h3><ul>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位</li>
<li>转移</li>
<li>输入输出</li>
</ul>
<h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><p>确定本条指令的数据地址以及下一条待执行指令的地址，分为：</p>
<ul>
<li><p>指令寻址：寻找下条要执行的指令<br>（1）顺序寻址<br>通过PC+(1)，自动形成下一条指令<br>（2）跳跃寻址<br>通过转移指令实现，下条指令的地址不由PC自动给出，而由本条指令给出下条指令地址的计算方式。是否可跳跃受到状态寄存器和操作数的控制，跳跃的结果是当前指令修改PC值，下一条指令仍通过PC给出</p>
</li>
<li><p>数据寻址：寻找本条指令的数据<br>通常在指令字中设一个字段指明寻址方式</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>操作码</td>
<td>寻址特征</td>
<td>形式地址A</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="常见数据寻址方式"><a href="#常见数据寻址方式" class="headerlink" title="常见数据寻址方式"></a>常见数据寻址方式</h3><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>不明显的给出操作数，在指令中隐含操作数地址</p>
<ul>
<li>优：有利于缩短指令字长</li>
<li>缺：需要增加存储操作数或隐含地址的硬件</li>
</ul>
<h4 id="立即（数）寻址"><a href="#立即（数）寻址" class="headerlink" title="立即（数）寻址"></a>立即（数）寻址</h4><p>指令的地址字段指出的不是操作数地址，而是操作数本身，又称立即数，#表示立即寻址特征，使用补码表示</p>
<ul>
<li>优：指令在执行阶段不访问主存，指令执行时间最短</li>
<li>缺：A的位数限制立即数的范围</li>
</ul>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>指令中的形式地址A是操作数的真实地址EA，EA&#x3D;A  </p>
<ul>
<li>优：简单，访存1次，不需要专门计算操作数的地址</li>
<li>缺：A的位数决定了指令操作数的寻址范围，操作数的地址不易修改</li>
</ul>
<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址的存储单元地址，EA&#x3D;(A)，间接寻址可以迭代多次<br>间接寻址，主存第一位表示是否为多次间址</p>
<ul>
<li>优：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间址寻址可方便的完成子程序返回）</li>
<li>缺：访问速度慢</li>
</ul>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>指令字中直接给出操作数所在的寄存器编号EA&#x3D; $R_i$，操作数在由$R_i$所指的寄存器内</p>
<ul>
<li>优：指令执行阶段不访存，只访问寄存器，寄存器对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量&#x2F;矩阵运算</li>
<li>缺:寄存器昂贵，有限</li>
</ul>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址EA&#x3D;($R_i$)</p>
<ul>
<li>优：与一般间址寻址速度快</li>
<li>缺：需要访存</li>
</ul>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>PC的内容加上指令格式的形式地址A而形成操作数的有效地址EA&#x3D;(PC)+A，A是相对于当前PC的值的位移量，可正可负，用补码表示，A的位数决定寻址范围</p>
<ul>
<li>操作数的地址是不固定的，随PC的值变化而变化，且与指令地址之间相差一个固定值，便于程序浮动，广泛用于转移指令</li>
<li>JMP A，CPU从存储器取出一字节，自动执行(PC)+1 $\to$ PC，若转移指令的地址为X，且占2B，取出该指令后，PC自增2，(PC)&#x3D;X+2，执行完该指令，会自动跳转至X+2+A的地址继续执行</li>
</ul>
<h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>将CPU的基址寄存器BR的内容加上指令格式的形式地址A形成操作数的有效地址EA&#x3D;(BR)+A，基址寄存器可采用专用寄存器也可为通用寄存器</p>
<ul>
<li><p>基址寄存器面向操作系统，内容通过操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性</p>
</li>
<li><p>执行过程中基址寄存器内容不变，形式地址可变（偏移量）</p>
</li>
<li><p>采用通用寄存器作为基址寄存器，用户可决定使用哪个寄存器，内容由操作系统确定</p>
</li>
<li><p>优：可扩大寻址范围（基址寄存器位数大于形式地址A的位数），用户不必考虑自己的程序存于主存哪个区域，有利于多道程序设计，可用于制成浮动程序</p>
</li>
<li><p>缺：偏移量位数较短</p>
</li>
</ul>
<h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，EA&#x3D;(IX)+A</p>
<ul>
<li>IX可使用专用寄存器或通用寄存器</li>
<li>变址寄存器面向用户，在程序执行过程，变址寄存器内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）</li>
<li>可扩大寻址范围（变址寄存器位数大于形式地址A的位数），适合编制循环程序，偏移量的位数（IX）足以表示整个存储空间</li>
</ul>
<h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>堆栈是存储器（或专用寄存器组）中一块特定的、按照后进先出（LIFO）的原则管理的存储区，存储区读写单元地址是用一个特定寄存器给出的称为堆栈指针(SP)，分为硬堆栈（不适合做大容量堆栈）和软堆栈（主存划出一段区域）</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>有效地址</th>
<th>访存次数</th>
</tr>
</thead>
<tbody><tr>
<td>隐含寻址</td>
<td>程序指定</td>
<td>0</td>
</tr>
<tr>
<td>立即寻址</td>
<td>A是操作数</td>
<td>0</td>
</tr>
<tr>
<td>直接寻址</td>
<td>EA&#x3D;A</td>
<td>1</td>
</tr>
<tr>
<td>一次间接寻址</td>
<td>EA&#x3D;(A)</td>
<td>2</td>
</tr>
<tr>
<td>寄存器寻址</td>
<td>EA&#x3D; $R_i$</td>
<td>0</td>
</tr>
<tr>
<td>寄存器间接一次寻址</td>
<td>EA &#x3D; ($R_i$)</td>
<td>1</td>
</tr>
<tr>
<td>相对寻址</td>
<td>EA&#x3D;(PC)+A</td>
<td>1</td>
</tr>
<tr>
<td>基址寻址</td>
<td>EA&#x3D;(BR)+A</td>
<td>1</td>
</tr>
<tr>
<td>变址寻址</td>
<td>EA&#x3D;(IX)+A</td>
<td>1</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" data-id="clmdavayl000d4w8k47b5607r" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理·虚拟存储器页式段式和段页式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.237Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚拟存储器·页式·段式·段页式"><a href="#虚拟存储器·页式·段式·段页式" class="headerlink" title="虚拟存储器·页式·段式·段页式"></a>虚拟存储器·页式·段式·段页式</h1><p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>
<ul>
<li>实地址 &#x3D; 主存页号 + 页内字地址</li>
<li>虚地址 &#x3D; 虚存页号 + 页内字地址</li>
<li>辅存地址 &#x3D; 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>
</ul>
<p>CPU使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>
<ul>
<li>在内存，通过地址变换，CPU可直接访问主存指示的数据单元</li>
<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>
</ul>
<h2 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h2><p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong>  </p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>有效位</td>
<td>脏位</td>
<td>引用位</td>
<td>物理页</td>
</tr>
</tbody></table>
<ul>
<li>有效位（装入位）：表示对应页是否在主存</li>
<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>
<li>引用位（使用位）：配合替换算法进行设置</li>
</ul>
<p>CPU运行指令时，虚地址转实地址：</p>
<ul>
<li>页表基址寄存器存放进程的页表首地址</li>
<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>
<li>装入位为1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>
<li>装入位为0，说明缺页，需要操作系统进行缺页处理</li>
</ul>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h3><p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>快表通常采用组相联或全相联方式</p>
<table>
<thead>
<tr>
<th>t</th>
<th>r</th>
<th>p</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>有效位</td>
<td>实页号</td>
</tr>
</tbody></table>
<h3 id="具有TLB和Cache的多级存储系统"><a href="#具有TLB和Cache的多级存储系统" class="headerlink" title="具有TLB和Cache的多级存储系统"></a>具有TLB和Cache的多级存储系统</h3><p>三种缺失的情况  </p>
<table>
<thead>
<tr>
<th></th>
<th>TLB</th>
<th>Page</th>
<th>Cache</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>命中</td>
<td>命中</td>
<td>命中</td>
<td>TLB命中则Page一定命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>2</td>
<td>命中</td>
<td>命中</td>
<td>缺失</td>
<td>TLB命中则Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>3</td>
<td>缺失</td>
<td>命中</td>
<td>命中</td>
<td>TLB缺失但Page可能命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>4</td>
<td>缺失</td>
<td>命中</td>
<td>缺失</td>
<td>TLB缺失但Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>5</td>
<td>缺失</td>
<td>缺失</td>
<td>缺失</td>
<td>TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache</td>
</tr>
</tbody></table>
<h2 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h2><p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>段首地址</td>
<td>装入位</td>
<td>段长</td>
</tr>
</tbody></table>
<p>CPU访存时：</p>
<ul>
<li>根据段号与段表基地址拼接成对应的段表行</li>
<li>根据段表行的装入位判断是否调入内存</li>
<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址</li>
</ul>
<h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><p>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>段内页号</td>
<td>页内地址</td>
</tr>
</tbody></table>
<p>CPU访存：</p>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成实地址</li>
</ul>
<h2 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与Cache的比较</h2><table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody><tr>
<td>目的均为提供系统性能</td>
<td>Cache主要解决系统速度，虚拟存储器解决主存容量</td>
</tr>
<tr>
<td>均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大</td>
<td>Cache由硬件实现，对程序员透明，虚拟存储器由OS和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td>都有地址的映射、替换算法、更新策略</td>
<td></td>
</tr>
<tr>
<td>均依据程序的局部性原理</td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/" data-id="clmdavayo000f4w8kbtq4adf5" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理·数据表示与运算" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.219Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据表示和运算"><a href="#数据表示和运算" class="headerlink" title="数据表示和运算"></a>数据表示和运算</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li><strong>r进制</strong><br> $K_{n} K_{n-1} K_{n-2} \dots K_{0} K_{-1} \dots K_{-m}$<br>数值表示 $K_{n} r^{n} + K_{n-1} r^{n-1} + \dots + K_{0} r^{0} + K_{-1} r^{-1} + \dots + K_{-m} r^{-m} &#x3D; \sum_{i&#x3D;n}^{-m} K_{i} r^{i}$</li>
<li>二进制<br>$01 \space r&#x3D;2$</li>
<li>八进制<br>$01234567 \space r&#x3D;8&#x3D;2^3$</li>
<li>十六进制<br>$0123456789ABCDEF \space r&#x3D;16&#x3D;2^4$</li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>4位二进制数码与1位十六进制数码相对应<br>3位二进制数码与1位八进制数码相对应  </p>
<h2 id="原反补移"><a href="#原反补移" class="headerlink" title="原反补移"></a>原反补移</h2><ul>
<li><p>原码</p>
</li>
<li><p>反码</p>
</li>
<li><p>补码</p>
</li>
<li><p>移码</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" data-id="clmdavayn000e4w8kg0ywer5r" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%C2%B7%E7%AE%80%E8%BF%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%BA%BF%E6%80%A7%E8%A1%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%80%E8%BF%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>