<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机组成原理·Cache和主存的映射替换算法和写策略" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E5%86%99%E7%AD%96%E7%95%A5/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.203Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Cache和主存的映射·替换算法·写策略"><a href="#Cache和主存的映射·替换算法·写策略" class="headerlink" title="Cache和主存的映射·替换算法·写策略"></a>Cache和主存的映射·替换算法·写策略</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>Cache行中的信息是主存某个块的副本<br>地址映射：将主存地址空间映射到Cache地址空间，按某种规则将主存的信息装入Cache<br>Cache的行数比主存块少的多，只有一部分主存块的信息可以装入Cache中，因此在Cache中需要为每块加一个<strong>标记</strong>，指明它是主存的哪一块的副本，此标记相当于主存块的编号。为了说明Cache行中的信息是否有效还需要一个<strong>有效位</strong>，地址映射以下3种：</p>
<ul>
<li>直接映射</li>
<li>全相联映射</li>
<li>组相联映射</li>
</ul>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>Cache 行号 &#x3D; 主存块号 mod Cache 总行数<br>假设 Cache : $2^c$行 主存 : $2^m$块<br>$0,2^c,2^{c+1},\dots$块映射到第0行<br>$1,2^c+1,2^{c+1}+1$块映射到第1行<br>低c位为装入的Cache行号，给每行设置一个长为t&#x3D;m-c的标记，当某个主存块调入Cache后，将主存块号的高t位设置为对应Cache行中的标记  </p>
<table>
<thead>
<tr>
<th>t</th>
<th>c</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>Cache行号</td>
<td>块内地址</td>
</tr>
</tbody></table>
<p>CPU访存过程：</p>
<ul>
<li>根据访存地址中间的c位找到对应Cache行</li>
<li>Cache行标记与主存地址高t位标记比较，确定是否有效</li>
<li>相等且有效位为1，访问Cache命中，根据主存地址低b位的块内地址，在对应Cache行中存取信息</li>
<li>不相等或有效位为0，不命中，CPU将主存读出该地址所在的一块信息送到相应的Cache行中，置有效位1，并将标记设置为地址高t位，同时将地址中的内容送CPU</li>
</ul>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p>主存的每一块可以装入Cache中的任何位置，每行<strong>标记</strong>用于指出该行取自主存的哪一块，CPU访存时需要与所有Cache行的标记进行对比  </p>
<table>
<thead>
<tr>
<th>t</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>块内地址</td>
</tr>
</tbody></table>
<h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p>将Cache分为Q个大小相等的组，每个主存块可以装入固定组的任意一行，即组间采用直接映射，而组内采用全相联映射，Q&#x3D;1变为全相联映射，Q&#x3D;Cache行数变为直接映射<br>假设r个Cache行，则称之为r路组相联映射<br>Cache组号&#x3D;主存块号 mod Cache组数(Q)  </p>
<table>
<thead>
<tr>
<th>t</th>
<th>g</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>组号</td>
<td>块内地址</td>
</tr>
</tbody></table>
<p>CPU访存：</p>
<ul>
<li>根据访存地址中间的g位组号找到对应的Cache组</li>
<li>将对应的Cache组的每个行标记与主存的高t位标记进行比较</li>
<li>相等且有效位为1，命中，根据主存地址中的低b位块内地址，在对应的Cache行中存取信息</li>
<li>不相等或有效位为0，未命中，CPU从主存读出该地址所在的一块信息送到对应的Cache组的任意一个空行，有效位置1，设置标记，同时将地址中的内容送CPU</li>
</ul>
<h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p>在采用全相联映射或组相联映射方式时，主存向Cache传送一个新块，Cache或Cache组空间已满替换的策略</p>
<ul>
<li>RAND</li>
<li>FIFO</li>
<li>LRU</li>
</ul>
<h2 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h2><p>因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略，使Cache内容和主存保持一致<br>对于Cache写命中：</p>
<ul>
<li>全写法：当CPU对Cache写命中时，必须八数据同时写入Cache和内存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖。</li>
<li>回写法：当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有当此块被换出时，才写入主存。每个Cache行设置一个修改位（脏位），若修改位为1，Cache行被修改过，替换时需要写回主存，若为0，则说明Cache行中的块未被命中，替换时无需写回</li>
</ul>
<p>对于Cache写不命中：</p>
<ul>
<li>写分配法：加载主存中的块到Cache中，然后更新这个Cache块</li>
<li>非写分配法：只写入主存，不进行调块</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%C2%B7Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E5%86%99%E7%AD%96%E7%95%A5/" data-id="clmdavayh000b4w8k7rm4fnvn" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络·网络层" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%BD%91%E7%BB%9C%E5%B1%82/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.187Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <pre><code class="markmap"># 网络层
## 功能概述 
- 数据报服务
    - 简单灵活 
    - 无连接
    - 尽最大努力交付
    - 为了使路由器简单
        可靠通信由传输层负责
        传送分组可能
        - 出错
        - 丢失
        - 重复
        - 失序
        - 超时
- 异构网络互连
    - 各层中继系统
        - 物理层
            - 转发器
            - 集线器
        - 数据链路层
            - 网桥
            - 交换机
        - 网络层
            - **路由器**
        - 网络层以上
            - 网关
- 路由与转发
    - 路由选择（确定哪一条路径）
        - 按照分布式算法
            根据从各相邻的路由器
            所得的关于整个网络拓扑的变化情况
            动态改变选择的路由
    - 分组转发（一个分组到达时采取的动作）
        - 根据转发表
            将用户IP数据报
            从合适端口转发出去
- SDN Software Define Network
    - 网络层定义
        - 数据平面
            - 转发
        - 控制平面
            - 路由选择
    - SDN网络
        - 数据、控制平面分离
        - 数据平面
            - 
        - 控制平面
            - 集中式
- 拥塞控制
    - 开环控制
    - 闭环控制

## 路由算法
- 静态路由算法
    - 非自适应路由算法
    - 网络管理员手动配置
    - 拓扑结构发生变化手动修改静态路由
    - 小型网络
- 动态路由算法
    - 自适应路由算法
    - 互连的路由器间彼此交换路由表
- 距离-向量算法
    - 所有节点定期
        将各自整个路由选择表
        转发到相邻节点
        - 每条路径的目的地
        - 路径的代价（距离）
        - RIP算法
- 链路状态路由算法
    - 每个参与算法的节点
        均具有完全的拓扑信息
        - 主动测试所有相邻节点
        - 定期将链路状态传播所有其他节点
    - OSPF算法
    - 洪泛法发送信息
    - 所有路由器
    - 路由器相邻的所有路由链路状态
    - 度量 metric
        - 费用
        - 距离
        - 时延
        - 带宽
    - 链路状态变化才发送
- 层次路由
    - 网络规模增大
        路由表增大
    - 整个互联网划分
        划分为很多较小的自治系统
    - 内部网关协议
        - RIP
        - OSPF
    - 外部网关协议
        - BGP
## IPV4
- IPV4分组
    - 首部长度
        - 占4位
        - 最大十进制数15
        - 最大值15 * 4B = 60B
    - 总长度
        - 首部和数据之和
        - 单位为字节
        - 以太网帧的最大传送单元
            MTU=1500B
        - 最大长度$2^&#123;16&#125;=65535B$
        - 标识 
            - 占16位
            - 计数器 i++
            - 数据报长度超过网络MTU
                必须分片
                此时每个数据报片
                均复制一次标识号
        - 标志
            - 占3位
            - 标志字段最低位MF
                MF=1表示后面还有分片
                MF=0表示最后一个分片
            - 标志字段中间的一位DF
                DF=0时才允许分片
        - 片偏移
            - 占13位
            - 较长的分组在分片后
                某片在原分组中相对位置
            - 以8个字节为偏移单位
            - 除最后一个分片
                每个分片的长度一定
                是8B的整数倍
        - 生存时间 TTL
            - 占8位
            - 数据报可通过路由数最大值
            - 确保分组不会永远在网络中循环
        - 协议
            - 占8位
            - TCP : 6
            - UDP : 17
        - 首部校验和
            - 占16位
            - 只校验分组的首部
            - 不校验数据部分
        - 源地址字段
            - 占4B
        - 目的地址字段
            - 占4B
- 数据报分片
    - 链路承载最大数据量
        最大传送单元MTU
    - IP数据报4000B
        首部20B 数据3980B
        MTU=1500B 标识=777
        MF=0 DF=0
        **分片大小为8B的倍数=1480**
        - 分片1
            - 标识=777 
            - 片偏移=0
            - MF=1 DF=0
            - 有效数据1480B
        - 分片2
            - 标识=777 
            - 片偏移=185
            - MF=1 DF=0
            - 有效数据1480B 
        - 分片3
            - 标识=777 
            - 片偏移=370
            - MF=0 DF=0
            - 有效数据(3980-1480*2)B
- IPV4地址
    - A类
        - 1 ~ 126
        - **0**000,0000;0;0;0 ~
            **0**111,1111;1;1;1
    - B类
        - 128 ~ 191
        - **10**00,0000;0;0;0
            **10**11,1111;1;1
    - C类
        - 192 ~ 223
        - **110**0,0000;0;0;0 ~
            **110**1,1111;1;1;1
    - D类
        - 224 ~ 239
        - **1110**,0000;0;0;0 ~
            **1110**,1111;1;1;1
    - E类
        - 240 ~ 255
        - **1111**,0000;0;0;0 ~
            **1111**,1111;1;1;1
    - IP::=&#123;&lt;网络号&gt;,&lt;主机号&gt;&#125;
        - 主机号全为0表示本网络
        - 主机号全1表示本网络广播地址
        - 127.x.x.x为环回自检地址
        - 表示任意主机自身
        - 目的地址为127.x的
            IP数据报不会出现在任何网络
        - 32位全为0表示本网络上本主机
        - 32位全为1表示整个TCP/IP网络的广播地址
        - IP地址使用范围
            - A
                - 最大网络可用数=$2^&#123;7&#125;-2$
                - 第一个可用的网络号=1
                - 最后一个可用的网络号=126
                - 每个网络中最大的主机=$2^&#123;24&#125;-2$
            - B
                - 最大网络可用数=$2^&#123;14&#125;$
                - 第一个可用的网络号=128.0
                - 最后一个可用的网络号=191.255
                - 每个网络中最大的主机=$2^&#123;16&#125;-2$
            - C
                - 最大网络可用数=$2^&#123;21&#125;$
                - 第一个可用的网络号=192.0.0
                - 最后一个可用的网络号=223.255.255
                - 每个网络中最大的主机=$2^&#123;8&#125;-2$
- NAT
    - 专门网络地址转换为公用地址
        而对外隐藏内部管理的IP
    - 划分私有IP
        - 只用于LAN
        - 不用于WAN
        - 私有IP不能直接接入Internet
        - 通过网关利用NAT
        - 私有IP转为Internet中合法的全球IP
        - 网段
            - A
                - 1个A类
                - 10.0.0.0 ~ 10.255.255.255
            - B
                - 16个B类
                - 172.16.0.0 ~ 172.31.255.255
            - C
                - 256个C类
                - 192.168.0.0 ~ 192.168.255.255
        - 目的地址为私有IP不进行转发：本地互联网
    - NAT转换表
        - WAN : LAN
        - 138.76.29.7:5001 | 192.168.0.2:2233
    - 普通路由器转发IP数据报，不改变源IP和目的IP
    - NAT路由器转发IP数据报，一定改变
- 子网划分
    - 两级IP
        - 缺点
            - 地址空间利用率低
            - 每分配一个网络号会是路由表变得太大
            - 网络性能变坏
            - 不够灵活
    - 划分
        - 对内表现为子网划分，对外表现为没有划分的网络
        - 从主机号借用若干比特作为子网号
        - IP = &#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;
        - 从其他网络发送给本单位某主机的IP
            仍然根据IP目的网络
            找到连接本单位网络的路由
            该路由收到IP
            按目的网络和子网找到目的子网
            最后交付IP至目的主机
        - 划分只根据主机号借用位作子网号
            不改变网络号
            从一个IP地址或首部无法判断是否子网划分
- 子网掩码
    - 表达对原网络主机号的借位
    - 将IP与子网掩码按位相与*AND*
    - 得到相应的子网地址
    - 要求
        - 主机设置IP地址必须设置子网掩码
        - 同属一个子网的所有主机及路由器的相应端口必须设置相同的子网掩码
        - 路由器的路由表所包含信息：目的网络地址、子网掩码、下一跳地址
- CIDR
    - 在变成子网掩码基础上消除ABC类网络划分
    - 在软件下实现超网构成
    - IP = &#123;&lt;网络前缀&gt;,&lt;主机号&gt;&#125;
    - 斜线记法
        - IP地址/网络前缀所占比特数
        - 128.14.32.5/20
            - IP:      1000,0000;0000,1110;0010,0000;0000,0101
            - 子网掩码: 1111,1111;1111,1111;1111,0000;0000,0000
            - 网络前缀: *1000,0000;0000,1110;0010*,0000;0000,0000
                128.14.32.0
    - CIDR不使用子网，仍使用掩码
    - CIDR地址块
        - 网络前缀相同的连续IP组成
        - 206.1.0.0/17
            - *1100,1010;0000,0001;0*000,0000;0000,0000
        - 206.1.128.0/17
            - *1100,1010;0000,0001;1*000,0000;0000,0000
        - 206.1.0.0/16
            - *1100,1010;0000,0001*;0000,0000;0000,0000
    - 最长前缀匹配（最佳匹配）
        - 路由表中的每个项目由&lt;网络前缀&gt;&lt;下一跳地址&gt;组成
            在查找路由表时可能不止一个匹配结果
            匹配结果中选择具有最长网络前缀的路由
            网络前缀越长
            地址块越小
            路由越具体
    - 网络层转发分组
        - 基于目的主机所在的网络
            网络数远小于主机数
        - 分组到达路由器
            路由器根据目的IP地址的网络前缀查找转发表
                确定下一跳应到哪个路由器
        - 转发表中每条路由必须有下面两条信息
            (目的网络, 下一跳地址)
            IP数据报最终一定可以找到目的主机所在目的网络上的路由器
            达到最后一个路由器，向目的主机进行直接交付
- ARP、DHCP、ICMP
    - IP地址与硬件地址
        - IP地址是网络层使用
        - MAC地址是数据链路层使用
        - 网络层及网络层之上使用IP
            IP地址放在IP数据报首部
            MAC地址放在MAC帧首部
            数据封装后
            IP数据报分组封装为MAC帧
            数据链路层看不见数据报分组中的IP地址
        - 决定了MAC地址无法跨网络通信
    - ARP Address Resolution Protocol
        - 无论网络层使用什么协议
            在实际网络的链路上传输数据帧
            必须使用硬件地址
        - 使用ARP进行映射
        - 每台主机设有ARP映射表
        - 工作原理
            - 主机A向本局域网上某台主机B发送IP数据报
                先在ARP高速缓存中查找有无主机B的IP
                有则将对应MAC地址写入MAC帧
                无则通过目的MAC地址
                FFFF-FF-FF-FF-FF的帧封装并广播ARP请求分组
            - 主机B收到该ARP请求分组，向ARP响应分组（单播）
                分组包含B的IP与MAC地址的映射
            - 主机A收到ARP响应分组
                写入ARP缓存
                按查询到的硬件地址发送MAC帧
## IPV6
## 路由协议
## IP组播
## 移动IP
## 网络层设备
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%C2%B7%E7%BD%91%E7%BB%9C%E5%B1%82/" data-id="clmdavayq000g4w8kgwhj3np1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-环境配置·Ubuntu1804安装CUDA和Pytorch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%C2%B7Ubuntu1804%E5%AE%89%E8%A3%85CUDA%E5%92%8CPytorch/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.180Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Init-Ubuntu-and-change-deb-pip-source"><a href="#Init-Ubuntu-and-change-deb-pip-source" class="headerlink" title="Init Ubuntu and change deb&amp;pip source"></a>Init Ubuntu and change deb&amp;pip source</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ebxeax/ebxeax.github.io/blob/main/toolbox/initUbuntu/initUbuntu.sh</span><br><span class="line">bash ./initUbuntu.sh</span><br></pre></td></tr></table></figure>

<h2 id="CUDA11-6"><a href="#CUDA11-6" class="headerlink" title="CUDA11.6"></a>CUDA11.6</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin</span><br><span class="line">sudo <span class="built_in">mv</span> cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda-repo-wsl-ubuntu-11-6-local_11.6.2-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-wsl-ubuntu-11-6-local_11.6.2-1_amd64.deb</span><br><span class="line">sudo apt-key add /var/cuda-repo-wsl-ubuntu-11-6-<span class="built_in">local</span>/7fa2af80.pub</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda</span><br></pre></td></tr></table></figure>
<h2 id="Load-library-path"><a href="#Load-library-path" class="headerlink" title="Load library path"></a>Load library path</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda/lib64:<span class="variable">$LD_LIBRARY_PAT</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="Test-nvidia-smi"><a href="#Test-nvidia-smi" class="headerlink" title="Test nvidia-smi"></a>Test nvidia-smi</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>

<h2 id="Test-nvcc-V"><a href="#Test-nvcc-V" class="headerlink" title="Test nvcc -V"></a>Test nvcc -V</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>

<h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure>
<h3 id="get-file-when-network-worse"><a href="#get-file-when-network-worse" class="headerlink" title="get file when network worse"></a>get file when network worse</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.pytorch.org/whl/cu113/torch-1.10.2%2Bcu113-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">wget https://download.pytorch.org/whl/cu113/torchvision-0.11.3%2Bcu113-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">wget </span><br><span class="line">pip3 install ./torch-1.10.2+cu113-cp36-cp36m-linux_x86_64.whl</span><br><span class="line">pip3 install ./torchvision-0.11.3+cu113-cp36-cp36m-linux_x86_64.whl</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%C2%B7Ubuntu1804%E5%AE%89%E8%A3%85CUDA%E5%92%8CPytorch/" data-id="clmdavayd000a4w8kbk2bcskh" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统·同步问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.158Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>经典同步问题</strong></p>
<p><em>1.生产者消费者问题</em></p>
<ul>
<li><p>一组生产者进程(Producer)</p>
</li>
<li><p>一组消费者进程(Consumer)</p>
</li>
<li><p>共享初始为空 大小为n的缓冲区(Buffer)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;  //mutex</span><br><span class="line">semaphore empty = n;  //buffer</span><br><span class="line">semaphore full = 0;   //full</span><br><span class="line"></span><br><span class="line">Producer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		Produce();</span><br><span class="line">		P(mutex);</span><br><span class="line">		add2Buffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(full);</span><br><span class="line">		P(mutex);</span><br><span class="line">		getFromBuffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		Consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>2.读者写者问题</em></p>
<ul>
<li>读者进程(Reader)</li>
<li>写者进程(Writer)</li>
<li>共享一个文档(Document)</li>
<li>多进程读，不可多进程写</li>
<li>写进程写，不可读</li>
<li>写进程检查是否有读进程读</li>
</ul>
<p><strong>读进程优先</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">Reader()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Writer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(rw);</span><br><span class="line">		write();</span><br><span class="line">		v(rw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写进程优先</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">semaphore w = 1;</span><br><span class="line">Writer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(rw);</span><br><span class="line">		Write();</span><br><span class="line">		V(rw);</span><br><span class="line">		V(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Reader()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(w);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>3.哲学家进餐问题</em></p>
<ul>
<li>5名哲学家(Philosopher)</li>
<li>每两名之间有一根筷子(Chopstick)</li>
<li>每名有一碗饭</li>
<li>吃完饭思考</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore Chopsticks[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">Philosopher()&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(Chopsticks[i]);</span><br><span class="line">		P(Chopsticks[(i+1)%5]);</span><br><span class="line">		V(mutex);</span><br><span class="line">		eat();</span><br><span class="line">		V(Chopsticks[i]);</span><br><span class="line">		V(Chopsticks[(i+1)%5]);</span><br><span class="line">		think();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.吸烟者问题</strong></p>
<ul>
<li>3个吸烟者进程(Smoker)</li>
<li>1个提供者进程(Offer)</li>
<li>Smoker1(paper, glue)</li>
<li>Smoker2(tobacco, glue)</li>
<li>Smoker3(paper, tobacco)</li>
<li>Offer(offer1) return paper, glue</li>
<li>Offer(offer2) return tobacco, glue</li>
<li>Offer(offer3) return paper, tobacco</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;	//store random num</span><br><span class="line">semaphore offer1 = 0;</span><br><span class="line">semaphore offer2 = 0;</span><br><span class="line">semaphore offer3 = 0;</span><br><span class="line">semaphore end = 0;</span><br><span class="line">Offer()&#123;</span><br><span class="line">	whlie(1)&#123;</span><br><span class="line">		num++;</span><br><span class="line">		num = num % 3;</span><br><span class="line">		if(num == 0)</span><br><span class="line">			V(offer1);</span><br><span class="line">		else if(num == 1)</span><br><span class="line">			V(offer2);</span><br><span class="line">		else</span><br><span class="line">			V(offer3);</span><br><span class="line">		P(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Smoker1()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(offer3);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Smoker2()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(offer2);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Smoker3()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(offer1);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>eg1</em></p>
<ul>
<li>3个进程P1 P2 P3</li>
<li>互斥使用N个单元的缓冲区(Buffer)</li>
<li>P1 produce() return (int num) put() @Buffer</li>
<li>P2</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/" data-id="clmdavaxx00024w8k1o2o5l8s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统·简述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E7%AE%80%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T10:04:16.141Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="并发、共享、虚拟、异步"><a href="#并发、共享、虚拟、异步" class="headerlink" title="并发、共享、虚拟、异步"></a>并发、共享、虚拟、异步</h2><p>没有并发和共享，就没有虚拟和异步</p>
<p>并发和共享互为存在条件</p>
<p>只有系统有并发性，才能导致异步性</p>
<h2 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h2><p>联机：交互式</p>
<p>脱机：批处理</p>
<h2 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h2><p>系统调用（广义指令）</p>
<h2 id="操作系统用作扩充机器"><a href="#操作系统用作扩充机器" class="headerlink" title="操作系统用作扩充机器"></a>操作系统用作扩充机器</h2><p>没有任何软件支持的计算机称为裸机</p>
<p>覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></p>
<h2 id="操作系统发展"><a href="#操作系统发展" class="headerlink" title="操作系统发展"></a>操作系统发展</h2><p>手工操作系统：独占全机、CPU等待手工操作</p>
<p>单道批处理操作系统：解决人机矛盾、CPU和I&#x2F;O设备速率不匹配、每次主机内存仅存放一道作业</p>
<p>多道批处理操作系统：资源利用率高、用户响应时间长、不提供人机交互</p>
<p>分时操作系统：同时、交互、独立、及时</p>
<p>实时操作系统：及时、可靠</p>
<p>网络操作系统</p>
<p>分布式计算机系统</p>
<p>个人操作系统</p>
<h2 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h2><p>CPU的状态划分为用户态、核心态</p>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>中断（外中断）：CPU执行指令意外的事件【设备发出的I&#x2F;O结束中断】</p>
<p>异常（内中断、陷入）：CPU执行指令内部的事件【非法操作码、地址越界、算术溢出、虚拟存储系统的缺页、陷入指令】</p>
<h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">关中断1--保存断点</span><br><span class="line">保存断点--中断服务程序寻址</span><br><span class="line">中断服务程序寻址--保存现场和屏蔽字</span><br><span class="line">保存现场和屏蔽字--开中断1</span><br><span class="line">开中断1--执行中断服务程序</span><br><span class="line">执行中断服务程序--关中断2</span><br><span class="line">关中断2--恢复现场和屏蔽字</span><br><span class="line">恢复现场和屏蔽字--开中断2</span><br><span class="line">开中断2--中断返回</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/OS/os_1.png" alt="os_1"></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>用户程序中调用操作系统提供的子功能</p>
<p>程序员可以使用高级语言，估计又要可以调用库函数，有的库函数封装了系统调用</p>
<p>用户进程执行 调用系统调用 <strong>进入核心态</strong> 执行系统调用 <strong>退出核心态</strong> 从系统调用返回</p>
<h2 id="大内核-微内核"><a href="#大内核-微内核" class="headerlink" title="大内核 微内核"></a>大内核 微内核</h2><p>大内核：内核代码庞大、结构混乱、难以维护、提供高性能系统服务</p>
<p>微内核：分离内核与服务、频繁切换用户核心态、操作系统执行开销大、内核内容少、方便维护</p>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p>进程:程序段、数据段、PCB进程控制块</p>
<p>进程映像是静态的，进程是动态的</p>
<p>动态、并发、独立、异步、结构</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>运行、就绪、阻塞、创建、结束</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>共享存储（需要同步互斥工具PV操作、低级：基于共享数据结构、高级：基于存储区）</p>
<p>消息传递（进程间数据交换以格式化消息为单位、直接&#x2F;间接）</p>
<p>管道通信（pipe文件用于连接一个读进程和写进程通信、半双工、全双工需要两条管道）</p>
<h2 id="线程-多线程"><a href="#线程-多线程" class="headerlink" title="线程 多线程"></a>线程 多线程</h2><p>引入进程目的：更好的使多道程序<strong>并发</strong>执行</p>
<p>引入线程目的：减小程序在并发执行付出的时空开销，提高并发性能</p>
<p>线程：线程ID、程序计数器、寄存器结合、堆栈组合、三态【就绪、阻塞、运行】</p>
<p>轻量实体，无系统资源，唯一ID和线程控制块</p>
<p>用户级线程ULT：操作系统意识不到ULT的存在，有关线程管理由应用程序完成</p>
<p>内核级线程KLT：有关线程管理由内核完成</p>
<p>多线程模型：多对一、一对一、多对多（m&lt;&#x3D;n）</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>调度层次：作业调度（高）、内存调度（中）、进程调度（低）</p>
<p>不能进行进程调度与切换：处理中断、进程处于内核态、其他需要完全屏蔽中断的原子操作</p>
<p>调度方式：非剥夺调度（非抢占方式、适用于大多批处理系统、不能用于分时系统和大多数的实时系统）、剥夺调度（抢占方式、有优先权、短进程优先、时间片原则）</p>
<p>调度基本原则：CPU利用率、系统吞吐量、周转时间、等待时间、响应时间</p>
<p>系统吞吐量：单位时间内CPU完成作业的数量</p>
<p>周转时间：从作业提交到作业完成所用时间</p>
<p>$$<br>T&#x3D;t_{等待}+t_{就绪队列排队}+t_{上处理机运行及输入输出}\<br>t_{周转时间}&#x3D;t_{作业完成时间}-t_{作业提交时间}\<br>t_{平均周转时间}&#x3D;\frac{\sum_i^n{t_i}}{n}(作业i的周转时间：t_i)\<br>t_{带权周转时间}&#x3D;\frac{t_{作业周转时间}}{t_{作业实际运转}}\geq{1}\<br>t_{带权平均周转时间}&#x3D;\frac{\sum_i^n{t_i}}{n}(作业i的带权周转时间：t_i)\<br>$$</p>
<p>等待时间：进程处于等处理机状态的时间和</p>
<p>响应时间：从用户提交请求到系统首次产生响应所用时间</p>
<p><strong>调度算法</strong>：先来先服务（FCFS、非抢占）、短作业优先（SJF、SPF）、抢占式短作业优先（SRTN）、优先级调度、高响应比优先（HRRN）、时间片轮转调度（RR）、多级反馈队列调度</p>
<p>1.先来先服务（FCFS）：简单，效率低；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于I&#x2F;O繁忙型作业；不会导致饥饿；多用于早期批处理系统</p>
<p>2.短作业优先（SJF、SPF）：当前已到达的最短作业先上处理机；有优先权、短进程优先、时间片原则；适用于实时&#x2F;分时操作系统；调度机制导致长作业长时间不被调度（饥饿）；多用于早期批处理系统</p>
<p>3.抢占式短作业优先（SRTN）：最短剩余时间算法</p>
<p>4.优先级调度：适用于实时操作系统；剥夺、非剥夺、静态优先级、动态优先级；系统进程用户进程 交互型进程非交互型进程 I&#x2F;O型进程计算型进程;不导致饥饿</p>
<p>5.高响应比优先（HRRN）：多用于早期批处理系统</p>
<p>$$<br>响应比R_p&#x3D;\frac{t_{等待时间}+t_{要求服务时间}}{t_{要求服务时间}}\geq{1}\<br>$$</p>
<p>6.时间片轮转调度（RR）：时间片大小设置对系统性能影响很大，时间片足够大，以至于所有进程都能在一个时间片完成，退化为先来先服务算法；时间片太小，处理机频繁在进程间切换，增加处理机开销；时间片长短由系统的响应时间、就绪队列的进程数目、系统处理能力决定；不会导致饥饿</p>
<p>7.多级反馈队列调度：设置多个就绪队列，各个队列赋予不同优先级，赋予各个队列中进程执行时间片的大小各个不同，一个进程进入内存后挂在一级队列队尾，时间片内未完成进入第二级队列队尾，第一级队列为空下一级运行；课本认为是抢占式算法；</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>临界资源：进入区、临界区、退出区、剩余区</p>
<p>同步：完成某种任务而建立的两个或多个进程，需要协调制约关系</p>
<p>互斥：一个进程使用临界资源另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程允许访问临界资源</p>
<p>为禁止两个进程进入同一个临界区，指定准则：</p>
<p>（1）空闲让进</p>
<p>（2）忙则等待</p>
<p>（3）有限等待</p>
<p>（4）让权等待</p>
<p>实现互斥基本方法：</p>
<p>（1）软件：单标志法（违背空闲让进）、双标志法先检查（违法忙则等待）、双标志法后检查（导致饥饿、违背空闲让进、有限等待）、皮特森算法Peterson’s Algorithm（违法让权等待）</p>
<p>（2）硬件：中断屏蔽方法（禁止一切中断发生、优：简单高效 &#x2F; 缺：不适用多处理机、用户进程，只适用于系统内核进程）、硬件指令方法TS&#x2F;TSL（优：适用于任意数目的进程，无论是单处理机还是多处理机，简单容易验证其正确性 &#x2F; 缺：不能实现让权等待，从等待中随机选择一个进临界区，可能导致饥饿）</p>
<p><strong>信号量</strong></p>
<p>整型信号量：用于表示资源数目的整型量S，只要信号量S&lt;&#x3D;0，就会不断测试，违背让权等待</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>)</span><br><span class="line">        S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录型信号量：一个用于记录资源数目的整型量value，一个进程链表L，链接等待资源的进程,S.L解决了让权等待的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        add <span class="keyword">this</span> process P to S.L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">block</span>(S.L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        <span class="built_in">wakeup</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现同步：前V后P，必须保证一前一后，实现同步关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    x;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    y;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现互斥：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seamphore S = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    进程P1的临界区;</span><br><span class="line">    <span class="built_in">V</span>(S);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">P</span>(S);</span><br><span class="line">   进程P2的临界区</span><br><span class="line">   <span class="built_in">V</span>(S);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现前驱关系：</p>
<p>对不同的临界资源设置不同的互斥信号量，PV必须成对出现</p>
<p><img src="/../imgs/OS/OS_mutex.png" alt="OS_mutex"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1 = a2 = b1 = b2 = c = d = e = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S1</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(a1);</span><br><span class="line">    <span class="built_in">V</span>(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S2</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(a1);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(b1);</span><br><span class="line">    <span class="built_in">V</span>(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S3</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(a2);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S4</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(b1);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S5</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(b2);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">V</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">S6</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(c);</span><br><span class="line">    <span class="built_in">P</span>(d);</span><br><span class="line">    <span class="built_in">P</span>(e);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一角度：图论出度（P）入度（V）</p>
<p><strong>管程</strong></p>
<p>名称、共享结构数据、一组过程（函数）、设置共享结构数据初值</p>
<p>互斥特性由编译器负责实现</p>
<p>各外部进程&#x2F;线程，只能从管程提供的特定入口才能访问共享数据</p>
<p>每次只允许一个进程在管程内执行某个内部过程</p>
<p><strong>经典同步问题</strong></p>
<p><em>1.生产者消费者问题</em></p>
<ul>
<li><p>一组生产者进程(Producer)</p>
</li>
<li><p>一组消费者进程(Consumer)</p>
</li>
<li><p>共享初始为空 大小为n的缓冲区(Buffer)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;  //mutex</span><br><span class="line">semaphore empty = n;  //buffer</span><br><span class="line">semaphore full = 0;   //full</span><br><span class="line"></span><br><span class="line">Producer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		Produce();</span><br><span class="line">		P(mutex);</span><br><span class="line">		add2Buffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(full);</span><br><span class="line">		P(mutex);</span><br><span class="line">		getFromBuffer();</span><br><span class="line">		V(mutex);</span><br><span class="line">		Consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>2.读者写者问题</em></p>
<ul>
<li>读者进程(Reader)</li>
<li>写者进程(Writer)</li>
<li>共享一个文档(Document)</li>
<li>多进程读，不可多进程写</li>
<li>写进程写，不可读</li>
<li>写进程检查是否有读进程读</li>
</ul>
<p><strong>读进程优先</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">Reader()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Writer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(rw);</span><br><span class="line">		write();</span><br><span class="line">		v(rw);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写进程优先</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">semaphore rw = 1;</span><br><span class="line">semaphore w = 1;</span><br><span class="line">Writer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(rw);</span><br><span class="line">		Write();</span><br><span class="line">		V(rw);</span><br><span class="line">		V(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Reader()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(mutex);</span><br><span class="line">		if(count == 0)</span><br><span class="line">			P(rw);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(w);</span><br><span class="line">		Read();</span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		if(count == 0)</span><br><span class="line">			V(rw);</span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>3.哲学家进餐问题</em></p>
<ul>
<li>5名哲学家(Philosopher)</li>
<li>每两名之间有一根筷子(Chopstick)</li>
<li>每名有一碗饭</li>
<li>吃完饭思考</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore Chopsticks[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">Philosopher()&#123;</span><br><span class="line">	do&#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		P(Chopsticks[i]);</span><br><span class="line">		P(Chopsticks[(i+1)%5]);</span><br><span class="line">		V(mutex);</span><br><span class="line">		eat();</span><br><span class="line">		V(Chopsticks[i]);</span><br><span class="line">		V(Chopsticks[(i+1)%5]);</span><br><span class="line">		think();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.吸烟者问题</strong></p>
<ul>
<li>3个吸烟者进程(Smoker)</li>
<li>1个提供者进程(Offer)</li>
<li>Smoker1(paper, glue)</li>
<li>Smoker2(tobacco, glue)</li>
<li>Smoker3(paper, tobacco)</li>
<li>Offer(offer1) return paper, glue</li>
<li>Offer(offer2) return tobacco, glue</li>
<li>Offer(offer3) return paper, tobacco</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;	//store random num</span><br><span class="line">semaphore offer1 = 0;</span><br><span class="line">semaphore offer2 = 0;</span><br><span class="line">semaphore offer3 = 0;</span><br><span class="line">semaphore end = 0;</span><br><span class="line">Offer()&#123;</span><br><span class="line">	whlie(1)&#123;</span><br><span class="line">		num++;</span><br><span class="line">		num = num % 3;</span><br><span class="line">		if(num == 0)</span><br><span class="line">			V(offer1);</span><br><span class="line">		else if(num == 1)</span><br><span class="line">			V(offer2);</span><br><span class="line">		else</span><br><span class="line">			V(offer3);</span><br><span class="line">		P(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Smoker1()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(offer3);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Smoker2()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(offer2);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Smoker3()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(offer1);</span><br><span class="line">		smoke();</span><br><span class="line">		V(end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>eg1</em></p>
<ul>
<li>3个进程P1 P2 P3</li>
<li>互斥使用N个单元的缓冲区(Buffer)</li>
<li>P1 produce() return (int num) put() @Buffer</li>
<li>P2</li>
</ul>
<p><strong>死锁</strong></p>
<p>多个进程因竞争资源造成的一种互相等待，若无外力作用，这些进程都将无法向前推进</p>
<p>死锁产生的原因：（1）系统资源的竞争（2）进程推进顺序非法（3）死锁产生的必要条件：互斥条件、不剥夺条件（已经至少保持了一个资源）、请求并保持条件、循环等待条件</p>
<p><strong>发生死锁一定有循环等待，但发生循环等待未必死锁</strong></p>
<p><strong>死锁的处理策略</strong></p>
<p><strong>死锁预防</strong>：破坏四个必要条件之一即可</p>
<ul>
<li><p>破坏互斥条件</p>
</li>
<li><p>破坏不剥夺条件</p>
</li>
<li><p>破坏请求并保持条件</p>
</li>
<li><p>破坏循环等待条件</p>
</li>
</ul>
<p>死锁避免：在资源分配过程，防止进入不安全状态</p>
<ul>
<li>银行家算法</li>
</ul>
<p>$$Need &#x3D; Max -Allocation$$</p>
<p>死锁检测和解除：系统分配进程时不做措施，应该提供死锁检测和解除的手段</p>
<ul>
<li>资源分配图</li>
</ul>
<p><img src="/../imgs/OS/source_allocation.png" alt="source_allocation"></p>
<p>请求边：从进程到资源<br>分配边：从资源到进程</p>
<ul>
<li>死锁定理：依次消除与不阻塞进程相连接的边，直到无边可消除</li>
<li>死锁解除：资源剥夺法、撤销进程法、进程回退法</li>
</ul>
<h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><p><strong>程序装入和链接</strong></p>
<ul>
<li>编译：编译程序将源代码编译成若干目标模块</li>
<li>链接：链接程序将编译后形成一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块</li>
<li>装入：装入程序装入模块装入内存运行</li>
</ul>
<p>链接方式</p>
<ul>
<li>静态：程序运行前，链接为一个完整可执行的程序</li>
<li>装入时动态：装入过程中，边装入边链接</li>
<li>运行时动态：程序执行过程需要该模块才进行</li>
</ul>
<p>装入方式：</p>
<ul>
<li>绝对装入：仅适用于单道程序，装入程序按照装入模块中的地址，将程序数据装入内存，逻辑地址与物理地址完全相同</li>
<li>可重定位装入（静态重定位）：一个作业装入内存，<strong>必须给它分配要求的全部内存空间</strong>，若没有足够的内存，则无法装入。一旦运行，作业进入内存，整个运行期间不能在内存中移动，也不能再申请内存空间</li>
<li>动态运行时装入（动态重定位）：程序在内存中发生移动，则需要采用动态的装入方式。装入程序把装入内存后，并不立即将装入模块中的相对地址转换为绝对地址，而是将<strong>地址转换推迟到程序真正要执行时才进行</strong>，需要重定位寄存器的支持</li>
</ul>
<p>逻辑地址和物理地址</p>
<ul>
<li>地址重定位：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成为物理地址</li>
</ul>
<p>内存保护</p>
<ul>
<li>在CPU中设置一堆上、下限寄存器，CPU要访问一个地址，分别和两个寄存器值相比，判断有无越界</li>
<li>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）来实现这种保护</li>
</ul>
<p><strong>连续分配管理方式</strong></p>
<p>单一连续分配</p>
<p>内存分为系统区、用户区，无需进行内存保护，内存中只允许有有一道程序</p>
<ul>
<li>优 简单无外部碎片</li>
<li>缺 只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低</li>
</ul>
<p><strong>固定分区分配</strong></p>
<p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，可从外存的后备作业队列中选择适当大小的作业装入</p>
<ul>
<li>划分分区方式：分区大小相等、分区大小不等</li>
</ul>
<p>问题</p>
<ul>
<li>程序可能太大放不进任何一块分区，用户不得不使用覆盖技术使用内存空间</li>
<li>主存利用率低，程序小也要占用一个分区，现象称为<strong>内部碎片</strong></li>
</ul>
<p><strong>动态分区分配</strong></p>
<p>又称可变分区分配，不预先划分内存，在进程装入内存时，根据进程大小动态地建立分区，并使分区的大小正好适合进程的需要</p>
<p>问题：所有分区外的存储空间会产生越来越多的碎片，克服外部碎片可以通过紧凑技术来解决</p>
<p>动态分区策略</p>
<ul>
<li><p>首次适应Fiist Fit：空闲分区以地址递增的次序链接，找到大小能满足要求的第一个空间。会使得内存的低地址部分出现很多小的空闲分区，每次分配查找时，都要经过这些分区，增加了查找的开销</p>
</li>
<li><p>最佳适应Best Fit：空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空间。性能通常很差，因为每次最佳的分配会留下很小难以利用的内存块，会产生最多的外部碎片。</p>
</li>
<li><p>最坏适应Worst Fit（最大适应Lasgest Fit）:以容量递减的次序链接，找到第一个能满足要求的空闲分区。选择最大的块，但却把最大的连续内存的划分开，会很快导致没有可用的大内存块，导致性能很差</p>
</li>
<li><p>邻近适用Next Fit（循环首次适应算法）：分配内存时从上次查询结束的位置开始继续查找。在一次扫描中，内存前面部分使用后再释放时，不会参与分配，导致在内存的末尾分配空间分裂为小碎片。</p>
</li>
</ul>
<p><em><strong>非连续分配</strong></em> </p>
<p><strong>基本分页存储管理方式</strong>：主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程以块为单位进行划分，进程在执行时，以块为单位逐个申请贮存中的空间</p>
<p>分页管理不会产生外部碎片，块的大小相对分区要小，进程按块划分，进程运行时按块申请主存可用空间并执行，进程只会在最后一个不完整的块，不产生主存碎片，，每个进程平均只产生半个块大小的内部碎片</p>
<ul>
<li><p>页面和页面大小：进程中的块称为页（page），内存中的块称为页框（page frame、或页帧）。外存也以同样的单位进行划分，称为块（block）。进程在执行时需要申请主存空间，要为每个页面分配主存中的可用页框，页和页框一一对应</p>
</li>
<li><p>地址结构</p>
</li>
</ul>
<p><img src="/../imgs/OS/single_page.png" alt="single_page"></p>
<ul>
<li>页表：通过查找页表即可找到相应的物理块</li>
</ul>
<p>基本地址变换：</p>
<p>将逻辑地址变换为内存中的物理地址，在系统中设置页表寄存器（PTR）存放内存起始地址F和页表长度M。</p>
<p><img src="/../imgs/OS/page_allocation_transform.png" alt="page_allocation_transform"></p>
<p>$$<br>\begin{aligned}<br>&amp;（1）页号P&#x3D;\frac{A}{L}\<br>&amp;（2）页内偏移量W&#x3D;A%L\<br>&amp;（3）比较页号P和页表长度M，P\geq M产生越界中断\<br>&amp;（4）页表中页号P对应的页表项地址A&#x3D;F+P<em>M\<br>&amp;（5）物理地址E&#x3D;b</em>L+W\<br>\end{aligned}<br>$$<br><em>页式管理中空间地址是一维的</em></p>
<p>问题</p>
<ul>
<li>每次访存均需地址变换，地址变换必须足够快，否则访存速度会降低</li>
<li>每个进程引入页表，用于存储映射机制，页表不能过大</li>
</ul>
<p>引入快表机制：在地址变换过程中加入具有并行查找能力的高速缓冲存储器——<strong>快表</strong>（相联存储器TLB，主存中的页表为<strong>慢表</strong>）</p>
<p><img src="/../imgs/OS/add_TLB_page_allocation_transform.png" alt="add_TLB_page_allocation_transform"></p>
<p>一次地址变换流程</p>
<p>（1）CPU给出逻辑地址，将页号送入高速缓冲寄存器，查询此页号是否存在于快表内</p>
<p>（2）若匹配到，直接取出对应页的页框号，与页内偏移拼接为物理地址，访存</p>
<p>（3）若未匹配到，访问慢表查询，读取页表项后复制到快表中，进行地址变换后访存</p>
<p><em>值得注意的是，题中是否说明快表初始为空以及快表慢表的查询机制，是否同时查询！</em></p>
<p>两级页表</p>
<ul>
<li>引入页表，执行时不需要调入所有内存页框，为了压缩页表，采取多级映射</li>
</ul>
<p><img src="/../imgs/OS/2_dim_page.png" alt="2_dim_page"></p>
<ul>
<li>多级页表大小不能超过一个页面</li>
</ul>
<p><img src="/../imgs/OS/2_dim_page_arch.png" alt="2_dim_page_arch"></p>
<p>$$<br>\begin{aligned}<br>&amp;逻辑地址：32bit\<br>&amp;以字节编址\<br>&amp;页表项：4B\<br>&amp;页面大小：4KB&#x3D;2^{12}B （页内偏移量）\<br>&amp;页号：32-12&#x3D;20\<br>&amp;全映射需要2^{20}个页表项\<br>&amp;共需4B<em>2^{20}&#x3D;4MB大小空间存储页表\<br>&amp;\<br>&amp;以40MB进程为例\<br>&amp;页表项：\frac{40MB}{4B</em>4KB}&#x3D;40KB\<br>&amp;需要\frac{40KB}{4KB}&#x3D;10页面\<br>&amp;整个进程需要\frac{40MB}{4KB}&#x3D;10*2^{10}个页面\<br>&amp;\<br>&amp;为了压缩页表，采取二级页表机制\<br>&amp;页表10页进行映射只需要10个页表项\<br>&amp;上一级页表只需要1页就已经足够2^{10}&#x3D;1024个页表项\<br>&amp;进程执行时，仅需将这一页的上级页表调入即可\<br>&amp;页面大小：4KB&#x3D;2^{12}B （页内偏移量）\<br>&amp;页号：32-12&#x3D;20\<br>&amp;顶级（一级）页表为1个页面\<br>&amp;一级页表项\frac{4KB}{4B}&#x3D;1K\<br>&amp;一级页表占用log_2{1K}&#x3D;10位\<br>&amp;二级页表占用20-10&#x3D;10位\<br>&amp;二级页表大小2^{10}*4B&#x3D;4KB\leq页面大小4KB\<br>\end{aligned}<br>$$</p>
<p><strong>基本分段存储管理方式</strong></p>
<p>分页管理是从计算机角度考虑设计，提高内存利用率，分页通过硬件机制实现</p>
<p>分段管理是从用户和程序员出发，方便编程、信息保护和共享、动态增长以及动态链接等方面的需要</p>
<p><img src="/../imgs/OS/single_seg.png" alt="single_seg"></p>
<p>段号决定每个进程最多可以分几个段，段内地址决定每个段内的最大长度</p>
<p>段表：每个进程都有一张逻辑空间与内存空间映射的段表</p>
<p><img src="/../imgs/OS/seg.png" alt="seg"></p>
<p>地址变换机构</p>
<p><img src="/../imgs/OS/segment_address_translation_mechanism.png" alt="分段地址变换机构"></p>
<p>$$<br>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W\<br>比较段号S和段表长度M，S\geq M,产生越界中断，否则继续执行\<br>段表中段号S对应段表项地址&#x3D;段表始址F+段号S*段表项长度\<br>段内偏移量\geq C，产生越界中断，否则继续执行\<br>取出段表项中该段的起始地址b，E&#x3D;b+W，得到物理地址E去访问内存\<br>$$</p>
<p>段的共享与保护：分段系统，通过两个作业的段表中相应表项指向被共享的段同一个物理副本，当地一个作业从共享段读取数据，必须防止另一个修改数据，不能修改的的代码称为<strong>纯代码、可重入代码</strong></p>
<p>段号和段内偏移需要显示给出，地址空间为二维</p>
<p><strong>段页式管理方式</strong></p>
<p>作业的地址空间被分为若干逻辑段，每段都有自己的段号，将每段分为若干大小的固定的页，内存空间分为若干和页面大小相同的存储块，对内存的分配以块为单位。</p>
<ul>
<li><p>段号位数决定每个进程最多可以分几个段</p>
</li>
<li><p>页号位数决定最多有几个页</p>
</li>
<li><p>页内偏移量决定页面大小、内存块的大小</p>
</li>
</ul>
<p>段页式系统的逻辑地址结构：</p>
<p><img src="/../imgs/OS/OS_page_seg_add.png" alt="OS_page_seg_add"></p>
<p>地址变换</p>
<p>需要三次访存，可以使用快表机制</p>
<p><img src="/../imgs/OS/segment_page_address_translation_mechanism.png" alt="segment_page_address_translation_mechanism"></p>
<p><strong>虚拟内存管理</strong></p>
<p>传统存储管理方式</p>
<ul>
<li>一次性：一次全部装入，才能开始</li>
<li>驻留性：装入后，常驻内存，任何部分都不会被换出，直至结束</li>
</ul>
<p>局部性原理</p>
<p>一个程序，一段时间内，只有一部分会被访问</p>
<ul>
<li>空间</li>
<li>时间</li>
</ul>
<p>虚拟存储器</p>
<p>将程序的一部分装入内存，其余部分留在外存，当所访问的部分不在内存，操作系统将需要的部分调入内存，将暂时不需要的内容换到外存</p>
<ul>
<li>多次性：无需一次全部装入，允许分为多次调入</li>
<li>对换性：无需常驻内存</li>
<li>虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于内存容量</li>
</ul>
<p>本质：用时间换空间</p>
<p>实现：请求分页、请求分段、请求段页式</p>
<p>支持：内存、外存、页表机制、段表机制、中断机构、地址变换机构</p>
<p><strong>请求分页管理方式</strong></p>
<p>访问不存在内存中的页面，通过调页将其调入，通过置换算法将暂时不需要的页面调到外存上</p>
<p>页表机制</p>
<p><img src="/../imgs/OS/Request_paging_page_table_mechanism.png" alt="Request_paging_page_table_mechanism"></p>
<p>$$<br>状态位P：指示是否调入内存\<br>访问字段A：记录一段时间内被访问的次数\<br>修改位M：标识页面调入内存后是否被修改过\<br>外存地址：指出该页在外存上的地址，通常是物理块号\<br>$$</p>
<p>缺页中断机制</p>
<p>访问页面不在内存中时，产生一个缺页中断，请求操作系统将缺页调入内存，将缺页的进程阻塞，若内存有闲置的空闲块，则分配一个块，将页面装入，并修改页表相应的页表项，若内存中无空闲块，则淘汰某页，淘汰页若在内存中修改过需要同步，写回外存</p>
<p>地址变换机构</p>
<p><img src="/../imgs/OS/request_paging_address_translation_mechanism.png" alt="request_paging_address_translation_mechanism"></p>
<p>页面置换算法</p>
<ul>
<li>最佳置换算法OPT</li>
</ul>
<p>选择的被淘汰页是以后永不使用的页面，或是最长时间内不再被访问的页面</p>
<ul>
<li>先进先出算法FIFO</li>
</ul>
<p>优先淘汰最早进入内存的页面，即内存中驻留时间最久的页面</p>
<p>会产生所分配的物理块增大页故障数不减反增的异常现象，<strong>Belady异常</strong></p>
<ul>
<li>最近最久未使用算法LRU</li>
</ul>
<p>选择最近最长时间未访问过的页面予以淘汰，为每个页面设置一个访问字段记录上次被访问所经历的时间</p>
<p>性能较好，需要寄存器和栈的硬件支持</p>
<ul>
<li>时钟置换算法CLOCK</li>
</ul>
<p>简单的CLOCK算法：每帧关联一个附加位，使用位<strong>u</strong>，连成一个循环队列。某页装入时，使用位置为1；被访问时，使用位置为1；置换时，操作系统扫描缓冲区，每当遇到一个使用位为1的帧，置为0；最后停留在第一个使用位为0的帧</p>
<p>CLOCK算法性能比较接近LRU算法</p>
<p>改进的CLOCK算法：再增加一个修改位<strong>m</strong>，<strong>P(u,m)</strong></p>
<p>第一轮扫描，指针扫描过的页面使用位<strong>u</strong>置为0</p>
<p>第一轮扫描中，未找到使用位<strong>u</strong>为0的页面进行第二轮扫描</p>
<p>第二轮扫描，第一个页面置换出，换入页面<strong>m</strong>修改位置为1，并将指针后移</p>
<p><strong>页面分配策略</strong></p>
<p>一个进程分配的物理页框的集合，分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而提高处理机的效率；一个进程页数过少，基于局部性原理，页错误率会相对较高；页数过多，基于局部性原理，给特定的进程分配更多主存空间对该进程的错误率没有明显改善。</p>
<p>策略：固定分配局部置换、可变分配全局置换、可变分配局部置换（没有固定分配全局分配）</p>
<p>调入时机：预调页策略、请求调页策略</p>
<p>从何处调页：系统拥有足够的对换区间、系统缺少足够的对换区间、UNIX方式</p>
<p><strong>抖动</strong></p>
<p>某进程频繁访问的页面数目高于可用的物理页帧数目</p>
<p><strong>工作集</strong></p>
<p>在某段时间间隔内，进程要访问的页面集合</p>
<p>一般，分配给进程的物理块数（驻留集大小）要大于工作集大小</p>
<h1 id="第四章-文件系统"><a href="#第四章-文件系统" class="headerlink" title="第四章 文件系统"></a>第四章 文件系统</h1><p><strong>文件</strong></p>
<p>文件结构：数据项、记录、文件</p>
<p>属性：名称、标识符、类型、位置、大小、保护、时间</p>
<p>所有文件的信息都保存在目录结构中，而目录结构保存在外存上，文件信息在需要时调入内存。</p>
<p>基本操作：创建、写、读、重定位、删除、截断</p>
<p>文件逻辑结构</p>
<ul>
<li>无结构文件（流式文件）</li>
</ul>
<p>二进制式字符流组成</p>
<ul>
<li>有结构文件（记录式文件）</li>
</ul>
<p>顺序文件</p>
<p>索引文件</p>
<p>索引顺序文件</p>
<p>直接文件或散列文件</p>
<p><strong>目录结构</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%C2%B7%E7%AE%80%E8%BF%B0/" data-id="clmdavay100034w8k757sd1pq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/10/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-09-10T09:52:40.067Z" itemprop="datePublished">2023-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/09/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/10/hello-world/" data-id="clmdavaxm00014w8kdnf68hu5" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%C2%B7%E7%AE%80%E8%BF%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%BA%BF%E6%80%A7%E8%A1%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%80%E8%BF%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>